version:
  version: 1.0.1
  run_id: "40a80d6e8c977067"
  target: Tofino
phv ingress:
  ig_md.ifindex: H61
  ig_md.port: H44(0..8)
  ig_md.egress_port: H0(0..8)
  ig_md.port_lag_index.0-7: B10
  ig_md.port_lag_index.8-9: B39(0..1)
  ig_md.egress_ifindex: H74
  ig_md.bd: H47
  ig_md.vrf: H80(0..13)
  ig_md.nexthop: W8(16..31)
  ig_md.timestamp.0-15: H60
  ig_md.timestamp.16-47: W15
  ig_md.hash: W1
  ig_md.flags.ipv4_checksum_err: H9(2)
  ig_md.flags.link_local: H15(8)
  ig_md.flags.routed: B7(0)
  ig_md.flags.acl_deny: B7(7)
  ig_md.flags.racl_deny: B10(3)
  ig_md.flags.port_vlan_miss: B51(7)
  ig_md.flags.rmac_hit: B54(6)
  ig_md.flags.dmac_miss: H9(13)
  ig_md.flags.myip: H9(14)
  ig_md.flags.glean: B10(2)
  ig_md.flags.flood_to_multicast_routers: B39(0)
  ig_md.checks.mrpf: B39(1)
  ig_md.bypass: H76
  ig_md.ipv4.unicast_enable: B51(0)
  ig_md.ipv4.multicast_enable: B51(1)
  ig_md.ipv4.multicast_snooping: B51(2)
  ig_md.ipv6.unicast_enable: B51(3)
  ig_md.ipv6.multicast_enable: B51(4)
  ig_md.ipv6.multicast_snooping: B51(5)
  ig_md.port_lag_label: H75
  ig_md.bd_label: H79
  ig_md.l4_port_label.0-7: B52
  ig_md.l4_port_label.8-15: B53
  ig_md.drop_reason: B41
  ig_md.cpu_reason: W8(0..15)
  ig_md.rmac_group.0-7: B50
  ig_md.rmac_group.8-9: H80(14..15)
  ig_md.lkp.pkt_type: B7(1..2)
  ig_md.lkp.mac_src_addr.0-15: H46
  ig_md.lkp.mac_src_addr.16-47: W7
  ig_md.lkp.mac_dst_addr.0-15: H59
  ig_md.lkp.mac_dst_addr.16-47: W10
  ig_md.lkp.mac_type: H39
  ig_md.lkp.pcp: H53(0..2)
  ig_md.lkp.arp_opcode: H33
  ig_md.lkp.ip_type: H4(10..11)
  ig_md.lkp.ip_proto: H13(8..15)
  ig_md.lkp.ip_ttl: H15(0..7)
  ig_md.lkp.ip_tos: H13(0..7)
  ig_md.lkp.ip_frag: H4(12..13)
  ig_md.lkp.ip_src_addr.0-23: W3(0..23)
  ig_md.lkp.ip_src_addr.24-31: W0(13..20)
  ig_md.lkp.ip_src_addr.32-63: W14
  ig_md.lkp.ip_src_addr.64-95: W36
  ig_md.lkp.ip_src_addr.96-127: W12
  ig_md.lkp.ip_dst_addr.0-31: W5
  ig_md.lkp.ip_dst_addr.32-63: W37
  ig_md.lkp.ip_dst_addr.64-95: W38
  ig_md.lkp.ip_dst_addr.96-127: W39
  ig_md.lkp.tcp_flags: B36
  ig_md.lkp.l4_src_port.0-7: B13
  ig_md.lkp.l4_src_port.8-15: B15
  ig_md.lkp.l4_dst_port: H11
  ig_md.multicast.id: H3
  ig_md.multicast.mode: B54(4..5)
  ig_md.multicast.rpf_group: H77
  ig_md.stp.state_: H6(13..14)
  ig_md.qos.trust_mode: H6(11..12)
  ig_md.qos.group: H7(9..13)
  ig_md.qos.tc: B11
  ig_md.qos.color: B6(0..1)
  ig_md.qos.acl_policer_color: B6(2..3)
  ig_md.qos.storm_control_color: B9(5..6)
  ig_md.qos.meter_index: H53(3..12)
  ig_md.qos.qid: B4(0..4)
  ig_md.qos.icos: B9(2..4)
  ig_md.learning.bd_mode: B51(6)
  ig_md.learning.port_mode: B9(7)
  ig_md.mirror.src: B8
  ig_md.mirror.type: B1
  ig_md.mirror.session_id: H5(0..9)
  ig_md.dtel.report_type: B5(0..3)
  ig_md.dtel.session_id: H4(0..9)
  hdr.bridged_md.src: B0
  hdr.bridged_md.type: TB4
  hdr.bridged_md.base_ingress_ifindex: H61
  hdr.bridged_md.base_ingress_bd: H47
  hdr.bridged_md.base_nexthop: W8(16..31)
  hdr.bridged_md.base_cpu_reason: W8(0..15)
  hdr.bridged_md.base_timestamp.0-15: H60
  hdr.bridged_md.base_timestamp.16-47: W15
  hdr.bridged_md.base_tc: B11
  hdr.bridged_md.dtel_hash: W1
  hdr.bridged_md.__pad_0: B7(4..7)
  hdr.bridged_md.base_peer_link: B7(3)
  hdr.bridged_md.base_pkt_type: B7(1..2)
  hdr.bridged_md.base_routed: B7(0)
  hdr.bridged_md.__pad_1: B6(2..7)
  hdr.bridged_md.base_color: B6(0..1)
  hdr.bridged_md.__pad_2: B5(4..7)
  hdr.bridged_md.dtel_report_type: B5(0..3)
  hdr.bridged_md.__pad_3: B3(5..7)
  hdr.bridged_md.base_qid: B3(0..4)
  hdr.bridged_md.__pad_4: H44(9..15)
  hdr.bridged_md.base_ingress_port: H44(0..8)
  hdr.bridged_md.__pad_5: H1(9..15)
  hdr.bridged_md.dtel_egress_port: H1(0..8)
  hdr.bridged_md.__pad_6: H4(10..15)
  hdr.bridged_md.dtel_session_id: H4(0..9)
  hdr.ethernet.dst_addr.0-15: H58
  hdr.ethernet.dst_addr.16-47: W9
  hdr.ethernet.src_addr.0-15: H45
  hdr.ethernet.src_addr.16-47: W6
  hdr.ethernet.ether_type: H42
  hdr.ipv4.version: H12(12..15)
  hdr.ipv4.ihl: H12(8..11)
  hdr.ipv4.diffserv: H12(0..7)
  hdr.ipv4.total_len: TH7
  hdr.ipv4.identification: TH9
  hdr.ipv4.flags: H40(13..15)
  hdr.ipv4.frag_offset: H40(0..12)
  hdr.ipv4.ttl: H14(8..15)
  hdr.ipv4.protocol: H14(0..7)
  hdr.ipv4.hdr_checksum: TH8
  hdr.ipv4.src_addr: W2
  hdr.ipv4.dst_addr: W4
  hdr.icmp.type: B12
  hdr.icmp.code: B14
  hdr.icmp.checksum: TH6
  hdr.igmp.type: TH6(8..15)
  hdr.igmp.code: TH6(0..7)
  hdr.igmp.checksum.0-7: TB5
  hdr.igmp.checksum.8-15: TB6
  hdr.tcp.src_port.0-7: B12
  hdr.tcp.src_port.8-15: B14
  hdr.tcp.dst_port: H10
  hdr.tcp.seq_no: TW7
  hdr.tcp.ack_no.0-7: TB6
  hdr.tcp.ack_no.8-15: TB7
  hdr.tcp.ack_no.16-31: TH10
  hdr.tcp.data_offset: TB5(4..7)
  hdr.tcp.res: TB5(0..3)
  hdr.tcp.flags: B40
  hdr.tcp.window: TH6
  hdr.tcp.checksum: TW6(16..31)
  hdr.tcp.urgent_ptr: TW6(0..15)
  hdr.udp.src_port.0-7: B12
  hdr.udp.src_port.8-15: B14
  hdr.udp.dst_port: H10
  hdr.udp.length: TW6(16..31)
  hdr.udp.checksum: TW6(0..15)
  hdr.ipv4_option.type: TW5(24..31)
  hdr.ipv4_option.length: TW5(16..23)
  hdr.ipv4_option.value: TW5(0..15)
  hdr.arp.hw_type: TW5(16..31)
  hdr.arp.proto_type: TW5(0..15)
  hdr.arp.hw_addr_len: TH6(8..15)
  hdr.arp.proto_addr_len: TH6(0..7)
  hdr.arp.opcode: H40
  hdr.ipv6.version: H12(12..15)
  hdr.ipv6.traffic_class: H12(4..11)
  hdr.ipv6.flow_label.0-15: TH7
  hdr.ipv6.flow_label.16-19: H12(0..3)
  hdr.ipv6.payload_len: TH8
  hdr.ipv6.next_hdr: H14(8..15)
  hdr.ipv6.hop_limit: H14(0..7)
  hdr.ipv6.src_addr.0-31: W2
  hdr.ipv6.src_addr.32-63: W13
  hdr.ipv6.src_addr.64-95: W32
  hdr.ipv6.src_addr.96-127: W11
  hdr.ipv6.dst_addr.0-31: W4
  hdr.ipv6.dst_addr.32-63: W33
  hdr.ipv6.dst_addr.64-95: W34
  hdr.ipv6.dst_addr.96-127: W35
  hdr.vlan_tag$0.pcp: H56(13..15)
  hdr.vlan_tag$0.cfi: H56(12)
  hdr.vlan_tag$0.vid: H56(0..11)
  hdr.vlan_tag$0.ether_type: H41
  hdr.vlan_tag$1.pcp: TW4(29..31)
  hdr.vlan_tag$1.cfi: TW4(28)
  hdr.vlan_tag$1.vid: TW4(16..27)
  hdr.vlan_tag$1.ether_type: TW4(0..15)
  hdr.fabric.dst_port_or_group: H73
  hdr.cpu.tx_bypass: H1(2)
  hdr.cpu.ingress_port: H43
  hdr.cpu.ingress_bd: W8(0..15)
  hdr.cpu.ether_type: H38
  ig_intr_md_for_tm.ucast_egress_port: H0(0..8)
  ig_intr_md_for_tm.bypass_egress: H9(0)
  ig_intr_md_for_tm.deflect_on_drop: H9(1)
  ig_intr_md_for_tm.ingress_cos: B9(2..4)
  ig_intr_md_for_tm.qid: B4(0..4)
  ig_intr_md_for_tm.copy_to_cpu: B9(7)
  ig_intr_md_for_tm.packet_color: B10(0..1)
  ig_intr_md_for_tm.mcast_grp_b: H2
  ig_intr_md_for_tm.level2_mcast_hash: W0(0..12)
  ig_intr_md_for_tm.level2_exclusion_id: H7(0..8)
  ig_intr_md_for_tm.rid: H8
  smac_src_miss: H7(14)
  smac_src_move: H62
  ig_intr_md_for_dprsr.drop_ctl: H9(2..4)
  ig_intr_md_for_dprsr.digest_type: B2(0..2)
  ig_intr_md_for_dprsr.mirror_type: B1(0..2)
  acl_stats_index.0-7: H9(5..12)
  acl_stats_index.8-11: B7(3..6)
  mirror_acl_stats_index.0-7: W0(21..28)
  mirror_acl_stats_index.8-11: B6(4..7)
  unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index: H1(3..12)
  unicast_ipv6_fib_fib_lpm__metadata.unicast_ipv6_fib_fib_lpm_partition_index: H78(0..9)
  multicast_multicast_hit: B54(7)
  multicast_rpf_check: H78
  racl_stats_index.0-7: W3(24..31)
  racl_stats_index.8-11: B54(0..3)
  system_acl_copp_meter_id: B50
  __pad_1: H5(10..15)
  __pad_5: H0(9..15)
  __pad_6: B4(5..7)
  hdr.bridged_md.$valid: H6(0)
  hdr.ethernet.$valid: H6(1)
  hdr.ipv4.$valid: H6(2)
  hdr.icmp.$valid: H6(3)
  hdr.igmp.$valid: H6(4)
  hdr.tcp.$valid: H6(5)
  hdr.udp.$valid: H6(6)
  hdr.ipv4_option.$valid: H6(7)
  hdr.arp.$valid: H6(8)
  hdr.ipv6.$valid: H6(9)
  hdr.cpu.$valid: H6(10)
  hdr.vlan_tag.$stkvalid: B9(0..1)
  hdr.vlan_tag$0.$valid: B9(1)
  hdr.vlan_tag$1.$valid: B9(0)
phv egress:
  eg_intr_md_from_prsr.global_tstamp.0-31: W17
  eg_intr_md_from_prsr.global_tstamp.32-47: TH12
  eg_intr_md.egress_port: H32(0..8)
  eg_intr_md.enq_qdepth: W29(0..18)
  eg_intr_md.egress_rid: H63
  eg_md.pkt_src: B43
  eg_md.pkt_length: H17
  eg_md.pkt_type: B44(1..2)
  eg_md.port_lag_index: H57(0..9)
  eg_md.port.0-7: B26
  eg_md.port.8-8: B24(0)
  eg_md.ingress_port: H30(0..8)
  eg_md.ingress_ifindex: H68
  eg_md.bd: H64
  eg_md.nexthop: W30(0..15)
  eg_md.timestamp: W18
  eg_md.ingress_timestamp.0-31: W16
  eg_md.ingress_timestamp.32-47: H71
  eg_md.flags.routed: B44(0)
  eg_md.flags.acl_deny: B49(6)
  eg_md.checks.same_bd: H72
  eg_md.checks.mtu: H19
  eg_md.checks.stp: H57(10)
  eg_md.bypass: B22
  eg_md.lkp.pcp: H57(13..15)
  eg_md.qos.group: W31(6..10)
  eg_md.qos.tc: W25(8..15)
  eg_md.qos.color: B45(0..1)
  eg_md.qos.qid: B32(0..4)
  eg_md.qos.qdepth.0-7: B35
  eg_md.qos.qdepth.8-18: H67(0..10)
  eg_md.mirror.src: B20
  eg_md.mirror.type: B17
  eg_md.mirror.session_id: H20(0..9)
  eg_md.dtel.report_type: B33(0..3)
  eg_md.dtel.latency: W20
  eg_md.dtel.session_id: H23(0..9)
  eg_md.dtel.hash.0-15: H24
  eg_md.dtel.hash.16-31: H26
  eg_md.cpu_reason: H69
  eg_md.drop_reason: B46
  hdr.dtel_drop_report.pad0: H55(9..15)
  hdr.dtel_drop_report.ingress_port: H55(0..8)
  hdr.dtel_drop_report.pad1: B23(1..7)
  hdr.dtel_drop_report.egress_port.0-7: B25
  hdr.dtel_drop_report.egress_port.8-8: B23(0)
  hdr.dtel_drop_report.pad2: TB2(5..7)
  hdr.dtel_drop_report.queue_id: TB2(0..4)
  hdr.dtel_drop_report.drop_reason: TB0
  hdr.dtel_drop_report.reserved: TH5
  hdr.cpu.egress_queue: B16(3..7)
  hdr.cpu.tx_bypass: B16(2)
  hdr.cpu.capture_ts: B16(1)
  hdr.cpu.reserved: B16(0)
  hdr.cpu.ingress_port: H31
  hdr.cpu.ingress_ifindex: H68
  hdr.cpu.ingress_bd: H64
  hdr.cpu.reason_code: H69
  hdr.cpu.ether_type: H34
  hdr.ethernet.dst_addr.0-15: H51
  hdr.ethernet.dst_addr.16-47: W24
  hdr.ethernet.src_addr.0-15: H49
  hdr.ethernet.src_addr.16-47: W22
  hdr.ethernet.ether_type: H37
  hdr.ipv4.version: B38(4..7)
  hdr.ipv4.ihl: B38(0..3)
  hdr.ipv4.diffserv: B37
  hdr.ipv4.total_len: H16
  hdr.ipv4.identification: W26(16..31)
  hdr.ipv4.flags: W26(13..15)
  hdr.ipv4.frag_offset: W26(0..12)
  hdr.ipv4.ttl: B19
  hdr.ipv4.protocol: B34
  hdr.ipv4.hdr_checksum: TH0
  hdr.ipv4.src_addr: W27
  hdr.ipv4.dst_addr: W28
  hdr.ipv6.version: B37(4..7)
  hdr.ipv6.traffic_class.0-3: B34(4..7)
  hdr.ipv6.traffic_class.4-7: B37(0..3)
  hdr.ipv6.flow_label.0-15: TH0
  hdr.ipv6.flow_label.16-19: B34(0..3)
  hdr.ipv6.payload_len: H16
  hdr.ipv6.next_hdr: TB3
  hdr.ipv6.hop_limit: B19
  hdr.ipv6.src_addr.0-31: TW2
  hdr.ipv6.src_addr.32-63: TW3
  hdr.ipv6.src_addr.64-79: TH1
  hdr.ipv6.src_addr.80-95: TH2
  hdr.ipv6.src_addr.96-111: TH3
  hdr.ipv6.src_addr.112-127: TH4
  hdr.ipv6.dst_addr.0-31: TW8
  hdr.ipv6.dst_addr.32-63: TW9
  hdr.ipv6.dst_addr.64-95: TW10
  hdr.ipv6.dst_addr.96-127: TW11
  hdr.vlan_tag$0.pcp: H54(13..15)
  hdr.vlan_tag$0.cfi: H54(12)
  hdr.vlan_tag$0.vid: H54(0..11)
  hdr.vlan_tag$0.ether_type: H35
  hdr.vlan_tag$1.pcp: TW0(29..31)
  hdr.vlan_tag$1.cfi: TW0(28)
  hdr.vlan_tag$1.vid: TW0(16..27)
  hdr.vlan_tag$1.ether_type: TW0(0..15)
  hdr.dtel_switch_local_report.pad0: H29(9..15)
  hdr.dtel_switch_local_report.ingress_port: H29(0..8)
  hdr.dtel_switch_local_report.pad1: H28(9..15)
  hdr.dtel_switch_local_report.egress_port: H28(0..8)
  hdr.dtel_switch_local_report.pad2: TW0(29..31)
  hdr.dtel_switch_local_report.queue_id: TW0(24..28)
  hdr.dtel_switch_local_report.pad3: TW0(19..23)
  hdr.dtel_switch_local_report.queue_occupancy: TW0(0..18)
  hdr.dtel_switch_local_report.timestamp: TW2
  hdr.fabric.reserved: B16
  hdr.fabric.color: B16(5..7)
  hdr.fabric.qos: B16(0..4)
  hdr.fabric.reserved2: B16
  hdr.fabric.dst_port_or_group.0-7: B16
  hdr.fabric.dst_port_or_group.8-15: B16
  hdr.erspan_type2.version: H65(12..15)
  hdr.erspan_type2.vlan: H65(0..11)
  hdr.erspan_type2.cos_en_t: H21(10..15)
  hdr.erspan_type2.session_id: H21(0..9)
  hdr.erspan_type2.reserved: TW1(20..31)
  hdr.erspan_type2.index: TW1(0..19)
  hdr.gre.C: TB1(7)
  hdr.gre.R: TB1(6)
  hdr.gre.K: TB1(5)
  hdr.gre.S: TB1(4)
  hdr.gre.s: TB1(3)
  hdr.gre.recurse: TB1(0..2)
  hdr.gre.flags: B16(3..7)
  hdr.gre.version: B16(0..2)
  hdr.gre.proto: H70
  hdr.inner_ethernet.dst_addr.0-15: H50
  hdr.inner_ethernet.dst_addr.16-47: W23
  hdr.inner_ethernet.src_addr.0-15: H48
  hdr.inner_ethernet.src_addr.16-47: W21
  hdr.inner_ethernet.ether_type: H36
  hdr.erspan_type3.version: H66(12..15)
  hdr.erspan_type3.vlan: H66(0..11)
  hdr.erspan_type3.cos_bso_t: H22(10..15)
  hdr.erspan_type3.session_id: H22(0..9)
  hdr.erspan_type3.timestamp: W19
  hdr.erspan_type3.sgt.0-7: B16
  hdr.erspan_type3.sgt.8-15: B16
  hdr.erspan_type3.p: H52(15)
  hdr.erspan_type3.ft: H52(10..14)
  hdr.erspan_type3.hw_id: H52(4..9)
  hdr.erspan_type3.d: H52(3)
  hdr.erspan_type3.gra: H52(1..2)
  hdr.erspan_type3.o: H52(0)
  hdr.erspan_platform.id: B16(2..7)
  hdr.erspan_platform.info.0-7: B16
  hdr.erspan_platform.info.8-15: B16
  hdr.erspan_platform.info.16-23: B16
  hdr.erspan_platform.info.24-31: B16
  hdr.erspan_platform.info.32-39: B16
  hdr.erspan_platform.info.40-47: B16
  hdr.erspan_platform.info.48-55: B16
  hdr.erspan_platform.info.56-57: B16(0..1)
  hdr.udp.src_port: H25
  hdr.udp.dst_port: H27
  hdr.udp.length: H18
  hdr.udp.checksum.0-7: B16
  hdr.udp.checksum.8-15: B16
  rewrite_smac_index: H72
  dtel_drop_report_flag: H57(11..12)
  dtel_queue_report_flag: H63(0)
  dtel_queue_report_quota: W31(11..26)
  dtel_flow_report_digest: H81
  dtel_flow_report_flag: B42(0..1)
  eg_intr_md_for_dprsr.drop_ctl: B21(2..4)
  eg_intr_md_for_dprsr.mirror_type: B18(0..2)
  hdr.dtel.version: W25(28..31)
  hdr.dtel.next_proto: W25(24..27)
  hdr.dtel.d_q_f: W25(21..23)
  hdr.dtel.reserved: W25(6..20)
  hdr.dtel.hw_id: W25(0..5)
  hdr.dtel.seq_number: W29
  hdr.dtel.timestamp: W17
  hdr.dtel.switch_id: W30
  __pad_7: H20(10..15)
  __pad_8: H30(9..15)
  __pad_9: H23(10..15)
  __pad_10: B33(4..7)
  __pad_12: B24(1..7)
  __pad_13: B32(5..7)
  __pad_14: H67(11..15)
  hdr.dtel_drop_report.$valid: W31(0)
  hdr.cpu.$valid: W31(1)
  hdr.ethernet.$valid: B49(0)
  hdr.ipv4.$valid: B49(1)
  hdr.ipv6.$valid: W31(2)
  hdr.dtel_switch_local_report.$valid: W31(3)
  hdr.fabric.$valid: W31(4)
  hdr.erspan_type2.$valid: B48(1)
  hdr.gre.$valid: B49(2)
  hdr.inner_ethernet.$valid: B48(0)
  hdr.erspan_type3.$valid: B49(3)
  hdr.erspan_platform.$valid: B49(4)
  hdr.udp.$valid: B49(5)
  hdr.dtel.$valid: W31(5)
  hdr.vlan_tag.$stkvalid: B21(0..1)
  hdr.vlan_tag$0.$valid: B21(1)
  hdr.vlan_tag$1.$valid: B21(0)
parser ingress:
  start: start
  init_zero: [ B10, B39, H74, H47, H80, W8, H9, H15, B7, B51, B54, H76, H75, H79, B52, B53, B41, B50, H46, W7, H59, W10, H39, H53, H33, H4, H13, W3, W0, W14, W36, W12, W5, W37, W38, W39, B36, B13, B15, H11, H3, H77, H6, H7, B6, B9, B4, B8, H5, H8, H62, H78, B0 ]
  bitwise_or: [ B9, H6 ]
  hdr_len_adj: 16
  states:
    start:  # from state ingress::start
      *:
        0..1: H44  # bit[7..15] -> H44 bit[8..0]: ingress::ig_md.port
        2..5: W15  # ingress::ig_md.timestamp[47:16].16-47
        6..7: H60  # ingress::ig_md.timestamp[15:0].0-15
        8: B39  # bit[70..71] -> B39 bit[1..0]: ingress::ig_md.port_lag_index[9:8].8-9
        9: B10  # ingress::ig_md.port_lag_index[7:0].0-7
        10..11: H75  # ingress::ig_md.port_lag_label
        12..13: H61  # ingress::ig_md.ifindex
        16..19: W9  # ingress::hdr.ethernet.dst_addr[47:16].16-47
        22..25: W6  # ingress::hdr.ethernet.src_addr[47:16].16-47
        save: { half : 28..29, byte0 : 0, byte1 : 1 }
        shift: 20
        buf_req: 30
        next: start.$split_0
    start.$split_0:  # from state ingress::start.$split_0
      match: [ half, byte0, byte1 ]
      0x0800****:
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        shift: 10
        buf_req: 10
        next: parse_ipv4
      0x0806****:
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        shift: 10
        buf_req: 10
        next: parse_arp
      0x86dd****:
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        shift: 10
        buf_req: 10
        next: parse_ipv6
      0x8100****:
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        save: { half : 12..13 }
        shift: 10
        buf_req: 14
        next: parse_vlan
      0x8100****:
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        save: { half : 12..13 }
        shift: 10
        buf_req: 14
        next: parse_vlan
      0x8906****:
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        shift: 10
        buf_req: 10
        next: parse_fcoe
      value_set SwitchIngressParser.cpu_port 1:
        handle: 511
        field_mapping:
          hdr.ethernet.ether_type(0..15) : half(0..15)
          ig_intr_md.ingress_port(0..7) : byte1(0..7)
          ig_intr_md.ingress_port(8..8) : byte0(0..0)
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        shift: 10
        buf_req: 10
        next: parse_cpu
      0x********:
        0..1: H58  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H45  # ingress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H42  # ingress::hdr.ethernet.ether_type
        H6: 2  # value 1 -> H6 bit[1]: ingress::hdr.ethernet.$valid
        shift: 10
        buf_req: 10
        next: end
    parse_ipv4:  # from state ingress::parse_ipv4
      *:
        checksum 0:
          type: VERIFY
          mask: [ 0, 1, 2..3, 4..5, 6, 6..7, 8, 9, 10..11, 12..15, 16..19 ]
          swap: 0
          start: 1
          end: 0
        0..1: H12
            # - bit[0..3] -> H12 bit[15..12]: ingress::hdr.ipv4.version
            # - bit[4..7] -> H12 bit[11..8]: ingress::hdr.ipv4.ihl
            # - bit[8..15] -> H12 bit[7..0]: ingress::hdr.ipv4.diffserv
        2..3: TH7  # ingress::hdr.ipv4.total_len
        4..5: TH9  # ingress::hdr.ipv4.identification
        6..7: H40
            # - bit[48..50] -> H40 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> H40 bit[12..0]: ingress::hdr.ipv4.frag_offset
        12..15: W2  # ingress::hdr.ipv4.src_addr
        16..19: W4  # ingress::hdr.ipv4.dst_addr
        save: { byte1 : 0, half : 6..7 }
        shift: 8
        buf_req: 20
        next: parse_ipv4.$split_0
    parse_ipv4.$split_0:  # from state ingress::parse_ipv4.$split_0
      match: [ byte1 ]
      0x*5:
        0..1: H14
            # - bit[0..7] -> H14 bit[15..8]: ingress::hdr.ipv4.ttl
            # - bit[8..15] -> H14 bit[7..0]: ingress::hdr.ipv4.protocol
        2..3: TH8  # ingress::hdr.ipv4.hdr_checksum
        H6: 4  # value 1 -> H6 bit[2]: ingress::hdr.ipv4.$valid
        save: { byte1 : 1 }
        shift: 12
        buf_req: 12
        next: parse_ipv4_no_options
      0x*6:
        0..1: H14
            # - bit[0..7] -> H14 bit[15..8]: ingress::hdr.ipv4.ttl
            # - bit[8..15] -> H14 bit[7..0]: ingress::hdr.ipv4.protocol
        2..3: TH8  # ingress::hdr.ipv4.hdr_checksum
        H6: 4  # value 1 -> H6 bit[2]: ingress::hdr.ipv4.$valid
        save: { byte1 : 1 }
        shift: 12
        buf_req: 12
        next: parse_ipv4_options
      0x**:
        0..1: H14
            # - bit[0..7] -> H14 bit[15..8]: ingress::hdr.ipv4.ttl
            # - bit[8..15] -> H14 bit[7..0]: ingress::hdr.ipv4.protocol
        2..3: TH8  # ingress::hdr.ipv4.hdr_checksum
        H6: 4  # value 1 -> H6 bit[2]: ingress::hdr.ipv4.$valid
        shift: 12
        buf_req: 12
        next: end
    parse_ipv4_no_options:  # from state ingress::parse_ipv4_no_options
      match: [ byte1, half ]
      0b00000001***0000000000000:
        checksum 0:
          type: VERIFY
          mask: [  ]
          swap: 0
          start: 0
          end: 1
          dest: H9(2)
        buf_req: 0
        next: parse_icmp
      0b00000010***0000000000000:
        checksum 0:
          type: VERIFY
          mask: [  ]
          swap: 0
          start: 0
          end: 1
          dest: H9(2)
        buf_req: 0
        next: parse_igmp
      0b00000110***0000000000000:
        checksum 0:
          type: VERIFY
          mask: [  ]
          swap: 0
          start: 0
          end: 1
          dest: H9(2)
        buf_req: 0
        next: parse_tcp
      0b00010001***0000000000000:
        checksum 0:
          type: VERIFY
          mask: [  ]
          swap: 0
          start: 0
          end: 1
          dest: H9(2)
        save: { half : 2..3 }
        buf_req: 4
        next: parse_udp
      0b00000100***0000000000000:
        checksum 0:
          type: VERIFY
          mask: [  ]
          swap: 0
          start: 0
          end: 1
          dest: H9(2)
        buf_req: 0
        next: parse_ipinip
      0b00101001***0000000000000:
        checksum 0:
          type: VERIFY
          mask: [  ]
          swap: 0
          start: 0
          end: 1
          dest: H9(2)
        buf_req: 0
        next: parse_ipv6inip
      0x******:
        checksum 0:
          type: VERIFY
          mask: [  ]
          swap: 0
          start: 0
          end: 1
          dest: H9(2)
        buf_req: 0
        next: end
    parse_icmp:  # from state ingress::parse_icmp
      *:
        0: B12  # ingress::hdr.icmp.type
        1: B14  # ingress::hdr.icmp.code
        2..3: TH6  # ingress::hdr.icmp.checksum
        H6: 8  # value 1 -> H6 bit[3]: ingress::hdr.icmp.$valid
        shift: 4
        buf_req: 4
        next: end
    parse_igmp:  # from state ingress::parse_igmp
      *:
        0..1: TH6
            # - bit[0..7] -> TH6 bit[15..8]: ingress::hdr.igmp.type
            # - bit[8..15] -> TH6 bit[7..0]: ingress::hdr.igmp.code
        2: TB6  # ingress::hdr.igmp.checksum[15:8].8-15
        3: TB5  # ingress::hdr.igmp.checksum[7:0].0-7
        H6: 16  # value 1 -> H6 bit[4]: ingress::hdr.igmp.$valid
        shift: 4
        buf_req: 4
        next: end
    parse_tcp:  # from state ingress::parse_tcp
      *:
        0: B14  # ingress::hdr.tcp.src_port[15:8].8-15
        1: B12  # ingress::hdr.tcp.src_port[7:0].0-7
        2..3: H10  # ingress::hdr.tcp.dst_port
        4..7: TW7  # ingress::hdr.tcp.seq_no
        8..9: TH10  # ingress::hdr.tcp.ack_no[31:16].16-31
        10: TB7  # ingress::hdr.tcp.ack_no[15:8].8-15
        11: TB6  # ingress::hdr.tcp.ack_no[7:0].0-7
        14..15: TH6  # ingress::hdr.tcp.window
        16..19: TW6
            # - bit[128..143] -> TW6 bit[31..16]: ingress::hdr.tcp.checksum
            # - bit[144..159] -> TW6 bit[15..0]: ingress::hdr.tcp.urgent_ptr
        H6: 32  # value 1 -> H6 bit[5]: ingress::hdr.tcp.$valid
        shift: 12
        buf_req: 20
        next: parse_tcp.$split_0
    parse_tcp.$split_0:  # from state ingress::parse_tcp.$split_0
      *:
        0: TB5
            # - bit[0..3] -> TB5 bit[7..4]: ingress::hdr.tcp.data_offset
            # - bit[4..7] -> TB5 bit[3..0]: ingress::hdr.tcp.res
        1: B40  # ingress::hdr.tcp.flags
        shift: 8
        buf_req: 8
        next: end
    parse_udp:  # from state ingress::parse_udp
      match: [ half ]
      value_set SwitchIngressParser.udp_port_vxlan 1:
        handle: 510
        field_mapping:
          hdr.udp.dst_port(0..15) : half(0..15)
        0: B14  # ingress::hdr.udp.src_port[15:8].8-15
        1: B12  # ingress::hdr.udp.src_port[7:0].0-7
        2..3: H10  # ingress::hdr.udp.dst_port
        4..7: TW6
            # - bit[32..47] -> TW6 bit[31..16]: ingress::hdr.udp.length
            # - bit[48..63] -> TW6 bit[15..0]: ingress::hdr.udp.checksum
        H6: 64  # value 1 -> H6 bit[6]: ingress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: parse_vxlan
      0x12b7:
        0: B14  # ingress::hdr.udp.src_port[15:8].8-15
        1: B12  # ingress::hdr.udp.src_port[7:0].0-7
        2..3: H10  # ingress::hdr.udp.dst_port
        4..7: TW6
            # - bit[32..47] -> TW6 bit[31..16]: ingress::hdr.udp.length
            # - bit[48..63] -> TW6 bit[15..0]: ingress::hdr.udp.checksum
        H6: 64  # value 1 -> H6 bit[6]: ingress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: parse_rocev2
      0x****:
        0: B14  # ingress::hdr.udp.src_port[15:8].8-15
        1: B12  # ingress::hdr.udp.src_port[7:0].0-7
        2..3: H10  # ingress::hdr.udp.dst_port
        4..7: TW6
            # - bit[32..47] -> TW6 bit[31..16]: ingress::hdr.udp.length
            # - bit[48..63] -> TW6 bit[15..0]: ingress::hdr.udp.checksum
        H6: 64  # value 1 -> H6 bit[6]: ingress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: end
    parse_vxlan:  # from state ingress::parse_vxlan
      *:
        buf_req: 0
        next: end
    parse_rocev2:  # from state ingress::parse_rocev2
      *:
        buf_req: 0
        next: end
    parse_ipinip:  # from state ingress::parse_ipinip
      *:
        buf_req: 0
        next: end
    parse_ipv6inip:  # from state ingress::parse_ipv6inip
      *:
        buf_req: 0
        next: end
    parse_ipv4_options:  # from state ingress::parse_ipv4_options
      *:
        checksum 0:
          type: VERIFY
          mask: [ 0, 1, 2..3 ]
          swap: 0
          start: 0
          end: 0
        0..3: TW5
            # - bit[0..7] -> TW5 bit[31..24]: ingress::hdr.ipv4_option.type
            # - bit[8..15] -> TW5 bit[23..16]: ingress::hdr.ipv4_option.length
            # - bit[16..31] -> TW5 bit[15..0]: ingress::hdr.ipv4_option.value
        H6: 128  # value 1 -> H6 bit[7]: ingress::hdr.ipv4_option.$valid
        shift: 4
        buf_req: 4
        next: parse_ipv4_no_options
    parse_arp:  # from state ingress::parse_arp
      *:
        0..3: TW5
            # - bit[0..15] -> TW5 bit[31..16]: ingress::hdr.arp.hw_type
            # - bit[16..31] -> TW5 bit[15..0]: ingress::hdr.arp.proto_type
        4..5: TH6
            # - bit[32..39] -> TH6 bit[15..8]: ingress::hdr.arp.hw_addr_len
            # - bit[40..47] -> TH6 bit[7..0]: ingress::hdr.arp.proto_addr_len
        6..7: H40  # ingress::hdr.arp.opcode
        H6: 256  # value 1 -> H6 bit[8]: ingress::hdr.arp.$valid
        shift: 8
        buf_req: 8
        next: end
    parse_ipv6:  # from state ingress::parse_ipv6
      *:
        0..1: H12
            # - bit[0..3] -> H12 bit[15..12]: ingress::hdr.ipv6.version
            # - bit[4..11] -> H12 bit[11..4]: ingress::hdr.ipv6.traffic_class
            # - bit[12..15] -> H12 bit[3..0]: ingress::hdr.ipv6.flow_label[19:16].16-19
        2..3: TH7  # ingress::hdr.ipv6.flow_label[15:0].0-15
        4..5: TH8  # ingress::hdr.ipv6.payload_len
        6..7: H14
            # - bit[48..55] -> H14 bit[15..8]: ingress::hdr.ipv6.next_hdr
            # - bit[56..63] -> H14 bit[7..0]: ingress::hdr.ipv6.hop_limit
        8..11: W11  # ingress::hdr.ipv6.src_addr[127:96].96-127
        12..15: W32  # ingress::hdr.ipv6.src_addr[95:64].64-95
        16..19: W13  # ingress::hdr.ipv6.src_addr[63:32].32-63
        20..23: W2  # ingress::hdr.ipv6.src_addr[31:0].0-31
        save: { byte1 : 6 }
        shift: 24
        buf_req: 24
        next: parse_ipv6.$split_0
    parse_ipv6.$split_0:  # from state ingress::parse_ipv6.$split_0
      match: [ byte1 ]
      0x3a:
        0..3: W35  # ingress::hdr.ipv6.dst_addr[127:96].96-127
        4..7: W34  # ingress::hdr.ipv6.dst_addr[95:64].64-95
        8..11: W33  # ingress::hdr.ipv6.dst_addr[63:32].32-63
        12..15: W4  # ingress::hdr.ipv6.dst_addr[31:0].0-31
        H6: 512  # value 1 -> H6 bit[9]: ingress::hdr.ipv6.$valid
        shift: 16
        buf_req: 16
        next: parse_icmp
      0x06:
        0..3: W35  # ingress::hdr.ipv6.dst_addr[127:96].96-127
        4..7: W34  # ingress::hdr.ipv6.dst_addr[95:64].64-95
        8..11: W33  # ingress::hdr.ipv6.dst_addr[63:32].32-63
        12..15: W4  # ingress::hdr.ipv6.dst_addr[31:0].0-31
        H6: 512  # value 1 -> H6 bit[9]: ingress::hdr.ipv6.$valid
        shift: 16
        buf_req: 16
        next: parse_tcp
      0x11:
        0..3: W35  # ingress::hdr.ipv6.dst_addr[127:96].96-127
        4..7: W34  # ingress::hdr.ipv6.dst_addr[95:64].64-95
        8..11: W33  # ingress::hdr.ipv6.dst_addr[63:32].32-63
        12..15: W4  # ingress::hdr.ipv6.dst_addr[31:0].0-31
        H6: 512  # value 1 -> H6 bit[9]: ingress::hdr.ipv6.$valid
        save: { half : 18..19 }
        shift: 16
        buf_req: 20
        next: parse_udp
      0x04:
        0..3: W35  # ingress::hdr.ipv6.dst_addr[127:96].96-127
        4..7: W34  # ingress::hdr.ipv6.dst_addr[95:64].64-95
        8..11: W33  # ingress::hdr.ipv6.dst_addr[63:32].32-63
        12..15: W4  # ingress::hdr.ipv6.dst_addr[31:0].0-31
        H6: 512  # value 1 -> H6 bit[9]: ingress::hdr.ipv6.$valid
        shift: 16
        buf_req: 16
        next: parse_ipinip
      0x29:
        0..3: W35  # ingress::hdr.ipv6.dst_addr[127:96].96-127
        4..7: W34  # ingress::hdr.ipv6.dst_addr[95:64].64-95
        8..11: W33  # ingress::hdr.ipv6.dst_addr[63:32].32-63
        12..15: W4  # ingress::hdr.ipv6.dst_addr[31:0].0-31
        H6: 512  # value 1 -> H6 bit[9]: ingress::hdr.ipv6.$valid
        shift: 16
        buf_req: 16
        next: parse_ipv6inip
      0x**:
        0..3: W35  # ingress::hdr.ipv6.dst_addr[127:96].96-127
        4..7: W34  # ingress::hdr.ipv6.dst_addr[95:64].64-95
        8..11: W33  # ingress::hdr.ipv6.dst_addr[63:32].32-63
        12..15: W4  # ingress::hdr.ipv6.dst_addr[31:0].0-31
        H6: 512  # value 1 -> H6 bit[9]: ingress::hdr.ipv6.$valid
        shift: 16
        buf_req: 16
        next: end
    parse_vlan:  # from state ingress::parse_vlan
      match: [ half ]
      0x0806:
        0..1: H56
            # - bit[0..2] -> H56 bit[15..13]: ingress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H56 bit[12]: ingress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H56 bit[11..0]: ingress::hdr.vlan_tag[0].vid
        2..3: H41  # ingress::hdr.vlan_tag[0].ether_type
        B9: 2  # value 2 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_arp
      0x0800:
        0..1: H56
            # - bit[0..2] -> H56 bit[15..13]: ingress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H56 bit[12]: ingress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H56 bit[11..0]: ingress::hdr.vlan_tag[0].vid
        2..3: H41  # ingress::hdr.vlan_tag[0].ether_type
        B9: 2  # value 2 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv4
      0x8100:
        0..1: H56
            # - bit[0..2] -> H56 bit[15..13]: ingress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H56 bit[12]: ingress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H56 bit[11..0]: ingress::hdr.vlan_tag[0].vid
        2..3: H41  # ingress::hdr.vlan_tag[0].ether_type
        B9: 2  # value 2 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        save: { half : 6..7 }
        shift: 4
        buf_req: 8
        next: parse_vlan.0
      0x86dd:
        0..1: H56
            # - bit[0..2] -> H56 bit[15..13]: ingress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H56 bit[12]: ingress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H56 bit[11..0]: ingress::hdr.vlan_tag[0].vid
        2..3: H41  # ingress::hdr.vlan_tag[0].ether_type
        B9: 2  # value 2 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv6
      0x****:
        0..1: H56
            # - bit[0..2] -> H56 bit[15..13]: ingress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H56 bit[12]: ingress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H56 bit[11..0]: ingress::hdr.vlan_tag[0].vid
        2..3: H41  # ingress::hdr.vlan_tag[0].ether_type
        B9: 2  # value 2 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: end
    parse_vlan.0:  # from state ingress::parse_vlan.0
      match: [ half ]
      0x0806:
        0..3: TW4
            # - bit[0..2] -> TW4 bit[31..29]: ingress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW4 bit[28]: ingress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW4 bit[27..16]: ingress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW4 bit[15..0]: ingress::hdr.vlan_tag[1].ether_type
        B9: 1  # value 1 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_arp
      0x0800:
        0..3: TW4
            # - bit[0..2] -> TW4 bit[31..29]: ingress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW4 bit[28]: ingress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW4 bit[27..16]: ingress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW4 bit[15..0]: ingress::hdr.vlan_tag[1].ether_type
        B9: 1  # value 1 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv4
      0x8100:
        0..3: TW4
            # - bit[0..2] -> TW4 bit[31..29]: ingress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW4 bit[28]: ingress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW4 bit[27..16]: ingress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW4 bit[15..0]: ingress::hdr.vlan_tag[1].ether_type
        B9: 1  # value 1 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: end
      0x86dd:
        0..3: TW4
            # - bit[0..2] -> TW4 bit[31..29]: ingress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW4 bit[28]: ingress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW4 bit[27..16]: ingress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW4 bit[15..0]: ingress::hdr.vlan_tag[1].ether_type
        B9: 1  # value 1 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv6
      0x****:
        0..3: TW4
            # - bit[0..2] -> TW4 bit[31..29]: ingress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW4 bit[28]: ingress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW4 bit[27..16]: ingress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW4 bit[15..0]: ingress::hdr.vlan_tag[1].ether_type
        B9: 1  # value 1 -> B9 bit[1..0]: ingress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: end
    parse_fcoe:  # from state ingress::parse_fcoe
      *:
        buf_req: 0
        next: end
    parse_cpu:  # from state ingress::parse_cpu
      *:
        3..4: H73  # ingress::hdr.fabric.dst_port_or_group
        4..5: H1  # bit[45] -> H1 bit[2]: ingress::hdr.cpu.tx_bypass
        6..7: H43  # ingress::hdr.cpu.ingress_port
        8..11: W8  # bit[80..95] -> W8 bit[15..0]: ingress::hdr.cpu.ingress_bd
        12..13: H76  # ingress::ig_md.bypass
        save: { half : 14..15 }
        shift: 14
        buf_req: 16
        next: parse_cpu.$split_0
    parse_cpu.$split_0:  # from state ingress::parse_cpu.$split_0
      match: [ half ]
      0x0800:
        0..1: H38  # ingress::hdr.cpu.ether_type
        H6: 1024  # value 1 -> H6 bit[10]: ingress::hdr.cpu.$valid
        shift: 2
        buf_req: 2
        next: parse_ipv4
      0x86dd:
        0..1: H38  # ingress::hdr.cpu.ether_type
        H6: 1024  # value 1 -> H6 bit[10]: ingress::hdr.cpu.$valid
        shift: 2
        buf_req: 2
        next: parse_ipv6
      0x8100:
        0..1: H38  # ingress::hdr.cpu.ether_type
        H6: 1024  # value 1 -> H6 bit[10]: ingress::hdr.cpu.$valid
        save: { half : 4..5 }
        shift: 2
        buf_req: 6
        next: parse_vlan
      0x8100:
        0..1: H38  # ingress::hdr.cpu.ether_type
        H6: 1024  # value 1 -> H6 bit[10]: ingress::hdr.cpu.$valid
        save: { half : 4..5 }
        shift: 2
        buf_req: 6
        next: parse_vlan
      0x****:
        0..1: H38  # ingress::hdr.cpu.ether_type
        H6: 1024  # value 1 -> H6 bit[10]: ingress::hdr.cpu.$valid
        shift: 2
        buf_req: 2
        next: end
deparser ingress:
  dictionary:
    B0: H6(0)  # ingress::hdr.bridged_md.src if ingress::hdr.bridged_md.$valid
    TB4: H6(0)  # ingress::hdr.bridged_md.type if ingress::hdr.bridged_md.$valid
    H61: H6(0)  # ingress::hdr.bridged_md.base_ingress_ifindex if ingress::hdr.bridged_md.$valid
    H47: H6(0)  # ingress::hdr.bridged_md.base_ingress_bd if ingress::hdr.bridged_md.$valid
    W8: H6(0)
        # - bit[31..16]: ingress::hdr.bridged_md.base_nexthop if ingress::hdr.bridged_md.$valid
        # - bit[15..0]: ingress::hdr.bridged_md.base_cpu_reason if ingress::hdr.bridged_md.$valid
    W15: H6(0)  # ingress::hdr.bridged_md.base_timestamp.16-47 if ingress::hdr.bridged_md.$valid
    H60: H6(0)  # ingress::hdr.bridged_md.base_timestamp.0-15 if ingress::hdr.bridged_md.$valid
    B11: H6(0)  # ingress::hdr.bridged_md.base_tc if ingress::hdr.bridged_md.$valid
    W1: H6(0)  # ingress::hdr.bridged_md.dtel_hash if ingress::hdr.bridged_md.$valid
    B7: H6(0)
        # - bit[7..4]: ingress::hdr.bridged_md.__pad_0 if ingress::hdr.bridged_md.$valid
        # - bit[3]: ingress::hdr.bridged_md.base_peer_link if ingress::hdr.bridged_md.$valid
        # - bit[2..1]: ingress::hdr.bridged_md.base_pkt_type if ingress::hdr.bridged_md.$valid
        # - bit[0]: ingress::hdr.bridged_md.base_routed if ingress::hdr.bridged_md.$valid
    B6: H6(0)
        # - bit[7..2]: ingress::hdr.bridged_md.__pad_1 if ingress::hdr.bridged_md.$valid
        # - bit[1..0]: ingress::hdr.bridged_md.base_color if ingress::hdr.bridged_md.$valid
    B5: H6(0)
        # - bit[7..4]: ingress::hdr.bridged_md.__pad_2 if ingress::hdr.bridged_md.$valid
        # - bit[3..0]: ingress::hdr.bridged_md.dtel_report_type if ingress::hdr.bridged_md.$valid
    B3: H6(0)
        # - bit[7..5]: ingress::hdr.bridged_md.__pad_3 if ingress::hdr.bridged_md.$valid
        # - bit[4..0]: ingress::hdr.bridged_md.base_qid if ingress::hdr.bridged_md.$valid
    H44: H6(0)
        # - bit[15..9]: ingress::hdr.bridged_md.__pad_4 if ingress::hdr.bridged_md.$valid
        # - bit[8..0]: ingress::hdr.bridged_md.base_ingress_port if ingress::hdr.bridged_md.$valid
    H1: H6(0)
        # - bit[15..9]: ingress::hdr.bridged_md.__pad_5 if ingress::hdr.bridged_md.$valid
        # - bit[8..0]: ingress::hdr.bridged_md.dtel_egress_port if ingress::hdr.bridged_md.$valid
    H4: H6(0)
        # - bit[15..10]: ingress::hdr.bridged_md.__pad_6 if ingress::hdr.bridged_md.$valid
        # - bit[9..0]: ingress::hdr.bridged_md.dtel_session_id if ingress::hdr.bridged_md.$valid
    W9: H6(1)  # ingress::hdr.ethernet.dst_addr.16-47 if ingress::hdr.ethernet.$valid
    H58: H6(1)  # ingress::hdr.ethernet.dst_addr.0-15 if ingress::hdr.ethernet.$valid
    W6: H6(1)  # ingress::hdr.ethernet.src_addr.16-47 if ingress::hdr.ethernet.$valid
    H45: H6(1)  # ingress::hdr.ethernet.src_addr.0-15 if ingress::hdr.ethernet.$valid
    H42: H6(1)  # ingress::hdr.ethernet.ether_type if ingress::hdr.ethernet.$valid
    H56: B9(1)
        # - bit[15..13]: ingress::hdr.vlan_tag[0].pcp if ingress::hdr.vlan_tag[0].$valid
        # - bit[12]: ingress::hdr.vlan_tag[0].cfi if ingress::hdr.vlan_tag[0].$valid
        # - bit[11..0]: ingress::hdr.vlan_tag[0].vid if ingress::hdr.vlan_tag[0].$valid
    H41: B9(1)  # ingress::hdr.vlan_tag[0].ether_type if ingress::hdr.vlan_tag[0].$valid
    TW4: B9(0)
        # - bit[31..29]: ingress::hdr.vlan_tag[1].pcp if ingress::hdr.vlan_tag[1].$valid
        # - bit[28]: ingress::hdr.vlan_tag[1].cfi if ingress::hdr.vlan_tag[1].$valid
        # - bit[27..16]: ingress::hdr.vlan_tag[1].vid if ingress::hdr.vlan_tag[1].$valid
        # - bit[15..0]: ingress::hdr.vlan_tag[1].ether_type if ingress::hdr.vlan_tag[1].$valid
    TW5: H6(8)
        # - bit[31..16]: ingress::hdr.arp.hw_type if ingress::hdr.arp.$valid
        # - bit[15..0]: ingress::hdr.arp.proto_type if ingress::hdr.arp.$valid
    TH6: H6(8)
        # - bit[15..8]: ingress::hdr.arp.hw_addr_len if ingress::hdr.arp.$valid
        # - bit[7..0]: ingress::hdr.arp.proto_addr_len if ingress::hdr.arp.$valid
    H40: H6(8)  # ingress::hdr.arp.opcode if ingress::hdr.arp.$valid
    H12: H6(2)
        # - bit[15..12]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[11..8]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - bit[7..0]: ingress::hdr.ipv4.diffserv if ingress::hdr.ipv4.$valid
    TH7: H6(2)  # ingress::hdr.ipv4.total_len if ingress::hdr.ipv4.$valid
    TH9: H6(2)  # ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
    H40: H6(2)
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.frag_offset if ingress::hdr.ipv4.$valid
    H14: H6(2)
        # - bit[15..8]: ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
        # - bit[7..0]: ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
    TH8: H6(2)  # ingress::hdr.ipv4.hdr_checksum if ingress::hdr.ipv4.$valid
    W2: H6(2)  # ingress::hdr.ipv4.src_addr if ingress::hdr.ipv4.$valid
    W4: H6(2)  # ingress::hdr.ipv4.dst_addr if ingress::hdr.ipv4.$valid
    TW5: H6(7)
        # - bit[31..24]: ingress::hdr.ipv4_option.type if ingress::hdr.ipv4_option.$valid
        # - bit[23..16]: ingress::hdr.ipv4_option.length if ingress::hdr.ipv4_option.$valid
        # - bit[15..0]: ingress::hdr.ipv4_option.value if ingress::hdr.ipv4_option.$valid
    H12: H6(9)
        # - bit[15..12]: ingress::hdr.ipv6.version if ingress::hdr.ipv6.$valid
        # - bit[11..4]: ingress::hdr.ipv6.traffic_class if ingress::hdr.ipv6.$valid
        # - bit[3..0]: ingress::hdr.ipv6.flow_label.16-19 if ingress::hdr.ipv6.$valid
    TH7: H6(9)  # ingress::hdr.ipv6.flow_label.0-15 if ingress::hdr.ipv6.$valid
    TH8: H6(9)  # ingress::hdr.ipv6.payload_len if ingress::hdr.ipv6.$valid
    H14: H6(9)
        # - bit[15..8]: ingress::hdr.ipv6.next_hdr if ingress::hdr.ipv6.$valid
        # - bit[7..0]: ingress::hdr.ipv6.hop_limit if ingress::hdr.ipv6.$valid
    W11: H6(9)  # ingress::hdr.ipv6.src_addr.96-127 if ingress::hdr.ipv6.$valid
    W32: H6(9)  # ingress::hdr.ipv6.src_addr.64-95 if ingress::hdr.ipv6.$valid
    W13: H6(9)  # ingress::hdr.ipv6.src_addr.32-63 if ingress::hdr.ipv6.$valid
    W2: H6(9)  # ingress::hdr.ipv6.src_addr.0-31 if ingress::hdr.ipv6.$valid
    W35: H6(9)  # ingress::hdr.ipv6.dst_addr.96-127 if ingress::hdr.ipv6.$valid
    W34: H6(9)  # ingress::hdr.ipv6.dst_addr.64-95 if ingress::hdr.ipv6.$valid
    W33: H6(9)  # ingress::hdr.ipv6.dst_addr.32-63 if ingress::hdr.ipv6.$valid
    W4: H6(9)  # ingress::hdr.ipv6.dst_addr.0-31 if ingress::hdr.ipv6.$valid
    B14: H6(6)  # ingress::hdr.udp.src_port.8-15 if ingress::hdr.udp.$valid
    B12: H6(6)  # ingress::hdr.udp.src_port.0-7 if ingress::hdr.udp.$valid
    H10: H6(6)  # ingress::hdr.udp.dst_port if ingress::hdr.udp.$valid
    TW6: H6(6)
        # - bit[31..16]: ingress::hdr.udp.length if ingress::hdr.udp.$valid
        # - bit[15..0]: ingress::hdr.udp.checksum if ingress::hdr.udp.$valid
    B14: H6(5)  # ingress::hdr.tcp.src_port.8-15 if ingress::hdr.tcp.$valid
    B12: H6(5)  # ingress::hdr.tcp.src_port.0-7 if ingress::hdr.tcp.$valid
    H10: H6(5)  # ingress::hdr.tcp.dst_port if ingress::hdr.tcp.$valid
    TW7: H6(5)  # ingress::hdr.tcp.seq_no if ingress::hdr.tcp.$valid
    TH10: H6(5)  # ingress::hdr.tcp.ack_no.16-31 if ingress::hdr.tcp.$valid
    TB7: H6(5)  # ingress::hdr.tcp.ack_no.8-15 if ingress::hdr.tcp.$valid
    TB6: H6(5)  # ingress::hdr.tcp.ack_no.0-7 if ingress::hdr.tcp.$valid
    TB5: H6(5)
        # - bit[7..4]: ingress::hdr.tcp.data_offset if ingress::hdr.tcp.$valid
        # - bit[3..0]: ingress::hdr.tcp.res if ingress::hdr.tcp.$valid
    B40: H6(5)  # ingress::hdr.tcp.flags if ingress::hdr.tcp.$valid
    TH6: H6(5)  # ingress::hdr.tcp.window if ingress::hdr.tcp.$valid
    TW6: H6(5)
        # - bit[31..16]: ingress::hdr.tcp.checksum if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.urgent_ptr if ingress::hdr.tcp.$valid
    B12: H6(3)  # ingress::hdr.icmp.type if ingress::hdr.icmp.$valid
    B14: H6(3)  # ingress::hdr.icmp.code if ingress::hdr.icmp.$valid
    TH6: H6(3)  # ingress::hdr.icmp.checksum if ingress::hdr.icmp.$valid
    TH6: H6(4)
        # - bit[15..8]: ingress::hdr.igmp.type if ingress::hdr.igmp.$valid
        # - bit[7..0]: ingress::hdr.igmp.code if ingress::hdr.igmp.$valid
    TB6: H6(4)  # ingress::hdr.igmp.checksum.8-15 if ingress::hdr.igmp.$valid
    TB5: H6(4)  # ingress::hdr.igmp.checksum.0-7 if ingress::hdr.igmp.$valid
  egress_unicast_port: H0(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  bypss_egr: H9(0..0)  # bit[0]: ingress::ig_intr_md_for_tm.bypass_egress
  deflect_on_drop: H9(1..1)  # bit[1]: ingress::ig_intr_md_for_tm.deflect_on_drop
  icos: B9(2..4)  # bit[4..2]: ingress::ig_intr_md_for_tm.ingress_cos
  qid: B4(0..4)  # bit[4..0]: ingress::ig_intr_md_for_tm.qid
  copy_to_cpu: B9(7..7)  # bit[7]: ingress::ig_intr_md_for_tm.copy_to_cpu
  meter_color: B10(0..1)  # bit[1..0]: ingress::ig_intr_md_for_tm.packet_color
  yid: H7(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.level2_exclusion_id
  rid: H8  # ingress::ig_intr_md_for_tm.rid
  drop_ctl: H9(2..4)  # bit[4..2]: ingress::ig_intr_md_for_dprsr.drop_ctl
  egress_multicast_group_1:
    - H2  # ingress::ig_intr_md_for_tm.mcast_grp_b
  hash_lag_ecmp_mcast_1:
    - W0(0..12)  # bit[12..0]: ingress::ig_intr_md_for_tm.level2_mcast_hash
  learning:
    select: B2(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.digest_type
    1:
      - B2(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.digest_type
      - H47  # ingress::ig_md.bd
      - H61  # ingress::ig_md.ifindex
      - W7  # ingress::ig_md.lkp.mac_src_addr.16-47
      - H46  # ingress::ig_md.lkp.mac_src_addr.0-15
    context_json:
      1:
        - [ ig_md.bd, 1, 16, 7, 0]
        - [ ig_md.ifindex, 3, 16, 7, 0]
        - [ ig_md.lkp.mac_src_addr, 5, 32, 7, 16]
        - [ ig_md.lkp.mac_src_addr, 9, 16, 7, 0]
      name: [ SwitchIngressDeparser.digest ]
  mirror:
    select: B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    1:
      - H5(0..9)  # bit[9..0]: ingress::ig_md.mirror.session_id
      - B8  # ingress::ig_md.mirror.src
      - B1  # ingress::ig_md.mirror.type
      - W15  # ingress::ig_md.timestamp.16-47
      - H60  # ingress::ig_md.timestamp.0-15
      - H5(0..9)  # bit[9..0]: ingress::ig_md.mirror.session_id
    3:
      - H4(0..9)  # bit[9..0]: ingress::ig_md.dtel.session_id
      - B8  # ingress::ig_md.mirror.src
      - B1  # ingress::ig_md.mirror.type
      - W15  # ingress::ig_md.timestamp.16-47
      - H60  # ingress::ig_md.timestamp.0-15
      - H4(0..9)  # bit[9..0]: ingress::ig_md.dtel.session_id
      - W1  # ingress::ig_md.hash
      - B5(0..3)  # bit[3..0]: ingress::ig_md.dtel.report_type
      - H44(0..8)  # bit[8..0]: ingress::ig_md.port
      - H0(0..8)  # bit[8..0]: ingress::ig_md.egress_port
      - B4(0..4)  # bit[4..0]: ingress::ig_md.qos.qid
      - B41  # ingress::ig_md.drop_reason
parser egress:
  start: $entry_point
  init_zero: [ TH12, B43, H17, B44, H57, B26, H30, H68, H64, W30, W18, W16, H71, B49, H72, H19, B22, W31, W25, B45, B32, B35, B20, B17, H20, B33, W20, H23, H24, H26, H69, B46, H81, B42, B21, B48, B16 ]
  bitwise_or: [ B21, B49 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point:  # from state egress::$entry_point
      *:
        54..55: TH12  # buffer mapped I/O: bit[432..447] -> TH12 bit[15..0]: egress::eg_intr_md_from_prsr.global_tstamp[47:32].32-47
        56..59: W17  # buffer mapped I/O: bit[448..479] -> W17 bit[31..0]: egress::eg_intr_md_from_prsr.global_tstamp[31:0].0-31
        save: { byte1 : 24, half : 27..28 }
        buf_req: 29
        next: start
    start:  # from state egress::start
      match: [ byte1, half ]
      0b*******1****************:
        0: B24  # bit[7] -> B24 bit[0]: egress::eg_md.port[8:8].8-8
        0..1: H32  # bit[7..15] -> H32 bit[8..0]: egress::eg_intr_md.egress_port
        1: B26  # egress::eg_md.port[7:0].0-7
        1..4: W29  # bit[21..39] -> W29 bit[18..0]: egress::eg_intr_md.enq_qdepth
        2..3: H67  # bit[21..31] -> H67 bit[10..0]: egress::eg_md.qos.qdepth[18:8].8-18
        4: B35  # egress::eg_md.qos.qdepth[7:0].0-7
        19..20: H63  # egress::eg_intr_md.egress_rid
        25..26: H17  # egress::eg_md.pkt_length
        shift: 27
        buf_req: 27
        next: parse_deflected_pkt
      0x**00**:
        0: B24  # bit[7] -> B24 bit[0]: egress::eg_md.port[8:8].8-8
        0..1: H32  # bit[7..15] -> H32 bit[8..0]: egress::eg_intr_md.egress_port
        1: B26  # egress::eg_md.port[7:0].0-7
        1..4: W29  # bit[21..39] -> W29 bit[18..0]: egress::eg_intr_md.enq_qdepth
        2..3: H67  # bit[21..31] -> H67 bit[10..0]: egress::eg_md.qos.qdepth[18:8].8-18
        4: B35  # egress::eg_md.qos.qdepth[7:0].0-7
        19..20: H63  # egress::eg_intr_md.egress_rid
        25..26: H17  # egress::eg_md.pkt_length
        save: { byte0 : 0, byte1 : 1 }
        shift: 27
        buf_req: 27
        next: parse_bridged_pkt
      0x****01:
        0: B24  # bit[7] -> B24 bit[0]: egress::eg_md.port[8:8].8-8
        0..1: H32  # bit[7..15] -> H32 bit[8..0]: egress::eg_intr_md.egress_port
        1: B26  # egress::eg_md.port[7:0].0-7
        1..4: W29  # bit[21..39] -> W29 bit[18..0]: egress::eg_intr_md.enq_qdepth
        2..3: H67  # bit[21..31] -> H67 bit[10..0]: egress::eg_md.qos.qdepth[18:8].8-18
        4: B35  # egress::eg_md.qos.qdepth[7:0].0-7
        19..20: H63  # egress::eg_intr_md.egress_rid
        25..26: H17  # egress::eg_md.pkt_length
        shift: 27
        buf_req: 27
        next: parse_port_mirrored_metadata
      0x**0202:
        0: B24  # bit[7] -> B24 bit[0]: egress::eg_md.port[8:8].8-8
        0..1: H32  # bit[7..15] -> H32 bit[8..0]: egress::eg_intr_md.egress_port
        1: B26  # egress::eg_md.port[7:0].0-7
        1..4: W29  # bit[21..39] -> W29 bit[18..0]: egress::eg_intr_md.enq_qdepth
        2..3: H67  # bit[21..31] -> H67 bit[10..0]: egress::eg_md.qos.qdepth[18:8].8-18
        4: B35  # egress::eg_md.qos.qdepth[7:0].0-7
        19..20: H63  # egress::eg_intr_md.egress_rid
        25..26: H17  # egress::eg_md.pkt_length
        shift: 27
        buf_req: 27
        next: parse_cpu_mirrored_metadata
      0x****03:
        0: B24  # bit[7] -> B24 bit[0]: egress::eg_md.port[8:8].8-8
        0..1: H32  # bit[7..15] -> H32 bit[8..0]: egress::eg_intr_md.egress_port
        1: B26  # egress::eg_md.port[7:0].0-7
        1..4: W29  # bit[21..39] -> W29 bit[18..0]: egress::eg_intr_md.enq_qdepth
        2..3: H67  # bit[21..31] -> H67 bit[10..0]: egress::eg_md.qos.qdepth[18:8].8-18
        4: B35  # egress::eg_md.qos.qdepth[7:0].0-7
        19..20: H63  # egress::eg_intr_md.egress_rid
        25..26: H17  # egress::eg_md.pkt_length
        shift: 27
        buf_req: 27
        next: parse_dtel_drop_metadata
      0x****04:
        0: B24  # bit[7] -> B24 bit[0]: egress::eg_md.port[8:8].8-8
        0..1: H32  # bit[7..15] -> H32 bit[8..0]: egress::eg_intr_md.egress_port
        1: B26  # egress::eg_md.port[7:0].0-7
        1..4: W29  # bit[21..39] -> W29 bit[18..0]: egress::eg_intr_md.enq_qdepth
        2..3: H67  # bit[21..31] -> H67 bit[10..0]: egress::eg_md.qos.qdepth[18:8].8-18
        4: B35  # egress::eg_md.qos.qdepth[7:0].0-7
        19..20: H63  # egress::eg_intr_md.egress_rid
        25..26: H17  # egress::eg_md.pkt_length
        shift: 27
        buf_req: 27
        next: parse_dtel_switch_local_metadata
    parse_deflected_pkt:  # from state egress::parse_deflected_pkt
      *:
        10..11: H71  # egress::eg_md.ingress_timestamp[47:32].32-47
        12..15: W16  # egress::eg_md.ingress_timestamp[31:0].0-31
        17..18: H26  # egress::eg_md.dtel.hash[31:16].16-31
        19..20: H24  # egress::eg_md.dtel.hash[15:0].0-15
        23: B33  # bit[188..191] -> B33 bit[3..0]: egress::eg_md.dtel.report_type
        24: TB2  # bit[195..199] -> TB2 bit[4..0]: egress::hdr.dtel_drop_report.queue_id
        24: B32  # bit[195..199] -> B32 bit[4..0]: egress::eg_md.qos.qid
        25..26: H55  # bit[207..215] -> H55 bit[8..0]: egress::hdr.dtel_drop_report.ingress_port
        27: B23  # bit[223] -> B23 bit[0]: egress::hdr.dtel_drop_report.egress_port[8:8].8-8
        W31: 1  # value 1 -> W31 bit[0]: egress::hdr.dtel_drop_report.$valid
        shift: 28
        buf_req: 28
        next: parse_deflected_pkt.$split_0
    parse_deflected_pkt.$split_0:  # from state egress::parse_deflected_pkt.$split_0
      *:
        0: B25  # egress::hdr.dtel_drop_report.egress_port[7:0].0-7
        1..2: H20  # bit[14..23] -> H20 bit[9..0]: egress::eg_md.mirror.session_id
        TB0: 71  # value 71 -> TB0 bit[7..0]: egress::hdr.dtel_drop_report.drop_reason
        B43: 3  # value 3 -> B43 bit[7..0]: egress::eg_md.pkt_src
        shift: 3
        buf_req: 3
        next: end
    parse_bridged_pkt:  # from state egress::parse_bridged_pkt
      *:
        2..3: H68  # egress::eg_md.ingress_ifindex
        4..5: H64  # egress::eg_md.bd
        4..7: W30  # bit[48..63] -> W30 bit[15..0]: egress::eg_md.nexthop
        8..9: H69  # egress::eg_md.cpu_reason
        10..11: H71  # egress::eg_md.ingress_timestamp[47:32].32-47
        12..15: W16  # egress::eg_md.ingress_timestamp[31:0].0-31
        14..17: W25  # bit[128..135] -> W25 bit[15..8]: egress::eg_md.qos.tc
        21: B44
            # - bit[173..174] -> B44 bit[2..1]: egress::eg_md.pkt_type
            # - bit[175] -> B44 bit[0]: egress::eg_md.flags.routed
        22: B45  # bit[182..183] -> B45 bit[1..0]: egress::eg_md.qos.color
        23: B33  # bit[188..191] -> B33 bit[3..0]: egress::eg_md.dtel.report_type
        24: B32  # bit[195..199] -> B32 bit[4..0]: egress::eg_md.qos.qid
        shift: 17
        buf_req: 25
        next: parse_bridged_pkt.$split_0
    parse_bridged_pkt.$split_0:  # from state egress::parse_bridged_pkt.$split_0
      *:
        0..1: H26  # egress::eg_md.dtel.hash[31:16].16-31
        2..3: H24  # egress::eg_md.dtel.hash[15:0].0-15
        8..9: H30  # bit[71..79] -> H30 bit[8..0]: egress::eg_md.ingress_port
        12..13: H23  # bit[102..111] -> H23 bit[9..0]: egress::eg_md.dtel.session_id
        14..17: W24  # egress::hdr.ethernet.dst_addr[47:16].16-47
        20..23: W22  # egress::hdr.ethernet.src_addr[47:16].16-47
        B49: 1  # value 1 -> B49 bit[0]: egress::hdr.ethernet.$valid
        save: { half : 26..27 }
        shift: 18
        buf_req: 28
        next: parse_bridged_pkt.$split_1
    parse_bridged_pkt.$split_1:  # from state egress::parse_bridged_pkt.$split_1
      match: [ half, byte0, byte1 ]
      value_set SwitchEgressParser.cpu_port 1:
        handle: 509
        field_mapping:
          hdr.ethernet.ether_type(0..15) : half(0..15)
          eg_intr_md.egress_port(0..7) : byte1(0..7)
          eg_intr_md.egress_port(8..8) : byte0(0..0)
        0..1: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H37  # egress::hdr.ethernet.ether_type
        shift: 10
        buf_req: 10
        next: parse_cpu
      0x0800****:
        0..1: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H37  # egress::hdr.ethernet.ether_type
        shift: 10
        buf_req: 10
        next: parse_ipv4
      0x86dd****:
        0..1: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H37  # egress::hdr.ethernet.ether_type
        shift: 10
        buf_req: 10
        next: parse_ipv6
      0x8100****:
        0..1: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H37  # egress::hdr.ethernet.ether_type
        save: { half : 12..13 }
        shift: 10
        buf_req: 14
        next: parse_vlan
      0x8100****:
        0..1: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H37  # egress::hdr.ethernet.ether_type
        save: { half : 12..13 }
        shift: 10
        buf_req: 14
        next: parse_vlan
      0x********:
        0..1: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        6..7: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        8..9: H37  # egress::hdr.ethernet.ether_type
        shift: 10
        buf_req: 10
        next: end
    parse_cpu:  # from state egress::parse_cpu
      *:
        B22: 255  # value 255 -> B22 bit[7..0]: egress::eg_md.bypass
        buf_req: 0
        next: end
    parse_ipv4:  # from state egress::parse_ipv4
      *:
        0: B38
            # - bit[0..3] -> B38 bit[7..4]: egress::hdr.ipv4.version
            # - bit[4..7] -> B38 bit[3..0]: egress::hdr.ipv4.ihl
        1: B37  # egress::hdr.ipv4.diffserv
        2..3: H16  # egress::hdr.ipv4.total_len
        4..7: W26
            # - bit[32..47] -> W26 bit[31..16]: egress::hdr.ipv4.identification
            # - bit[48..50] -> W26 bit[15..13]: egress::hdr.ipv4.flags
            # - bit[51..63] -> W26 bit[12..0]: egress::hdr.ipv4.frag_offset
        8: B19  # egress::hdr.ipv4.ttl
        9: B34  # egress::hdr.ipv4.protocol
        10..11: TH0  # egress::hdr.ipv4.hdr_checksum
        12..15: W27  # egress::hdr.ipv4.src_addr
        16..19: W28  # egress::hdr.ipv4.dst_addr
        save: { byte1 : 0, half : 6..7, byte0 : 9 }
        shift: 20
        buf_req: 20
        next: parse_ipv4.$split_0
    parse_ipv4.$split_0:  # from state egress::parse_ipv4.$split_0
      match: [ byte0, byte1, half ]
      0x***6****:
        B49: 2  # value 1 -> B49 bit[1]: egress::hdr.ipv4.$valid
        buf_req: 0
        next: parse_ipv4_options
      0x********:
        B49: 2  # value 1 -> B49 bit[1]: egress::hdr.ipv4.$valid
        buf_req: 0
        next: end
    parse_ipv4_options:  # from state egress::parse_ipv4_options
      match: [ byte0, half ]
      0x******:
        shift: 4
        buf_req: 4
        next: end
    parse_ipv6:  # from state egress::parse_ipv6
      *:
        0: B37
            # - bit[0..3] -> B37 bit[7..4]: egress::hdr.ipv6.version
            # - bit[4..7] -> B37 bit[3..0]: egress::hdr.ipv6.traffic_class[7:4].4-7
        1: B34
            # - bit[8..11] -> B34 bit[7..4]: egress::hdr.ipv6.traffic_class[3:0].0-3
            # - bit[12..15] -> B34 bit[3..0]: egress::hdr.ipv6.flow_label[19:16].16-19
        2..3: TH0  # egress::hdr.ipv6.flow_label[15:0].0-15
        4..5: H16  # egress::hdr.ipv6.payload_len
        6: TB3  # egress::hdr.ipv6.next_hdr
        7: B19  # egress::hdr.ipv6.hop_limit
        8..9: TH4  # egress::hdr.ipv6.src_addr[127:112].112-127
        10..11: TH3  # egress::hdr.ipv6.src_addr[111:96].96-111
        16..19: TW3  # egress::hdr.ipv6.src_addr[63:32].32-63
        20..23: TW2  # egress::hdr.ipv6.src_addr[31:0].0-31
        24..27: TW11  # egress::hdr.ipv6.dst_addr[127:96].96-127
        28..31: TW10  # egress::hdr.ipv6.dst_addr[95:64].64-95
        save: { byte1 : 6 }
        shift: 12
        buf_req: 32
        next: parse_ipv6.$split_0
    parse_ipv6.$split_0:  # from state egress::parse_ipv6.$split_0
      match: [ byte1 ]
      0x**:
        0..1: TH2  # egress::hdr.ipv6.src_addr[95:80].80-95
        2..3: TH1  # egress::hdr.ipv6.src_addr[79:64].64-79
        20..23: TW9  # egress::hdr.ipv6.dst_addr[63:32].32-63
        24..27: TW8  # egress::hdr.ipv6.dst_addr[31:0].0-31
        W31: 4  # value 1 -> W31 bit[2]: egress::hdr.ipv6.$valid
        shift: 28
        buf_req: 28
        next: end
    parse_vlan:  # from state egress::parse_vlan
      match: [ half ]
      0x0800:
        0..1: H54
            # - bit[0..2] -> H54 bit[15..13]: egress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H54 bit[12]: egress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H54 bit[11..0]: egress::hdr.vlan_tag[0].vid
        2..3: H35  # egress::hdr.vlan_tag[0].ether_type
        B21: 2  # value 2 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv4
      0x8100:
        0..1: H54
            # - bit[0..2] -> H54 bit[15..13]: egress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H54 bit[12]: egress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H54 bit[11..0]: egress::hdr.vlan_tag[0].vid
        2..3: H35  # egress::hdr.vlan_tag[0].ether_type
        B21: 2  # value 2 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        save: { half : 6..7 }
        shift: 4
        buf_req: 8
        next: parse_vlan.0
      0x86dd:
        0..1: H54
            # - bit[0..2] -> H54 bit[15..13]: egress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H54 bit[12]: egress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H54 bit[11..0]: egress::hdr.vlan_tag[0].vid
        2..3: H35  # egress::hdr.vlan_tag[0].ether_type
        B21: 2  # value 2 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv6
      0x****:
        0..1: H54
            # - bit[0..2] -> H54 bit[15..13]: egress::hdr.vlan_tag[0].pcp
            # - bit[3] -> H54 bit[12]: egress::hdr.vlan_tag[0].cfi
            # - bit[4..15] -> H54 bit[11..0]: egress::hdr.vlan_tag[0].vid
        2..3: H35  # egress::hdr.vlan_tag[0].ether_type
        B21: 2  # value 2 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: end
    parse_vlan.0:  # from state egress::parse_vlan.0
      match: [ half ]
      0x0800:
        0..3: TW0
            # - bit[0..2] -> TW0 bit[31..29]: egress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW0 bit[28]: egress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW0 bit[27..16]: egress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.vlan_tag[1].ether_type
        B21: 1  # value 1 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv4
      0x8100:
        0..3: TW0
            # - bit[0..2] -> TW0 bit[31..29]: egress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW0 bit[28]: egress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW0 bit[27..16]: egress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.vlan_tag[1].ether_type
        B21: 1  # value 1 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: end
      0x86dd:
        0..3: TW0
            # - bit[0..2] -> TW0 bit[31..29]: egress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW0 bit[28]: egress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW0 bit[27..16]: egress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.vlan_tag[1].ether_type
        B21: 1  # value 1 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_ipv6
      0x****:
        0..3: TW0
            # - bit[0..2] -> TW0 bit[31..29]: egress::hdr.vlan_tag[1].pcp
            # - bit[3] -> TW0 bit[28]: egress::hdr.vlan_tag[1].cfi
            # - bit[4..15] -> TW0 bit[27..16]: egress::hdr.vlan_tag[1].vid
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.vlan_tag[1].ether_type
        B21: 1  # value 1 -> B21 bit[1..0]: egress::hdr.vlan_tag.$stkvalid
        shift: 4
        buf_req: 4
        next: end
    parse_port_mirrored_metadata:  # from state egress::parse_port_mirrored_metadata
      *:
        0: B43  # egress::eg_md.pkt_src
        1: B17  # egress::eg_md.mirror.type
        2..3: H71  # egress::eg_md.ingress_timestamp[47:32].32-47
        4..7: W16  # egress::eg_md.ingress_timestamp[31:0].0-31
        8..9: H20  # bit[70..79] -> H20 bit[9..0]: egress::eg_md.mirror.session_id
        10..13: W24  # egress::hdr.ethernet.dst_addr[47:16].16-47
        14..15: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        16..19: W22  # egress::hdr.ethernet.src_addr[47:16].16-47
        20..21: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        B22: 191  # value 191 -> B22 bit[7..0]: egress::eg_md.bypass
        B49: 1  # value 1 -> B49 bit[0]: egress::hdr.ethernet.$valid
        shift: 22
        buf_req: 22
        next: parse_port_mirrored_metadata.$split_0
    parse_port_mirrored_metadata.$split_0:  # from state egress::parse_port_mirrored_metadata.$split_0
      *:
        0..1: H37  # egress::hdr.ethernet.ether_type
        shift: 2
        buf_req: 2
        next: end
    parse_cpu_mirrored_metadata:  # from state egress::parse_cpu_mirrored_metadata
      *:
        0: B43  # egress::eg_md.pkt_src
        1: B17  # egress::eg_md.mirror.type
        4..5: H64  # egress::eg_md.bd
        8..9: H69  # egress::eg_md.cpu_reason
        10..13: W24  # egress::hdr.ethernet.dst_addr[47:16].16-47
        14..15: H51  # egress::hdr.ethernet.dst_addr[15:0].0-15
        16..19: W22  # egress::hdr.ethernet.src_addr[47:16].16-47
        20..21: H49  # egress::hdr.ethernet.src_addr[15:0].0-15
        B22: 191  # value 191 -> B22 bit[7..0]: egress::eg_md.bypass
        B49: 1  # value 1 -> B49 bit[0]: egress::hdr.ethernet.$valid
        shift: 22
        buf_req: 22
        next: parse_cpu_mirrored_metadata.$split_0
    parse_cpu_mirrored_metadata.$split_0:  # from state egress::parse_cpu_mirrored_metadata.$split_0
      *:
        0..1: H37  # egress::hdr.ethernet.ether_type
        shift: 2
        buf_req: 2
        next: end
    parse_dtel_drop_metadata:  # from state egress::parse_dtel_drop_metadata
      *:
        0: B43  # egress::eg_md.pkt_src
        1: B17  # egress::eg_md.mirror.type
        2..3: H71  # egress::eg_md.ingress_timestamp[47:32].32-47
        4..7: W16  # egress::eg_md.ingress_timestamp[31:0].0-31
        8..9: H20  # bit[70..79] -> H20 bit[9..0]: egress::eg_md.mirror.session_id
        10..11: H26  # egress::eg_md.dtel.hash[31:16].16-31
        12..13: H24  # egress::eg_md.dtel.hash[15:0].0-15
        14: B33  # bit[116..119] -> B33 bit[3..0]: egress::eg_md.dtel.report_type
        19: TB2  # bit[155..159] -> TB2 bit[4..0]: egress::hdr.dtel_drop_report.queue_id
        W31: 1  # value 1 -> W31 bit[0]: egress::hdr.dtel_drop_report.$valid
        shift: 15
        buf_req: 20
        next: parse_dtel_drop_metadata.$split_0
    parse_dtel_drop_metadata.$split_0:  # from state egress::parse_dtel_drop_metadata.$split_0
      *:
        0..1: H55  # bit[7..15] -> H55 bit[8..0]: egress::hdr.dtel_drop_report.ingress_port
        5: TB0  # egress::hdr.dtel_drop_report.drop_reason
        B23: 1  # value 1 -> B23 bit[0]: egress::hdr.dtel_drop_report.egress_port[8:8].8-8
        B25: 255  # value 255 -> B25 bit[7..0]: egress::hdr.dtel_drop_report.egress_port[7:0].0-7
        shift: 6
        buf_req: 6
        next: end
    parse_dtel_switch_local_metadata:  # from state egress::parse_dtel_switch_local_metadata
      *:
        0: B43  # egress::eg_md.pkt_src
        1: B17  # egress::eg_md.mirror.type
        2..3: H71  # egress::eg_md.ingress_timestamp[47:32].32-47
        4..7: W16  # egress::eg_md.ingress_timestamp[31:0].0-31
        8..9: H20  # bit[70..79] -> H20 bit[9..0]: egress::eg_md.mirror.session_id
        10..11: H26  # egress::eg_md.dtel.hash[31:16].16-31
        12..13: H24  # egress::eg_md.dtel.hash[15:0].0-15
        14: B33  # bit[116..119] -> B33 bit[3..0]: egress::eg_md.dtel.report_type
        19..22: TW0
            # - bit[155..159] -> TW0 bit[28..24]: egress::hdr.dtel_switch_local_report.queue_id
            # - bit[165..183] -> TW0 bit[18..0]: egress::hdr.dtel_switch_local_report.queue_occupancy
        23..26: TW2  # egress::hdr.dtel_switch_local_report.timestamp
        W31: 8  # value 1 -> W31 bit[3]: egress::hdr.dtel_switch_local_report.$valid
        shift: 15
        buf_req: 27
        next: parse_dtel_switch_local_metadata.$split_0
    parse_dtel_switch_local_metadata.$split_0:  # from state egress::parse_dtel_switch_local_metadata.$split_0
      *:
        0..1: H29  # bit[7..15] -> H29 bit[8..0]: egress::hdr.dtel_switch_local_report.ingress_port
        2..3: H28  # bit[23..31] -> H28 bit[8..0]: egress::hdr.dtel_switch_local_report.egress_port
        shift: 12
        buf_req: 12
        next: end
deparser egress:
  dictionary:
    W24: B49(0)  # egress::hdr.ethernet.dst_addr.16-47 if egress::hdr.ethernet.$valid
    H51: B49(0)  # egress::hdr.ethernet.dst_addr.0-15 if egress::hdr.ethernet.$valid
    W22: B49(0)  # egress::hdr.ethernet.src_addr.16-47 if egress::hdr.ethernet.$valid
    H49: B49(0)  # egress::hdr.ethernet.src_addr.0-15 if egress::hdr.ethernet.$valid
    H37: B49(0)  # egress::hdr.ethernet.ether_type if egress::hdr.ethernet.$valid
    B16: W31(4)  # egress::hdr.fabric.reserved if egress::hdr.fabric.$valid
    B16: W31(4)
        # - bit[7..5]: egress::hdr.fabric.color if egress::hdr.fabric.$valid
        # - bit[4..0]: egress::hdr.fabric.qos if egress::hdr.fabric.$valid
    B16: W31(4)  # egress::hdr.fabric.reserved2 if egress::hdr.fabric.$valid
    B16: W31(4)  # egress::hdr.fabric.dst_port_or_group.8-15 if egress::hdr.fabric.$valid
    B16: W31(4)  # egress::hdr.fabric.dst_port_or_group.0-7 if egress::hdr.fabric.$valid
    B16: W31(1)
        # - bit[7..3]: egress::hdr.cpu.egress_queue if egress::hdr.cpu.$valid
        # - bit[2]: egress::hdr.cpu.tx_bypass if egress::hdr.cpu.$valid
        # - bit[1]: egress::hdr.cpu.capture_ts if egress::hdr.cpu.$valid
        # - bit[0]: egress::hdr.cpu.reserved if egress::hdr.cpu.$valid
    H31: W31(1)  # egress::hdr.cpu.ingress_port if egress::hdr.cpu.$valid
    H68: W31(1)  # egress::hdr.cpu.ingress_ifindex if egress::hdr.cpu.$valid
    H64: W31(1)  # egress::hdr.cpu.ingress_bd if egress::hdr.cpu.$valid
    H69: W31(1)  # egress::hdr.cpu.reason_code if egress::hdr.cpu.$valid
    H34: W31(1)  # egress::hdr.cpu.ether_type if egress::hdr.cpu.$valid
    H54: B21(1)
        # - bit[15..13]: egress::hdr.vlan_tag[0].pcp if egress::hdr.vlan_tag[0].$valid
        # - bit[12]: egress::hdr.vlan_tag[0].cfi if egress::hdr.vlan_tag[0].$valid
        # - bit[11..0]: egress::hdr.vlan_tag[0].vid if egress::hdr.vlan_tag[0].$valid
    H35: B21(1)  # egress::hdr.vlan_tag[0].ether_type if egress::hdr.vlan_tag[0].$valid
    TW0: B21(0)
        # - bit[31..29]: egress::hdr.vlan_tag[1].pcp if egress::hdr.vlan_tag[1].$valid
        # - bit[28]: egress::hdr.vlan_tag[1].cfi if egress::hdr.vlan_tag[1].$valid
        # - bit[27..16]: egress::hdr.vlan_tag[1].vid if egress::hdr.vlan_tag[1].$valid
        # - bit[15..0]: egress::hdr.vlan_tag[1].ether_type if egress::hdr.vlan_tag[1].$valid
    B38: B49(1)
        # - bit[7..4]: egress::hdr.ipv4.version if egress::hdr.ipv4.$valid
        # - bit[3..0]: egress::hdr.ipv4.ihl if egress::hdr.ipv4.$valid
    B37: B49(1)  # egress::hdr.ipv4.diffserv if egress::hdr.ipv4.$valid
    H16: B49(1)  # egress::hdr.ipv4.total_len if egress::hdr.ipv4.$valid
    W26: B49(1)
        # - bit[31..16]: egress::hdr.ipv4.identification if egress::hdr.ipv4.$valid
        # - bit[15..13]: egress::hdr.ipv4.flags if egress::hdr.ipv4.$valid
        # - bit[12..0]: egress::hdr.ipv4.frag_offset if egress::hdr.ipv4.$valid
    B19: B49(1)  # egress::hdr.ipv4.ttl if egress::hdr.ipv4.$valid
    B34: B49(1)  # egress::hdr.ipv4.protocol if egress::hdr.ipv4.$valid
    checksum 0: B49(1)  # egress::hdr.ipv4.$valid
    W27: B49(1)  # egress::hdr.ipv4.src_addr if egress::hdr.ipv4.$valid
    W28: B49(1)  # egress::hdr.ipv4.dst_addr if egress::hdr.ipv4.$valid
    B37: W31(2)
        # - bit[7..4]: egress::hdr.ipv6.version if egress::hdr.ipv6.$valid
        # - bit[3..0]: egress::hdr.ipv6.traffic_class.4-7 if egress::hdr.ipv6.$valid
    B34: W31(2)
        # - bit[7..4]: egress::hdr.ipv6.traffic_class.0-3 if egress::hdr.ipv6.$valid
        # - bit[3..0]: egress::hdr.ipv6.flow_label.16-19 if egress::hdr.ipv6.$valid
    TH0: W31(2)  # egress::hdr.ipv6.flow_label.0-15 if egress::hdr.ipv6.$valid
    H16: W31(2)  # egress::hdr.ipv6.payload_len if egress::hdr.ipv6.$valid
    TB3: W31(2)  # egress::hdr.ipv6.next_hdr if egress::hdr.ipv6.$valid
    B19: W31(2)  # egress::hdr.ipv6.hop_limit if egress::hdr.ipv6.$valid
    TH4: W31(2)  # egress::hdr.ipv6.src_addr.112-127 if egress::hdr.ipv6.$valid
    TH3: W31(2)  # egress::hdr.ipv6.src_addr.96-111 if egress::hdr.ipv6.$valid
    TH2: W31(2)  # egress::hdr.ipv6.src_addr.80-95 if egress::hdr.ipv6.$valid
    TH1: W31(2)  # egress::hdr.ipv6.src_addr.64-79 if egress::hdr.ipv6.$valid
    TW3: W31(2)  # egress::hdr.ipv6.src_addr.32-63 if egress::hdr.ipv6.$valid
    TW2: W31(2)  # egress::hdr.ipv6.src_addr.0-31 if egress::hdr.ipv6.$valid
    TW11: W31(2)  # egress::hdr.ipv6.dst_addr.96-127 if egress::hdr.ipv6.$valid
    TW10: W31(2)  # egress::hdr.ipv6.dst_addr.64-95 if egress::hdr.ipv6.$valid
    TW9: W31(2)  # egress::hdr.ipv6.dst_addr.32-63 if egress::hdr.ipv6.$valid
    TW8: W31(2)  # egress::hdr.ipv6.dst_addr.0-31 if egress::hdr.ipv6.$valid
    H25: B49(5)  # egress::hdr.udp.src_port if egress::hdr.udp.$valid
    H27: B49(5)  # egress::hdr.udp.dst_port if egress::hdr.udp.$valid
    H18: B49(5)  # egress::hdr.udp.length if egress::hdr.udp.$valid
    B16: B49(5)  # egress::hdr.udp.checksum.8-15 if egress::hdr.udp.$valid
    B16: B49(5)  # egress::hdr.udp.checksum.0-7 if egress::hdr.udp.$valid
    W25: W31(5)
        # - bit[31..28]: egress::hdr.dtel.version if egress::hdr.dtel.$valid
        # - bit[27..24]: egress::hdr.dtel.next_proto if egress::hdr.dtel.$valid
        # - bit[23..21]: egress::hdr.dtel.d_q_f if egress::hdr.dtel.$valid
        # - bit[20..6]: egress::hdr.dtel.reserved if egress::hdr.dtel.$valid
        # - bit[5..0]: egress::hdr.dtel.hw_id if egress::hdr.dtel.$valid
    W29: W31(5)  # egress::hdr.dtel.seq_number if egress::hdr.dtel.$valid
    W17: W31(5)  # egress::hdr.dtel.timestamp if egress::hdr.dtel.$valid
    W30: W31(5)  # egress::hdr.dtel.switch_id if egress::hdr.dtel.$valid
    H29: W31(3)
        # - bit[15..9]: egress::hdr.dtel_switch_local_report.pad0 if egress::hdr.dtel_switch_local_report.$valid
        # - bit[8..0]: egress::hdr.dtel_switch_local_report.ingress_port if egress::hdr.dtel_switch_local_report.$valid
    H28: W31(3)
        # - bit[15..9]: egress::hdr.dtel_switch_local_report.pad1 if egress::hdr.dtel_switch_local_report.$valid
        # - bit[8..0]: egress::hdr.dtel_switch_local_report.egress_port if egress::hdr.dtel_switch_local_report.$valid
    TW0: W31(3)
        # - bit[31..29]: egress::hdr.dtel_switch_local_report.pad2 if egress::hdr.dtel_switch_local_report.$valid
        # - bit[28..24]: egress::hdr.dtel_switch_local_report.queue_id if egress::hdr.dtel_switch_local_report.$valid
        # - bit[23..19]: egress::hdr.dtel_switch_local_report.pad3 if egress::hdr.dtel_switch_local_report.$valid
        # - bit[18..0]: egress::hdr.dtel_switch_local_report.queue_occupancy if egress::hdr.dtel_switch_local_report.$valid
    TW2: W31(3)  # egress::hdr.dtel_switch_local_report.timestamp if egress::hdr.dtel_switch_local_report.$valid
    H55: W31(0)
        # - bit[15..9]: egress::hdr.dtel_drop_report.pad0 if egress::hdr.dtel_drop_report.$valid
        # - bit[8..0]: egress::hdr.dtel_drop_report.ingress_port if egress::hdr.dtel_drop_report.$valid
    B23: W31(0)
        # - bit[7..1]: egress::hdr.dtel_drop_report.pad1 if egress::hdr.dtel_drop_report.$valid
        # - bit[0]: egress::hdr.dtel_drop_report.egress_port.8-8 if egress::hdr.dtel_drop_report.$valid
    B25: W31(0)  # egress::hdr.dtel_drop_report.egress_port.0-7 if egress::hdr.dtel_drop_report.$valid
    TB2: W31(0)
        # - bit[7..5]: egress::hdr.dtel_drop_report.pad2 if egress::hdr.dtel_drop_report.$valid
        # - bit[4..0]: egress::hdr.dtel_drop_report.queue_id if egress::hdr.dtel_drop_report.$valid
    TB0: W31(0)  # egress::hdr.dtel_drop_report.drop_reason if egress::hdr.dtel_drop_report.$valid
    TH5: W31(0)  # egress::hdr.dtel_drop_report.reserved if egress::hdr.dtel_drop_report.$valid
    TB1: B49(2)
        # - bit[7]: egress::hdr.gre.C if egress::hdr.gre.$valid
        # - bit[6]: egress::hdr.gre.R if egress::hdr.gre.$valid
        # - bit[5]: egress::hdr.gre.K if egress::hdr.gre.$valid
        # - bit[4]: egress::hdr.gre.S if egress::hdr.gre.$valid
        # - bit[3]: egress::hdr.gre.s if egress::hdr.gre.$valid
        # - bit[2..0]: egress::hdr.gre.recurse if egress::hdr.gre.$valid
    B16: B49(2)
        # - bit[7..3]: egress::hdr.gre.flags if egress::hdr.gre.$valid
        # - bit[2..0]: egress::hdr.gre.version if egress::hdr.gre.$valid
    H70: B49(2)  # egress::hdr.gre.proto if egress::hdr.gre.$valid
    H65: B48(1)
        # - bit[15..12]: egress::hdr.erspan_type2.version if egress::hdr.erspan_type2.$valid
        # - bit[11..0]: egress::hdr.erspan_type2.vlan if egress::hdr.erspan_type2.$valid
    H21: B48(1)
        # - bit[15..10]: egress::hdr.erspan_type2.cos_en_t if egress::hdr.erspan_type2.$valid
        # - bit[9..0]: egress::hdr.erspan_type2.session_id if egress::hdr.erspan_type2.$valid
    TW1: B48(1)
        # - bit[31..20]: egress::hdr.erspan_type2.reserved if egress::hdr.erspan_type2.$valid
        # - bit[19..0]: egress::hdr.erspan_type2.index if egress::hdr.erspan_type2.$valid
    H66: B49(3)
        # - bit[15..12]: egress::hdr.erspan_type3.version if egress::hdr.erspan_type3.$valid
        # - bit[11..0]: egress::hdr.erspan_type3.vlan if egress::hdr.erspan_type3.$valid
    H22: B49(3)
        # - bit[15..10]: egress::hdr.erspan_type3.cos_bso_t if egress::hdr.erspan_type3.$valid
        # - bit[9..0]: egress::hdr.erspan_type3.session_id if egress::hdr.erspan_type3.$valid
    W19: B49(3)  # egress::hdr.erspan_type3.timestamp if egress::hdr.erspan_type3.$valid
    B16: B49(3)  # egress::hdr.erspan_type3.sgt.8-15 if egress::hdr.erspan_type3.$valid
    B16: B49(3)  # egress::hdr.erspan_type3.sgt.0-7 if egress::hdr.erspan_type3.$valid
    H52: B49(3)
        # - bit[15]: egress::hdr.erspan_type3.p if egress::hdr.erspan_type3.$valid
        # - bit[14..10]: egress::hdr.erspan_type3.ft if egress::hdr.erspan_type3.$valid
        # - bit[9..4]: egress::hdr.erspan_type3.hw_id if egress::hdr.erspan_type3.$valid
        # - bit[3]: egress::hdr.erspan_type3.d if egress::hdr.erspan_type3.$valid
        # - bit[2..1]: egress::hdr.erspan_type3.gra if egress::hdr.erspan_type3.$valid
        # - bit[0]: egress::hdr.erspan_type3.o if egress::hdr.erspan_type3.$valid
    B16: B49(4)
        # - bit[7..2]: egress::hdr.erspan_platform.id if egress::hdr.erspan_platform.$valid
        # - bit[1..0]: egress::hdr.erspan_platform.info.56-57 if egress::hdr.erspan_platform.$valid
    B16: B49(4)  # egress::hdr.erspan_platform.info.48-55 if egress::hdr.erspan_platform.$valid
    B16: B49(4)  # egress::hdr.erspan_platform.info.40-47 if egress::hdr.erspan_platform.$valid
    B16: B49(4)  # egress::hdr.erspan_platform.info.32-39 if egress::hdr.erspan_platform.$valid
    B16: B49(4)  # egress::hdr.erspan_platform.info.24-31 if egress::hdr.erspan_platform.$valid
    B16: B49(4)  # egress::hdr.erspan_platform.info.16-23 if egress::hdr.erspan_platform.$valid
    B16: B49(4)  # egress::hdr.erspan_platform.info.8-15 if egress::hdr.erspan_platform.$valid
    B16: B49(4)  # egress::hdr.erspan_platform.info.0-7 if egress::hdr.erspan_platform.$valid
    W23: B48(0)  # egress::hdr.inner_ethernet.dst_addr.16-47 if egress::hdr.inner_ethernet.$valid
    H50: B48(0)  # egress::hdr.inner_ethernet.dst_addr.0-15 if egress::hdr.inner_ethernet.$valid
    W21: B48(0)  # egress::hdr.inner_ethernet.src_addr.16-47 if egress::hdr.inner_ethernet.$valid
    H48: B48(0)  # egress::hdr.inner_ethernet.src_addr.0-15 if egress::hdr.inner_ethernet.$valid
    H36: B48(0)  # egress::hdr.inner_ethernet.ether_type if egress::hdr.inner_ethernet.$valid
  checksum 0:
    - B38: { swap: 1 }
        # - bit[7..4]: egress::hdr.ipv4.version
        # - bit[3..0]: egress::hdr.ipv4.ihl
    - B37: { }  # egress::hdr.ipv4.diffserv
    - H16: { }  # egress::hdr.ipv4.total_len
    - W26: { }
        # - bit[31..16]: egress::hdr.ipv4.identification
        # - bit[15..13]: egress::hdr.ipv4.flags
        # - bit[12..0]: egress::hdr.ipv4.frag_offset
    - B19: { swap: 1 }  # egress::hdr.ipv4.ttl
    - B34: { }  # egress::hdr.ipv4.protocol
    - W27: { }  # egress::hdr.ipv4.src_addr
    - W28: { }  # egress::hdr.ipv4.dst_addr
  drop_ctl: B21(2..4)  # bit[4..2]: egress::eg_intr_md_for_dprsr.drop_ctl
  egress_unicast_port: H32(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
  mirror:
    select: B18(0..2)  # bit[2..0]: egress::eg_intr_md_for_dprsr.mirror_type
    1:
      - H20(0..9)  # bit[9..0]: egress::eg_md.mirror.session_id
      - B20  # egress::eg_md.mirror.src
      - B17  # egress::eg_md.mirror.type
      - H71  # egress::eg_md.ingress_timestamp.32-47
      - W16  # egress::eg_md.ingress_timestamp.0-31
      - H20(0..9)  # bit[9..0]: egress::eg_md.mirror.session_id
    2:
      - H20(0..9)  # bit[9..0]: egress::eg_md.mirror.session_id
      - B20  # egress::eg_md.mirror.src
      - B17  # egress::eg_md.mirror.type
      - H30(0..8)  # bit[8..0]: egress::eg_md.ingress_port
      - H64  # egress::eg_md.bd
      - H68  # egress::eg_md.ingress_ifindex
      - H69  # egress::eg_md.cpu_reason
    4:
      - H23(0..9)  # bit[9..0]: egress::eg_md.dtel.session_id
      - B20  # egress::eg_md.mirror.src
      - B17  # egress::eg_md.mirror.type
      - H71  # egress::eg_md.ingress_timestamp.32-47
      - W16  # egress::eg_md.ingress_timestamp.0-31
      - H23(0..9)  # bit[9..0]: egress::eg_md.dtel.session_id
      - H26  # egress::eg_md.dtel.hash.16-31
      - H24  # egress::eg_md.dtel.hash.0-15
      - B33(0..3)  # bit[3..0]: egress::eg_md.dtel.report_type
      - H30(0..8)  # bit[8..0]: egress::eg_md.ingress_port
      - B24(0..0)  # bit[0]: egress::eg_md.port.8-8
      - B26  # egress::eg_md.port.0-7
      - B32(0..4)  # bit[4..0]: egress::eg_md.qos.qid
      - H67(0..10)  # bit[10..0]: egress::eg_md.qos.qdepth.8-18
      - B35  # egress::eg_md.qos.qdepth.0-7
      - W18  # egress::eg_md.timestamp[31:0]
stage 0 ingress:
  phase0_match SwitchIngressParser.$PORT_METADATA:
    p4:
      name: SwitchIngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {port_lag_index: 48..57, port_lag_label: 32..47, ifindex: 16..31}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { port_lag_index: 10, port_lag_label: 16, ifindex: 16 } 
  ternary_match pkt_validation_validate_ethernet 1:
    p4: { name: SwitchIngress.pkt_validation.validate_ethernet, size: 64 }
    p4_param_order: 
      hdr.ethernet.src_addr: { type: ternary, size: 48, full_size: 48 }
      hdr.ethernet.dst_addr: { type: ternary, size: 48, full_size: 48 }
      hdr.vlan_tag$0.$valid: { type: ternary, size: 1, full_size: 1 }
    row: [ 0, 1, 2 ]
    bus: [ 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: hdr.ethernet.src_addr.16-47(0..7), 8: hdr.ethernet.dst_addr.16-47(8..15), 16: hdr.ethernet.src_addr.16-47(16..31), 32: hdr.ethernet.dst_addr.16-47(0..7) }
      ternary group 1: { 0: hdr.ethernet.dst_addr.16-47(16..31), 16: hdr.ethernet.src_addr.0-15, 32: hdr.ethernet.dst_addr.0-15(0..7) }
      ternary group 2: { 0: hdr.ethernet.dst_addr.0-15(8..15), 9: hdr.vlan_tag$0.$valid }
      byte group 0: { 0: hdr.ethernet.src_addr.16-47(8..15) }
    match:
    - { group: 0, byte_group: 0, byte_config: 0, dirtcam: 0x555 }
    - { group: 1, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 2, byte_config: 3, dirtcam: 0x5 }
    hit: [  tbl_act_11,  pkt_validation_validate_other,  pkt_validation_validate_other,  pkt_validation_validate_other,  pkt_validation_validate_other,  pkt_validation_validate_other,  pkt_validation_validate_other ]
    miss:  pkt_validation_validate_other
    indirect: pkt_validation_validate_ethernet$tind
  ternary_indirect pkt_validation_validate_ethernet$tind:
    row: 3
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.ethernet.src_addr.16-47(0..7), 8: hdr.ethernet.dst_addr.16-47(8..15), 16: hdr.ethernet.src_addr.16-47(16..31), 32: hdr.ethernet.dst_addr.16-47(0..7) }
      ternary group 1: { 0: hdr.ethernet.dst_addr.16-47(16..31), 16: hdr.ethernet.src_addr.0-15, 32: hdr.ethernet.dst_addr.0-15(0..7) }
      ternary group 2: { 0: hdr.ethernet.dst_addr.0-15(8..15), 9: hdr.vlan_tag$0.$valid }
      byte group 0: { 0: hdr.ethernet.src_addr.16-47(8..15) }
    format: { action: 0..2, immediate: 3..10 }
    action_bus: { 0 : immediate(0..7) }
    instruction: pkt_validation_validate_ethernet$tind(action, $DEFAULT)
    actions:
      SwitchIngress.pkt_validation.malformed_non_ip_pkt(0, 1):
      - p4_param_order: { reason: 8 }
      - default_action: { allowed: true }
      - handle: 0x20000001
      - next_table: 0
      - { reason: immediate(0..7) }
      - set ig_md.lkp.mac_src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set ig_md.lkp.mac_src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set ig_md.lkp.mac_dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set ig_md.lkp.mac_dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set ig_md.lkp.mac_type, hdr.ethernet.ether_type
      - set ig_md.drop_reason, reason
      SwitchIngress.pkt_validation.valid_unicast_pkt_untagged(1, 2):
      - default_action: { allowed: true }
      - handle: 0x20000002
      - next_table: 1
      - {  }
      - set ig_md.lkp.pkt_type, 0
      - set ig_md.lkp.mac_src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set ig_md.lkp.mac_src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set ig_md.lkp.mac_dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set ig_md.lkp.mac_dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set ig_md.lkp.mac_type, hdr.ethernet.ether_type
      SwitchIngress.pkt_validation.valid_multicast_pkt_untagged(2, 4):
      - default_action: { allowed: true }
      - handle: 0x20000003
      - next_table: 2
      - {  }
      - set ig_md.lkp.pkt_type, 1
      - set ig_md.lkp.mac_src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set ig_md.lkp.mac_src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set ig_md.lkp.mac_dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set ig_md.lkp.mac_dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set ig_md.lkp.mac_type, hdr.ethernet.ether_type
      SwitchIngress.pkt_validation.valid_broadcast_pkt_untagged(3, 6):
      - default_action: { allowed: true }
      - handle: 0x20000004
      - next_table: 3
      - {  }
      - set ig_md.lkp.pkt_type, 2
      - set ig_md.lkp.mac_src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set ig_md.lkp.mac_src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set ig_md.lkp.mac_dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set ig_md.lkp.mac_dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set ig_md.lkp.mac_type, hdr.ethernet.ether_type
      SwitchIngress.pkt_validation.valid_unicast_pkt_tagged(4, 8):
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 4
      - {  }
      - set ig_md.lkp.pkt_type, 0
      - set ig_md.lkp.mac_src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set ig_md.lkp.mac_src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set ig_md.lkp.mac_dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set ig_md.lkp.mac_dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set ig_md.lkp.mac_type, hdr.vlan_tag$0.ether_type
      - set ig_md.lkp.pcp, hdr.vlan_tag$0.pcp
      SwitchIngress.pkt_validation.valid_multicast_pkt_tagged(5, 10):
      - default_action: { allowed: true }
      - handle: 0x20000006
      - next_table: 5
      - {  }
      - set ig_md.lkp.pkt_type, 1
      - set ig_md.lkp.mac_src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set ig_md.lkp.mac_src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set ig_md.lkp.mac_dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set ig_md.lkp.mac_dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set ig_md.lkp.mac_type, hdr.vlan_tag$0.ether_type
      - set ig_md.lkp.pcp, hdr.vlan_tag$0.pcp
      SwitchIngress.pkt_validation.valid_broadcast_pkt_tagged(6, 12):
      - default_action: { allowed: true }
      - handle: 0x20000007
      - next_table: 6
      - {  }
      - set ig_md.lkp.pkt_type, 2
      - set ig_md.lkp.mac_src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set ig_md.lkp.mac_src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set ig_md.lkp.mac_dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set ig_md.lkp.mac_dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set ig_md.lkp.mac_type, hdr.vlan_tag$0.ether_type
      - set ig_md.lkp.pcp, hdr.vlan_tag$0.pcp
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000008
      - next_table_miss:  pkt_validation_validate_other
      - {  }
    default_only_action: NoAction
  exact_match pkt_validation_validate_other 2:
    p4: { name: SwitchIngress.pkt_validation.validate_other }
    p4_param_order: 
      hdr.tcp.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.udp.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.icmp.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.igmp.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.arp.$valid: { type: exact, size: 1, full_size: 1 }
    row: 6
    bus: 1
    column: 7
    stash: 
      row: [ 6 ]
      col: [ 7 ]
      unit: [ 0 ]
    ways:
      - [0, 1, 0x0, [6, 7]]
    input_xbar:
      exact group 0: { 19: hdr.icmp.$valid, 20: hdr.igmp.$valid, 21: hdr.tcp.$valid, 22: hdr.udp.$valid, 24: hdr.arp.$valid }
      hash 0:
        10: hdr.icmp.$valid
        11: hdr.igmp.$valid
        12: hdr.tcp.$valid
        13: hdr.udp.$valid
        14: hdr.arp.$valid
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..2, version(0): 112..115 }
    hit: [  pkt_validation_validate_ipv4 ]
    miss:  pkt_validation_validate_ipv4
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.tcp.$valid
          value: "0x1"
        - field_name: hdr.udp.$valid
          value: "0x0"
        - field_name: hdr.icmp.$valid
          value: "0x0"
        - field_name: hdr.igmp.$valid
          value: "0x0"
        - field_name: hdr.arp.$valid
          value: "0x0"
        action_handle: 0x20000010
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.tcp.$valid
          value: "0x0"
        - field_name: hdr.udp.$valid
          value: "0x1"
        - field_name: hdr.icmp.$valid
          value: "0x0"
        - field_name: hdr.igmp.$valid
          value: "0x0"
        - field_name: hdr.arp.$valid
          value: "0x0"
        action_handle: 0x20000011
        is_default_entry: false
        action_parameters_values: []
      - priority: 2
        match_key_fields_values:
        - field_name: hdr.tcp.$valid
          value: "0x0"
        - field_name: hdr.udp.$valid
          value: "0x0"
        - field_name: hdr.icmp.$valid
          value: "0x1"
        - field_name: hdr.igmp.$valid
          value: "0x0"
        - field_name: hdr.arp.$valid
          value: "0x0"
        action_handle: 0x20000012
        is_default_entry: false
        action_parameters_values: []
      - priority: 3
        match_key_fields_values:
        - field_name: hdr.tcp.$valid
          value: "0x0"
        - field_name: hdr.udp.$valid
          value: "0x0"
        - field_name: hdr.icmp.$valid
          value: "0x0"
        - field_name: hdr.igmp.$valid
          value: "0x1"
        - field_name: hdr.arp.$valid
          value: "0x0"
        action_handle: 0x20000013
        is_default_entry: false
        action_parameters_values: []
      - priority: 4
        match_key_fields_values:
        - field_name: hdr.tcp.$valid
          value: "0x0"
        - field_name: hdr.udp.$valid
          value: "0x0"
        - field_name: hdr.icmp.$valid
          value: "0x0"
        - field_name: hdr.igmp.$valid
          value: "0x0"
        - field_name: hdr.arp.$valid
          value: "0x1"
        action_handle: 0x20000014
        is_default_entry: false
        action_parameters_values: []
    instruction: pkt_validation_validate_other(action, $DEFAULT)
    actions:
      SwitchIngress.pkt_validation.init_l4_lkp_ports(0, 0):
      - default_action: { allowed: true }
      - handle: 0x2000000f
      - next_table: 0
      SwitchIngress.pkt_validation.set_tcp_ports(1, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000010
      - next_table: 0
      - set ig_md.lkp.l4_src_port.0-7, hdr.tcp.src_port.0-7
      - set ig_md.lkp.l4_src_port.8-15, hdr.tcp.src_port.8-15
      - set ig_md.lkp.l4_dst_port, hdr.tcp.dst_port
      - set ig_md.lkp.tcp_flags, hdr.tcp.flags
      SwitchIngress.pkt_validation.set_udp_ports(2, 5):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000011
      - next_table: 0
      - set ig_md.lkp.l4_src_port.0-7, hdr.udp.src_port.0-7
      - set ig_md.lkp.l4_src_port.8-15, hdr.udp.src_port.8-15
      - set ig_md.lkp.l4_dst_port, hdr.udp.dst_port
      SwitchIngress.pkt_validation.set_icmp_type(3, 7):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000012
      - next_table: 0
      - set ig_md.lkp.l4_src_port.0-7, hdr.icmp.type
      - set ig_md.lkp.l4_src_port.8-15, hdr.icmp.code
      SwitchIngress.pkt_validation.set_igmp_type(4, 9):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000013
      - next_table: 0
      SwitchIngress.pkt_validation.set_arp_opcode(5, 11):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000014
      - next_table: 0
      - set ig_md.lkp.arp_opcode, hdr.arp.opcode
    default_action: SwitchIngress.pkt_validation.init_l4_lkp_ports
  ternary_match pkt_validation_validate_ipv4 6:
    p4: { name: SwitchIngress.pkt_validation.validate_ipv4, size: 64 }
    p4_param_order: 
      ig_md.flags.ipv4_checksum_err: { type: ternary, size: 1, full_size: 1, key_name: "flags.ipv4_checksum_err" }
      hdr.ipv4.version: { type: ternary, size: 4, full_size: 4 }
      hdr.ipv4.ihl: { type: ternary, size: 4, full_size: 4 }
      hdr.ipv4.flags: { type: ternary, size: 3, full_size: 3 }
      hdr.ipv4.frag_offset: { type: ternary, size: 13, full_size: 13 }
      hdr.ipv4.ttl: { type: ternary, size: 8, full_size: 8 }
      hdr.ipv4.src_addr: { type: ternary, size: 8, full_size: 32, start_bit: 24 }
    row: [ 6, 7 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 2: { 16: hdr.ipv4.ihl, 20: hdr.ipv4.version, 24: hdr.ipv4.frag_offset(0..7), 32: hdr.ipv4.src_addr(24..31) }
      ternary group 3: { 0: hdr.ipv4.ttl, 10: ig_md.flags.ipv4_checksum_err, 16: hdr.ipv4.frag_offset(8..12), 21: hdr.ipv4.flags }
    match:
    - { group: 2, byte_config: 3, dirtcam: 0x150 }
    - { group: 3, dirtcam: 0x15 }
    gateway:
      name: cond-1
      input_xbar:
        exact group 0: { 18: hdr.ipv4.$valid }
      row: 6
      bus: 1
      unit: 1
      match: { 2: hdr.ipv4.$valid }
      0b*****1: run_table
      miss:  pkt_validation_validate_ipv6
      condition: 
        expression: "(hdr.ipv4.$valid == 1)"
        true:  pkt_validation_validate_ipv4
        false:  pkt_validation_validate_ipv6
    hit: [  tbl_act_11 ]
    miss:  tbl_act_11
    indirect: pkt_validation_validate_ipv4$tind
  ternary_indirect pkt_validation_validate_ipv4$tind:
    row: 2
    bus: 0
    column: 2
    input_xbar:
      ternary group 2: { 16: hdr.ipv4.ihl, 20: hdr.ipv4.version, 24: hdr.ipv4.frag_offset(0..7), 32: hdr.ipv4.src_addr(24..31) }
      ternary group 3: { 0: hdr.ipv4.ttl, 10: ig_md.flags.ipv4_checksum_err, 16: hdr.ipv4.frag_offset(8..12), 21: hdr.ipv4.flags }
    format: { action: 0..1, immediate: 2..9 }
    action_bus: { 4 : immediate(0..7), 40..41 : immediate(0..7) }
    instruction: pkt_validation_validate_ipv4$tind(action, $DEFAULT)
    actions:
      SwitchIngress.pkt_validation.valid_ipv4_pkt(1, 13):
      - p4_param_order: { ip_frag: 2 }
      - default_action: { allowed: true }
      - handle: 0x20000009
      - next_table: 0
      - { $data0: immediate(0..3), $constant0: $data0(0..1), $constant0: 1, ip_frag: $data0(2..3) }
      - set ig_md.lkp.ip_ttl, hdr.ipv4.ttl
      - set ig_md.lkp.ip_src_addr.32-63, 0
      - set ig_md.lkp.ip_src_addr.64-95, 0
      - set ig_md.lkp.ip_src_addr.96-127, 0
      - set ig_md.lkp.ip_src_addr.0-23, hdr.ipv4.src_addr(0..23)
      - set ig_md.lkp.ip_src_addr.24-31, hdr.ipv4.src_addr(24..31)
      - set ig_md.lkp.ip_dst_addr.32-63, 0
      - set ig_md.lkp.ip_dst_addr.64-95, 0
      - set ig_md.lkp.ip_dst_addr.96-127, 0
      - set ig_md.lkp.ip_dst_addr.0-31, hdr.ipv4.dst_addr
      - set H4(10..13), $data0
      - deposit-field H13(8..15), H14(0..7), H12
      SwitchIngress.pkt_validation.malformed_ipv4_pkt(2, 14):
      - p4_param_order: { reason: 8 }
      - default_action: { allowed: true }
      - handle: 0x2000000a
      - next_table: 0
      - { reason: immediate(0..7) }
      - set ig_md.lkp.ip_type, 1
      - set ig_md.lkp.ip_ttl, hdr.ipv4.ttl
      - set ig_md.lkp.ip_src_addr.32-63, 0
      - set ig_md.lkp.ip_src_addr.64-95, 0
      - set ig_md.lkp.ip_src_addr.96-127, 0
      - set ig_md.lkp.ip_src_addr.0-23, hdr.ipv4.src_addr(0..23)
      - set ig_md.lkp.ip_src_addr.24-31, hdr.ipv4.src_addr(24..31)
      - set ig_md.lkp.ip_dst_addr.32-63, 0
      - set ig_md.lkp.ip_dst_addr.64-95, 0
      - set ig_md.lkp.ip_dst_addr.96-127, 0
      - set ig_md.lkp.ip_dst_addr.0-31, hdr.ipv4.dst_addr
      - set ig_md.drop_reason, reason
      - deposit-field H13(8..15), H14(0..7), H12
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000000b
      - next_table: 0
      - {  }
    default_only_action: NoAction
  ternary_match pkt_validation_validate_ipv6 7:
    p4: { name: SwitchIngress.pkt_validation.validate_ipv6, size: 64 }
    p4_param_order: 
      hdr.ipv6.version: { type: ternary, size: 4, full_size: 4 }
      hdr.ipv6.hop_limit: { type: ternary, size: 8, full_size: 8 }
      hdr.ipv6.src_addr: { type: ternary, size: 32, full_size: 128, start_bit: 96 }
    row: [ 4, 5 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 4: { 0: hdr.ipv6.src_addr.96-127(16..31), 16: hdr.ipv6.src_addr.96-127(0..15), 32: hdr.ipv6.hop_limit }
      byte group 2: { 4: hdr.ipv6.version }
    match:
    - { group: 4, byte_group: 2, byte_config: 1, dirtcam: 0x555 }
    - { byte_config: 3, dirtcam: 0x0 }
    gateway:
      name: cond-2
      input_xbar:
        exact group 0: { 25: hdr.ipv6.$valid }
      row: 6
      bus: 0
      unit: 0
      match: { 1: hdr.ipv6.$valid }
      0b******1: run_table
      miss:  tbl_act_11
      condition: 
        expression: "(hdr.ipv6.$valid == 1)"
        true:  pkt_validation_validate_ipv6
        false:  tbl_act_11
    hit: [  tbl_act_11 ]
    miss:  tbl_act_11
    indirect: pkt_validation_validate_ipv6$tind
  ternary_indirect pkt_validation_validate_ipv6$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 4: { 0: hdr.ipv6.src_addr.96-127(16..31), 16: hdr.ipv6.src_addr.96-127(0..15), 32: hdr.ipv6.hop_limit }
      byte group 2: { 4: hdr.ipv6.version }
    format: { action: 0..1, immediate: 2..9 }
    action_bus: { 8 : immediate(0..7), 44..45 : immediate(0..7) }
    instruction: pkt_validation_validate_ipv6$tind(action, $DEFAULT)
    actions:
      SwitchIngress.pkt_validation.valid_ipv6_pkt(1, 16):
      - p4_param_order: { is_link_local: 1 }
      - default_action: { allowed: true }
      - handle: 0x2000000c
      - next_table: 0
      - { is_link_local: immediate(0..0) }
      - set ig_md.lkp.ip_type, 2
      - set ig_md.lkp.ip_src_addr.0-23, hdr.ipv6.src_addr.0-31(0..23)
      - set ig_md.lkp.ip_src_addr.24-31, hdr.ipv6.src_addr.0-31(24..31)
      - set ig_md.lkp.ip_src_addr.32-63, hdr.ipv6.src_addr.32-63
      - set ig_md.lkp.ip_src_addr.64-95, hdr.ipv6.src_addr.64-95
      - set ig_md.lkp.ip_src_addr.96-127, hdr.ipv6.src_addr.96-127
      - set ig_md.lkp.ip_dst_addr.0-31, hdr.ipv6.dst_addr.0-31
      - set ig_md.lkp.ip_dst_addr.32-63, hdr.ipv6.dst_addr.32-63
      - set ig_md.lkp.ip_dst_addr.64-95, hdr.ipv6.dst_addr.64-95
      - set ig_md.lkp.ip_dst_addr.96-127, hdr.ipv6.dst_addr.96-127
      - deposit-field H13(0..7), H12(4..11), H14
      - deposit-field H15(8..8), is_link_local, H14
      SwitchIngress.pkt_validation.malformed_ipv6_pkt(2, 18):
      - p4_param_order: { reason: 8 }
      - default_action: { allowed: true }
      - handle: 0x2000000d
      - next_table: 0
      - { reason: immediate(0..7) }
      - set ig_md.lkp.ip_type, 2
      - set ig_md.lkp.ip_ttl, hdr.ipv6.hop_limit
      - set ig_md.lkp.ip_src_addr.0-23, hdr.ipv6.src_addr.0-31(0..23)
      - set ig_md.lkp.ip_src_addr.24-31, hdr.ipv6.src_addr.0-31(24..31)
      - set ig_md.lkp.ip_src_addr.32-63, hdr.ipv6.src_addr.32-63
      - set ig_md.lkp.ip_src_addr.64-95, hdr.ipv6.src_addr.64-95
      - set ig_md.lkp.ip_src_addr.96-127, hdr.ipv6.src_addr.96-127
      - set ig_md.lkp.ip_dst_addr.0-31, hdr.ipv6.dst_addr.0-31
      - set ig_md.lkp.ip_dst_addr.32-63, hdr.ipv6.dst_addr.32-63
      - set ig_md.lkp.ip_dst_addr.64-95, hdr.ipv6.dst_addr.64-95
      - set ig_md.lkp.ip_dst_addr.96-127, hdr.ipv6.dst_addr.96-127
      - set ig_md.drop_reason, reason
      - deposit-field H13(0..7), H12(4..11), H14
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000000e
      - next_table: 0
      - {  }
    default_only_action: NoAction
  ternary_match tbl_act_11 8:
    p4: { name: tbl_act_11 }
    hit: [  ingress_port_mapping_port_mapping ]
    miss:  ingress_port_mapping_port_mapping
    indirect: tbl_act_11$tind
  ternary_indirect tbl_act_11$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_act_11$tind(action, $DEFAULT)
    actions:
      act_11(0, 15):
      - default_action: { allowed: true }
      - handle: 0x20000079
      - next_table: 0
      - set ig_md.qos.color, 0
      - set ig_md.qos.tc, 0
    default_action: act_11
  exact_match ingress_port_mapping_port_mapping 9:
    p4: { name: SwitchIngress.ingress_port_mapping.port_mapping, size: 8192 }
    p4_param_order: 
      ig_md.port: { type: exact, size: 9, full_size: 9 }
      hdr.cpu.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.cpu.ingress_port: { type: exact, size: 16, full_size: 16 }
    row: 7
    bus: 0
    column: [ 6, 7, 8, 9 ]
    stash: 
      row: [ 7 ]
      col: [ 9 ]
      unit: [ 0 ]
    ways:
      - [2, 0, 0x0, [7, 9]]
      - [2, 1, 0x0, [7, 6]]
      - [2, 2, 0x0, [7, 8]]
      - [2, 3, 0x0, [7, 7]]
    input_xbar:
      exact group 1: { 0: hdr.cpu.ingress_port, 16: ig_md.port, 42: hdr.cpu.$valid }
      hash 2:
        0..7: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.ingress_port(0..7)
        8: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ ig_md.port(8)
        9: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.$valid
        11..18: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.ingress_port(0..7)
        19: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ ig_md.port(8)
        10: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.$valid
        22..29: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.ingress_port(0..7)
        20: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ ig_md.port(8)
        21: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.$valid
        33..39: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.ingress_port(0..6)
        30: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.ingress_port(7)
        31: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ ig_md.port(8)
        32: random(hdr.cpu.ingress_port(8..15), ig_md.port(0..7)) ^ hdr.cpu.$valid
      hash group 2:
        table: [2]
        seed: 0xda5a628e80
    format: { action(0): 0..0, immediate(0): 2..17, version(0): 112..115, match(0): 40..55, action(1): 1..1, immediate(1): 18..33, version(1): 116..119, match(1): 56..71 }
    match: [ hdr.cpu.ingress_port(8..15), ig_md.port(0..7) ]
    hit: [  ingress_port_mapping_port_vlan_to_bd_mapping,  ingress_port_mapping_cpu_to_bd_mapping ]
    miss:  cond-34
    action_bus: { 12 : immediate(0..7), 48..49 : immediate(0..15) }
    action: ingress_port_mapping_port_mapping$action_data($DIRECT, $DEFAULT)
    instruction: ingress_port_mapping_port_mapping(action, $DEFAULT)
    actions:
      SwitchIngress.ingress_port_mapping.set_port_properties(0, 17):
      - p4_param_order: { exclusion_id: 9, learning_mode: 1, trust_mode: 2, qos_group: 5, color: 2, tc: 8, mac_pkt_class: 1 }
      - default_action: { allowed: true }
      - handle: 0x20000015
      - next_table: 0
      - { $data0: $adf_h0(0..13), exclusion_id: $data0(0..8), qos_group: $data0(9..13), trust_mode: $adf_h0(14..15), learning_mode: immediate(0..0) }
      - set ig_md.qos.trust_mode, trust_mode
      - set ig_md.learning.port_mode, learning_mode
      - set H7(0..13), $data0
      SwitchIngress.ingress_port_mapping.set_cpu_port_properties(1, 19):
      - p4_param_order: { port_lag_index: 10, port_lag_label: 16, exclusion_id: 9, trust_mode: 2, qos_group: 5, color: 2, tc: 8 }
      - default_action: { allowed: true }
      - handle: 0x20000019
      - next_table: 1
      - { $data0: $adf_h0(0..13), exclusion_id: $data0(0..8), qos_group: $data0(9..13), trust_mode: $adf_h0(14..15), port_lag_label: immediate(0..15) }
      - set ig_md.port_lag_label, port_lag_label
      - set ig_md.qos.trust_mode, trust_mode
      - set ig_md.port, hdr.cpu.ingress_port(0..8)
      - set ig_md.egress_ifindex, hdr.fabric.dst_port_or_group
      - set ig_intr_md_for_tm.bypass_egress, hdr.cpu.tx_bypass
      - set hdr.ethernet.ether_type, hdr.cpu.ether_type
      - set H7(0..13), $data0
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000001a
      - next_table_miss:  cond-34
      - {  }
    default_only_action: NoAction
  action ingress_port_mapping_port_mapping$action_data:
    p4: { name: SwitchIngress.ingress_port_mapping.port_mapping$action }
    row: 13
    column: 3
    vpns: [ 0 ]
    home_row:
    - 13
    format SwitchIngress.ingress_port_mapping.set_port_properties: { $adf_h0: 0..15 }
    format SwitchIngress.ingress_port_mapping.set_cpu_port_properties: { $adf_h0: 0..15 }
    action_bus: { 52..53 : $adf_h0 }
  ternary_match ingress_port_mapping_port_vlan_to_bd_mapping 10:
    p4: { name: SwitchIngress.ingress_port_mapping.port_vlan_to_bd_mapping, size: 1024, action_profile: SwitchIngress.ingress_port_mapping.bd_action_profile }
    p4_param_order: 
      ig_md.port_lag_index: { type: exact, size: 10, full_size: 10 }
      hdr.vlan_tag$0.$valid: { type: ternary, size: 1, full_size: 1 }
      hdr.vlan_tag$0.vid: { type: ternary, size: 12, full_size: 12 }
    row: [ 3, 8 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 5: { 0: hdr.vlan_tag$0.vid, 16: ig_md.port_lag_index.0-7, 24: ig_md.port_lag_index.8-9, 33: hdr.vlan_tag$0.$valid }
    match:
    - { group: 5, byte_config: 3, dirtcam: 0x155 }
    hit: [  cond-34 ]
    miss:  ingress_port_mapping_vlan_to_bd_mapping
    indirect: ingress_port_mapping_port_vlan_to_bd_mapping$tind
  ternary_indirect ingress_port_mapping_port_vlan_to_bd_mapping$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 5: { 0: hdr.vlan_tag$0.vid, 16: ig_md.port_lag_index.0-7, 24: ig_md.port_lag_index.8-9, 33: hdr.vlan_tag$0.$valid }
    format: { action: 0..1, action_addr: 2..15 }
    action: ingress_port_mapping_vlan_to_bd_mapping$action_data.SwitchIngress.ingress_port_mapping.bd_action_profile(action_addr, $DEFAULT)
    instruction: ingress_port_mapping_port_vlan_to_bd_mapping$tind(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x20000016
      - next_table_miss:  ingress_port_mapping_vlan_to_bd_mapping
      - next_table: 0
      - {  }
      SwitchIngress.ingress_port_mapping.port_vlan_miss(1, 20):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000017
      - next_table_miss:  ingress_port_mapping_vlan_to_bd_mapping
      - next_table: 0
      - {  }
      SwitchIngress.ingress_port_mapping.set_bd_properties(2, 21):
      - p4_param_order: { bd: 16, vrf: 14, bd_label: 16, rid: 16, stp_group: 10, learning_mode: 1, ipv4_unicast_enable: 1, ipv4_multicast_enable: 1, igmp_snooping_enable: 1, ipv6_unicast_enable: 1, ipv6_multicast_enable: 1, mld_snooping_enable: 1, mrpf_group: 16, rmac_group: 10 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000018
      - next_table_miss:  ingress_port_mapping_vlan_to_bd_mapping
      - next_table: 0
      - { rmac_group.0-7: $adf_b0(0..7), $data0: $adf_b1(0..6), ipv4_unicast_enable: $data0(0..0), ipv4_multicast_enable: $data0(1..1), igmp_snooping_enable: $data0(2..2), ipv6_unicast_enable: $data0(3..3), ipv6_multicast_enable: $data0(4..4), mld_snooping_enable: $data0(5..5), learning_mode: $data0(6..6), rid: $adf_h1(0..15), bd: $adf_h2(0..15), mrpf_group: $adf_h3(0..15), bd_label: $adf_h4(0..15), $data1: $adf_h5(0..15), vrf: $data1(0..13), rmac_group.8-9: $data1(14..15) }
      - set ig_md.bd, bd
      - set ig_md.bd_label, bd_label
      - set ig_intr_md_for_tm.rid, rid
      - set ig_md.rmac_group.0-7, rmac_group.0-7
      - set ig_md.multicast.rpf_group, mrpf_group
      - set B51(0..6), $data0
      - set H80, $data1
    default_action: NoAction
  exact_match ingress_port_mapping_vlan_to_bd_mapping 12:
    p4: { name: SwitchIngress.ingress_port_mapping.vlan_to_bd_mapping, size: 4096, action_profile: SwitchIngress.ingress_port_mapping.bd_action_profile }
    p4_param_order: 
      hdr.vlan_tag$0.vid: { type: exact, size: 12, full_size: 12 }
    row: [ 4, 3 ]
    bus: [ 1, 0 ]
    column:
    - [ 10, 11 ]
    - [ 6, 7 ]
    stash: 
      row: [ 3 ]
      col: [ 7 ]
      unit: [ 0 ]
    ways:
      - [4, 0, 0x0, [3, 7]]
      - [4, 1, 0x0, [3, 6]]
      - [4, 2, 0x0, [4, 11]]
      - [4, 3, 0x0, [4, 10]]
    input_xbar:
      exact group 2: { 0: hdr.vlan_tag$0.vid }
      hash 4:
        0..5: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(0..5)
        6..9: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(8..11)
        11..16: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(0..5)
        17..19: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(8..10)
        10: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(11)
        22..27: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(0..5)
        28..29: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(8..9)
        20..21: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(10..11)
        33..38: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(0..5)
        39: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(8)
        30..32: random(hdr.vlan_tag$0.vid(6..7)) ^ hdr.vlan_tag$0.vid(9..11)
      hash group 4:
        table: [4]
        seed: 0xf4886b638b
    format: { action(0): 0..1, version(0): 112..115, action_addr(0): 6..19, match(0): 54..55, action(1): 2..3, version(1): 116..119, action_addr(1): 20..33, match(1): 62..63, action(2): 4..5, version(2): 120..123, action_addr(2): 34..47, match(2): 70..71 }
    match: [ hdr.vlan_tag$0.vid(6..7) ]
    gateway:
      name: cond-3
      input_xbar:
        exact group 0: { 49: hdr.vlan_tag$0.$valid }
      row: 5
      bus: 1
      unit: 1
      match: { 1: hdr.vlan_tag$0.$valid }
      0b******1: run_table
      miss:  cond-34
      condition: 
        expression: "(hdr.vlan_tag[0].$valid == 1)"
        true:  ingress_port_mapping_vlan_to_bd_mapping
        false:  cond-34
    hit: [  cond-34 ]
    miss:  cond-34
    action: ingress_port_mapping_vlan_to_bd_mapping$action_data.SwitchIngress.ingress_port_mapping.bd_action_profile(action_addr, $DEFAULT)
    instruction: ingress_port_mapping_vlan_to_bd_mapping(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000016
      - next_table: 0
      - {  }
      SwitchIngress.ingress_port_mapping.port_vlan_miss(2, 20):
      - default_action: { allowed: true }
      - handle: 0x20000017
      - next_table: 0
      - {  }
      SwitchIngress.ingress_port_mapping.set_bd_properties(3, 21):
      - p4_param_order: { bd: 16, vrf: 14, bd_label: 16, rid: 16, stp_group: 10, learning_mode: 1, ipv4_unicast_enable: 1, ipv4_multicast_enable: 1, igmp_snooping_enable: 1, ipv6_unicast_enable: 1, ipv6_multicast_enable: 1, mld_snooping_enable: 1, mrpf_group: 16, rmac_group: 10 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000018
      - next_table: 0
      - { rmac_group.0-7: $adf_b0(0..7), $data0: $adf_b1(0..6), ipv4_unicast_enable: $data0(0..0), ipv4_multicast_enable: $data0(1..1), igmp_snooping_enable: $data0(2..2), ipv6_unicast_enable: $data0(3..3), ipv6_multicast_enable: $data0(4..4), mld_snooping_enable: $data0(5..5), learning_mode: $data0(6..6), rid: $adf_h1(0..15), bd: $adf_h2(0..15), mrpf_group: $adf_h3(0..15), bd_label: $adf_h4(0..15), $data1: $adf_h5(0..15), vrf: $data1(0..13), rmac_group.8-9: $data1(14..15) }
      - set ig_md.bd, bd
      - set ig_md.bd_label, bd_label
      - set ig_intr_md_for_tm.rid, rid
      - set ig_md.rmac_group.0-7, rmac_group.0-7
      - set ig_md.multicast.rpf_group, mrpf_group
      - set B51(0..6), $data0
      - set H80, $data1
    default_action: SwitchIngress.ingress_port_mapping.port_vlan_miss
  action ingress_port_mapping_vlan_to_bd_mapping$action_data.SwitchIngress.ingress_port_mapping.bd_action_profile:
    p4: { name: SwitchIngress.ingress_port_mapping.bd_action_profile, size: 5120 }
    row: [ 15, 14, 13 ]
    word: [ 0, 0, 0 ]
    column:
    - 5
    - [ 3, 4, 5 ]
    - 2
    vpns: 
    - [ 0 ]
    - [ 1, 2, 3 ]
    - [ 4 ]
    home_row:
    - 15
    format SwitchIngress.ingress_port_mapping.set_bd_properties: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_h1: 16..31, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h4: 64..79, $adf_h5: 80..95 }
    action_bus: { 2 : $adf_b0, 3 : $adf_b1, 64..65 : $adf_h4, 66..67 : $adf_h5, 74..75 : $adf_h1, 76..77 : $adf_h2, 78..79 : $adf_h3 }
  exact_match ingress_port_mapping_cpu_to_bd_mapping 11:
    p4: { name: SwitchIngress.ingress_port_mapping.cpu_to_bd_mapping, size: 5120, action_profile: SwitchIngress.ingress_port_mapping.bd_action_profile }
    p4_param_order: 
      hdr.cpu.ingress_bd: { type: exact, size: 16, full_size: 16 }
    row: 4
    bus: 0
    column: [ 6, 7, 8, 9 ]
    stash: 
      row: [ 4 ]
      col: [ 9 ]
      unit: [ 0 ]
    ways:
      - [3, 0, 0x0, [4, 9]]
      - [3, 1, 0x0, [4, 8]]
      - [3, 2, 0x0, [4, 7]]
      - [3, 3, 0x0, [4, 6]]
    input_xbar:
      exact group 1: { 64: hdr.cpu.ingress_bd }
      hash 3:
        0..7: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(0..7)
        8..9: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(8..9)
        11..18: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(0..7)
        19: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(8)
        10: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(9)
        22..29: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(0..7)
        20..21: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(8..9)
        33..39: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(0..6)
        30: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(7)
        31..32: random(hdr.cpu.ingress_bd(10..15)) ^ hdr.cpu.ingress_bd(8..9)
      hash group 3:
        table: [3]
        seed: 0x1ca6e037a3
    format: { action(0): 0..1, version(0): 112..115, action_addr(0): 4..17, match(0): 34..39, action(1): 2..3, version(1): 116..119, action_addr(1): 18..31, match(1): 42..47 }
    match: [ hdr.cpu.ingress_bd(10..15) ]
    hit: [  cond-34 ]
    miss:  cond-34
    action: ingress_port_mapping_vlan_to_bd_mapping$action_data.SwitchIngress.ingress_port_mapping.bd_action_profile(action_addr, $DEFAULT)
    instruction: ingress_port_mapping_cpu_to_bd_mapping(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000016
      - next_table: 0
      - {  }
      SwitchIngress.ingress_port_mapping.port_vlan_miss(1, 20):
      - default_action: { allowed: true }
      - handle: 0x20000017
      - next_table: 0
      - {  }
      SwitchIngress.ingress_port_mapping.set_bd_properties(2, 21):
      - p4_param_order: { bd: 16, vrf: 14, bd_label: 16, rid: 16, stp_group: 10, learning_mode: 1, ipv4_unicast_enable: 1, ipv4_multicast_enable: 1, igmp_snooping_enable: 1, ipv6_unicast_enable: 1, ipv6_multicast_enable: 1, mld_snooping_enable: 1, mrpf_group: 16, rmac_group: 10 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000018
      - next_table: 0
      - { rmac_group.0-7: $adf_b0(0..7), $data0: $adf_b1(0..6), ipv4_unicast_enable: $data0(0..0), ipv4_multicast_enable: $data0(1..1), igmp_snooping_enable: $data0(2..2), ipv6_unicast_enable: $data0(3..3), ipv6_multicast_enable: $data0(4..4), mld_snooping_enable: $data0(5..5), learning_mode: $data0(6..6), rid: $adf_h1(0..15), bd: $adf_h2(0..15), mrpf_group: $adf_h3(0..15), bd_label: $adf_h4(0..15), $data1: $adf_h5(0..15), vrf: $data1(0..13), rmac_group.8-9: $data1(14..15) }
      - set ig_md.bd, bd
      - set ig_md.bd_label, bd_label
      - set ig_intr_md_for_tm.rid, rid
      - set ig_md.rmac_group.0-7, rmac_group.0-7
      - set ig_md.multicast.rpf_group, mrpf_group
      - set B51(0..6), $data0
      - set H80, $data1
    default_action: SwitchIngress.ingress_port_mapping.port_vlan_miss
  gateway cond-34 13:
    name: cond-34
    input_xbar:
      exact group 0: { 84: ig_md.bypass(4) }
    row: 5
    bus: 0
    unit: 0
    match: { 4: ig_md.bypass(4) }
    0b***0:  qos_dscp_tc_map
    miss:  acl_lou_l4_src_port
    condition: 
      expression: "(ig_md.bypass & 16 == 0)"
      true:  qos_dscp_tc_map
      false:  acl_lou_l4_src_port
stage 1 ingress:
  exact_match qos_dscp_tc_map 0:
    p4: { name: SwitchIngress.qos.dscp_tc_map, size: 1024 }
    p4_param_order: 
      ig_md.qos.group: { type: exact, size: 5, full_size: 5 }
      ig_md.lkp.ip_tos: { type: exact, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
    row: [ 2, 1 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - 2
    stash: 
      row: [ 2 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [0, 0, 0x0, [2, 2]]
      - [0, 1, 0x0, [2, 3]]
      - [0, 2, 0x0, [2, 4]]
      - [0, 3, 0x0, [1, 2]]
    input_xbar:
      exact group 0: { 0: ig_md.lkp.ip_tos, 9: ig_md.qos.group }
      hash 0:
        0..4: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.lkp.ip_tos(0..4)
        5..9: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.qos.group
        11..15: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.lkp.ip_tos(0..4)
        16..19: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.qos.group(0..3)
        10: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.qos.group(4)
        22..26: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.lkp.ip_tos(0..4)
        27..29: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.qos.group(0..2)
        20..21: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.qos.group(3..4)
        33..37: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.lkp.ip_tos(0..4)
        38..39: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.qos.group(0..1)
        30..32: random(ig_md.lkp.ip_tos(5..7)) ^ ig_md.qos.group(2..4)
      hash group 0:
        table: [0]
        seed: 0xe96f05a91c
    format: { action(0): 0..2, immediate(0): 3..26, version(0): 112..115, match(0): 37..39 }
    match: [ ig_md.lkp.ip_tos(5..7) ]
    gateway:
      name: cond-35
      input_xbar:
        exact group 0: { 26: ig_md.lkp.ip_type, 43: ig_md.qos.trust_mode(0) }
      row: 4
      bus: 1
      unit: 0
      match: { 11: ig_md.qos.trust_mode(0), 2: ig_md.lkp.ip_type }
      0b****0*********:  qos_pcp_tc_map
      0b************00:  qos_pcp_tc_map
      miss: run_table
      condition: 
        expression: "(ig_md.qos.trust_mode & 1 == 1 && ig_md.lkp.ip_type != 0)"
        true:  qos_dscp_tc_map
        false:  qos_pcp_tc_map
    hit: [  acl_lou_l4_src_port ]
    miss:  acl_lou_l4_src_port
    action_bus: { 0 : immediate(0..7), 1 : immediate(8..15), 2 : immediate(16..23), 32..33 : immediate(0..15) }
    instruction: qos_dscp_tc_map(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x2000007f
      - next_table: 0
      - {  }
      set_ingress_tc(2, 1):
      - p4_param_order: { tc: 8 }
      - default_action: { allowed: true }
      - handle: 0x20000080
      - next_table: 0
      - { tc: immediate(0..7) }
      - set ig_md.qos.tc, tc
      set_ingress_color(3, 2):
      - p4_param_order: { color: 2 }
      - default_action: { allowed: true }
      - handle: 0x20000081
      - next_table: 0
      - { color: immediate(0..1) }
      - set ig_md.qos.color, color
      set_ingress_tc_and_color(4, 4):
      - p4_param_order: { tc: 8, color: 2 }
      - default_action: { allowed: true }
      - handle: 0x20000082
      - next_table: 0
      - { color: immediate(0..1), tc: immediate(8..15) }
      - set ig_md.qos.tc, tc
      - set ig_md.qos.color, color
      set_ingress_tc_color_and_meter(5, 6):
      - p4_param_order: { tc: 8, color: 2, index: 10 }
      - default_action: { allowed: true }
      - handle: 0x20000083
      - next_table: 0
      - { index: immediate(0..9), color: immediate(10..11), tc: immediate(16..23) }
      - set ig_md.qos.tc, tc
      - set ig_md.qos.color, color
      - set ig_md.qos.meter_index, index
    default_action: NoAction
  ternary_match qos_pcp_tc_map 1:
    p4: { name: SwitchIngress.qos.pcp_tc_map, size: 1024 }
    p4_param_order: 
      ig_md.qos.group: { type: ternary, size: 5, full_size: 5 }
      ig_md.lkp.pcp: { type: exact, size: 3, full_size: 3, key_name: "lkp.pcp" }
    row: [ 5, 6 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.pcp, 9: ig_md.qos.group }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x5 }
    gateway:
      name: cond-36
      input_xbar:
        exact group 0: { 17: hdr.vlan_tag$0.$valid, 44: ig_md.qos.trust_mode(1) }
      row: 2
      bus: 1
      unit: 1
      match: { 4: ig_md.qos.trust_mode(1), 9: hdr.vlan_tag$0.$valid }
      0b******1****1: run_table
      miss:  acl_lou_l4_src_port
      condition: 
        expression: "(ig_md.qos.trust_mode & 2 == 2 && hdr.vlan_tag[0].$valid == 1)"
        true:  qos_pcp_tc_map
        false:  acl_lou_l4_src_port
    hit: [  acl_lou_l4_src_port ]
    miss:  acl_lou_l4_src_port
    indirect: qos_pcp_tc_map$tind
  ternary_indirect qos_pcp_tc_map$tind:
    row: 1
    bus: 0
    column: 3
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.pcp, 9: ig_md.qos.group }
    format: { action: 0..2, immediate: 3..26 }
    action_bus: { 4 : immediate(0..7), 5 : immediate(8..15), 6 : immediate(16..23), 36..37 : immediate(0..15) }
    instruction: qos_pcp_tc_map$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x2000007a
      - next_table: 0
      - {  }
      set_ingress_tc(2, 3):
      - p4_param_order: { tc: 8 }
      - default_action: { allowed: true }
      - handle: 0x2000007b
      - next_table: 0
      - { tc: immediate(0..7) }
      - set ig_md.qos.tc, tc
      set_ingress_color(3, 8):
      - p4_param_order: { color: 2 }
      - default_action: { allowed: true }
      - handle: 0x2000007c
      - next_table: 0
      - { color: immediate(0..1) }
      - set ig_md.qos.color, color
      set_ingress_tc_and_color(4, 10):
      - p4_param_order: { tc: 8, color: 2 }
      - default_action: { allowed: true }
      - handle: 0x2000007d
      - next_table: 0
      - { color: immediate(0..1), tc: immediate(8..15) }
      - set ig_md.qos.tc, tc
      - set ig_md.qos.color, color
      set_ingress_tc_color_and_meter(5, 12):
      - p4_param_order: { tc: 8, color: 2, index: 10 }
      - default_action: { allowed: true }
      - handle: 0x2000007e
      - next_table: 0
      - { index: immediate(0..9), color: immediate(10..11), tc: immediate(16..23) }
      - set ig_md.qos.tc, tc
      - set ig_md.qos.color, color
      - set ig_md.qos.meter_index, index
    default_action: NoAction
  ternary_match acl_lou_l4_src_port 2:
    p4: { name: SwitchIngress.acl.lou.l4_src_port, size: 8 }
    p4_param_order: 
      ig_md.lkp.l4_src_port: { type: range, size: 16, full_size: 16, key_name: "src_port" }
    row: 4
    bus: 0
    column: 0
    input_xbar:
      ternary group 1: { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.0-7, 16: ig_md.lkp.l4_src_port.8-15, 24: ig_md.lkp.l4_src_port.8-15 }
    match:
    - { group: 1, byte_config: 3, dirtcam: 0xee }
    hit: [  cond-9 ]
    miss:  cond-9
    indirect: acl_lou_l4_src_port$tind
  ternary_indirect acl_lou_l4_src_port$tind:
    row: 0
    bus: 1
    column: 3
    input_xbar:
      ternary group 1: { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.0-7, 16: ig_md.lkp.l4_src_port.8-15, 24: ig_md.lkp.l4_src_port.8-15 }
    format: { action: 0..0, immediate: 1..8 }
    action_bus: { 8 : immediate(0..7) }
    instruction: acl_lou_l4_src_port$tind(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x20000025
      - next_table: 0
      - {  }
      SwitchIngress.acl.lou.set_src_port_label(1, 5):
      - p4_param_order: { label: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000026
      - next_table: 0
      - { label: immediate(0..7) }
      - set ig_md.l4_port_label.0-7, label
    default_action: NoAction
  gateway cond-9 4:
    name: cond-9
    input_xbar:
      exact group 0: { 50: ig_md.bypass(2) }
    row: 1
    bus: 1
    unit: 1
    match: { 2: ig_md.bypass(2) }
    0b*****0:  acl_mac_acl_acl
    miss:  smac_smac
    condition: 
      expression: "(ig_md.bypass & 4 == 0)"
      true:  acl_mac_acl_acl
      false:  smac_smac
  ternary_match acl_mac_acl_acl 5:
    p4: { name: SwitchIngress.acl.mac_acl.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.mac_src_addr: { type: ternary, size: 48, full_size: 48, key_name: "lkp.mac_src_addr" }
      ig_md.lkp.mac_dst_addr: { type: ternary, size: 48, full_size: 48, key_name: "lkp.mac_dst_addr" }
      ig_md.lkp.mac_type: { type: ternary, size: 16, full_size: 16, key_name: "lkp.mac_type" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.bd_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3 ]
    bus: [ 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 0: { 16: ig_md.lkp.mac_dst_addr.16-47(16..31), 32: ig_md.lkp.mac_dst_addr.16-47(0..7) }
      ternary group 2: { 0: ig_md.lkp.mac_src_addr.16-47(24..31), 8: ig_md.lkp.mac_src_addr.16-47(0..23), 32: ig_md.lkp.mac_type(8..15) }
      ternary group 3: { 0: ig_md.lkp.mac_src_addr.0-15(8..15), 8: ig_md.lkp.mac_type(0..7), 16: ig_md.lkp.mac_dst_addr.0-15(8..15), 24: ig_md.lkp.mac_src_addr.0-15(0..7), 32: ig_md.port_lag_label(8..15) }
      ternary group 4: { 0: ig_md.lkp.mac_dst_addr.0-15(0..7), 8: ig_md.bd_label(8..15), 16: ig_md.port_lag_label(0..7), 32: ig_md.bd_label(0..7) }
      byte group 0: { 0: ig_md.lkp.mac_dst_addr.16-47(8..15) }
    match:
    - { group: 0, byte_group: 0, byte_config: 0, dirtcam: 0x550 }
    - { group: 2, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 3, byte_config: 3, dirtcam: 0x155 }
    - { group: 4, dirtcam: 0x115 }
    gateway:
      name: cond-10
      input_xbar:
        exact group 0: { 26: ig_md.lkp.ip_type }
      row: 0
      bus: 1
      unit: 1
      match: { 2: ig_md.lkp.ip_type }
      0b****00: run_table
      miss:  smac_smac
      condition: 
        expression: "(ig_md.lkp.ip_type == 0)"
        true:  acl_mac_acl_acl
        false:  smac_smac
    hit: [  smac_smac ]
    miss:  smac_smac
    indirect: acl_mac_acl_acl$tind
  ternary_indirect acl_mac_acl_acl$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 16: ig_md.lkp.mac_dst_addr.16-47(16..31), 32: ig_md.lkp.mac_dst_addr.16-47(0..7) }
      ternary group 2: { 0: ig_md.lkp.mac_src_addr.16-47(24..31), 8: ig_md.lkp.mac_src_addr.16-47(0..23), 32: ig_md.lkp.mac_type(8..15) }
      ternary group 3: { 0: ig_md.lkp.mac_src_addr.0-15(8..15), 8: ig_md.lkp.mac_type(0..7), 16: ig_md.lkp.mac_dst_addr.0-15(8..15), 24: ig_md.lkp.mac_src_addr.0-15(0..7), 32: ig_md.port_lag_label(8..15) }
      ternary group 4: { 0: ig_md.lkp.mac_dst_addr.0-15(0..7), 8: ig_md.bd_label(8..15), 16: ig_md.port_lag_label(0..7), 32: ig_md.bd_label(0..7) }
      byte group 0: { 0: ig_md.lkp.mac_dst_addr.16-47(8..15) }
    format: { action: 0..2, immediate: 3..15 }
    action_bus: { 9 : immediate(8..12), 44..45 : immediate(0..12) }
    instruction: acl_mac_acl_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000029
      - next_table: 0
      - {  }
      ingress_acl_deny(2, 7):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000002a
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 1 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
      ingress_acl_permit(3, 9):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000002b
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 0 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
      ingress_acl_redirect(4, 11):
      - p4_param_order: { nexthop_index: 16, stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000002c
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 0 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
    default_action: NoAction
  exact_match smac_smac 6:
    p4: { name: SwitchIngress.smac.smac, size: 16384 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16 }
      ig_md.lkp.mac_src_addr: { type: exact, size: 48, full_size: 48, key_name: "src_addr" }
    row: [ 7, 6, 5 ]
    bus: [ 0, 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - [ 2, 3, 4 ]
    - [ 2, 3 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [2, 0, 0x1, [7, 2], [7, 3]]
      - [2, 1, 0x2, [7, 4], [6, 2]]
      - [2, 2, 0x4, [6, 3], [6, 4]]
      - [2, 3, 0x8, [5, 2], [5, 3]]
    input_xbar:
      exact group 1: { 0: ig_md.lkp.mac_src_addr.16-47, 32: ig_md.lkp.mac_src_addr.0-15, 48: ig_md.bd }
      hash 2:
        0..7: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(0..7)
        8..9: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(8..9)
        40: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(10)
        11..18: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(0..7)
        19: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(8)
        10: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(10)
        41: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(9)
        22..29: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(0..7)
        20..21: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(9..10)
        42: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(8)
        33..39: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(0..6)
        30..32: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(8..10)
        43: random(ig_md.lkp.mac_src_addr.16-47, ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd) ^ ig_md.lkp.mac_src_addr.0-15(7)
      hash group 2:
        table: [2]
        seed: 0xc76511d2bf3
    format: { action(0): 0..0, version(0): 112..115, match(0): [83..87, 32..79 ], action(1): 1..1, version(1): 116..119, match(1): [3..7, 88..111, 8..31 ] }
    match: [ ig_md.lkp.mac_src_addr.0-15(11..15), ig_md.bd(0..7), ig_md.bd(8..15), ig_md.lkp.mac_src_addr.16-47(0..7), ig_md.lkp.mac_src_addr.16-47(8..15), ig_md.lkp.mac_src_addr.16-47(16..23), ig_md.lkp.mac_src_addr.16-47(24..31) ]
    gateway:
      name: cond-7
      input_xbar:
        exact group 1: { 72: ig_md.bypass(8) }
      row: 0
      bus: 0
      unit: 0
      match: { 0: ig_md.bypass(8) }
      0b*******0: run_table
      miss:  ingress_port_mapping_port_mirror_port_mirror
      condition: 
        expression: "(ig_md.bypass & 256 == 0)"
        true:  smac_smac
        false:  ingress_port_mapping_port_mirror_port_mirror
    hit: [  ingress_port_mapping_port_mirror_port_mirror ]
    miss:  ingress_port_mapping_port_mirror_port_mirror
    action: smac_smac$action_data($DIRECT, $DEFAULT)
    instruction: smac_smac(action, $DEFAULT)
    actions:
      SwitchIngress.smac.smac_miss(-1, 13):
      - default_only_action: { allowed: true }
      - handle: 0x2000001f
      - next_table: 0
      - {  }
      - set smac_src_miss, 1
      SwitchIngress.smac.smac_hit(1, 14):
      - p4_param_order: { ifindex: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000020
      - next_table: 0
      - { ifindex: $adf_h0(0..15) }
      - xor smac_src_move, ig_md.ifindex, ifindex
    default_only_action: SwitchIngress.smac.smac_miss
    idletime:
      row: [ 0, 1 ]
      bus: [ 0, 0 ]
      column:
      - [ 0, 1, 2, 3, 4, 5 ]
      - [ 0, 1 ]
      precision: 3
      sweep_interval: 7
      notification: two_way
      per_flow_enable: true
  action smac_smac$action_data:
    p4: { name: SwitchIngress.smac.smac$action }
    row: [ 14, 12 ]
    word: [ 0, 0 ]
    column:
    - 5
    - 5
    vpns: 
    - [ 0 ]
    - [ 1 ]
    home_row:
    - 14
    format SwitchIngress.smac.smac_hit: { $adf_h0: 0..15 }
    action_bus: { 48..49 : $adf_h0 }
  exact_match ingress_port_mapping_port_mirror_port_mirror 7:
    p4: { name: SwitchIngress.ingress_port_mapping.port_mirror.port_mirror, size: 4096 }
    p4_param_order: 
      ig_md.port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 3
    bus: 1
    column: 3
    stash: 
      row: [ 3 ]
      col: [ 3 ]
      unit: [ 0 ]
    ways:
      - [3, 0, 0x0, [3, 3]]
    input_xbar:
      exact group 1: { 64: ig_md.port(0..7), 88: ig_md.port(8) }
      hash 3:
        0..7: ig_md.port(0..7)
        8: ig_md.port(8)
      hash group 3:
        table: [3]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..10, version(0): 112..115 }
    hit: [  cond-5 ]
    miss:  cond-5
    action_bus: { 52..53 : immediate(0..9) }
    instruction: ingress_port_mapping_port_mirror_port_mirror(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x2000001c
      - next_table: 0
      - {  }
      SwitchIngress.ingress_port_mapping.port_mirror.set_mirror_id(1, 15):
      - p4_param_order: { session_id: 10 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000001d
      - next_table: 0
      - { session_id: immediate(0..9) }
      - set ig_md.mirror.type, 1
      - set ig_md.mirror.src, 1
      - set ig_md.mirror.session_id, session_id
    default_action: NoAction
  gateway cond-5 8:
    name: cond-5
    input_xbar:
      exact group 0: { 55: ig_md.bypass(7) }
    row: 2
    bus: 0
    unit: 0
    match: { 7: ig_md.bypass(7) }
    0x0:  tbl_act_1
    miss:  tbl_act_0
    condition: 
      expression: "(ig_md.bypass & 128 == 0)"
      true:  tbl_act_1
      false:  tbl_act_0
  hash_action tbl_act_1 9:
    p4: { name: tbl_act_1 }
    row: 2
    bus: 1
    hash_dist:
      1: { hash: 1, mask: 0x7fffff, shift: 0, expand: 7 }
    input_xbar:
      exact group 0: { 88: ig_md.bd(8..11), 96: ig_md.port(0..6), 112: ig_md.bd(0..7) }
      hash 1:
        16..22: stripe(ig_md.port(0..6))
        31..31: stripe(ig_md.bd(8))
        39..41: stripe(ig_md.bd(9..11))
        23..30: stripe(ig_md.bd(0..7))
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: cond-6
      input_xbar:
        exact group 1: { 60: ig_md.bd(12..15) }
      row: 5
      bus: 1
      unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 4: ig_md.bd(12..15) }
      0x0:  tbl_act_0
      miss: run_table
      condition: 
        expression: "(ig_md.bd[15:12][15:12] == 0)"
        true:  tbl_act_0
        false:  tbl_act_0
    next:  tbl_act_0
    action_bus: { 56..57 : tbl_act_1$salu.SwitchIngress.stp.stp(0..15) }
    stateful: tbl_act_1$salu.SwitchIngress.stp.stp(hash_dist 1, meter_pfe, meter_type)
    instruction: tbl_act_1(action, $DEFAULT)
    actions:
      act_1(1, 16):
      - default_action: { allowed: true }
      - handle: 0x2000001e
      - next_table: 0
      - set ig_md.stp.state_(0..0), tbl_act_1$salu.SwitchIngress.stp.stp
      - tbl_act_1$salu.SwitchIngress.stp.stp(1, $hash_dist)
    default_action: act_1
  stateful tbl_act_1$salu.SwitchIngress.stp.stp:
    p4: { name: SwitchIngress.stp.stp, size: 524288 }
    row: 11
    column: [ 0, 1, 2, 3, 4 ]
    maprams: [ 0, 1, 2, 3, 4 ]
    format: { lo: 1 }
    actions:
      stp_stp_check:
      - read_bit
      - output alu_lo
      set_bit_alu$0:
      - set_bit
      clr_bit_alu$0:
      - clr_bit
  hash_action tbl_act_0 10:
    p4: { name: tbl_act_0 }
    row: 1
    bus: 1
    hash_dist:
      3: { hash: 4, mask: 0x7fffff, shift: 0, expand: 0 }
    input_xbar:
      exact group 2: { 0: ig_md.port(0..6), 8: hdr.vlan_tag$0.vid(8..11), 16: hdr.vlan_tag$0.vid(0..7) }
      hash 4:
        8..11: stripe(hdr.vlan_tag$0.vid(8..11))
        0..7: stripe(hdr.vlan_tag$0.vid(0..7))
        12..15: stripe(ig_md.port(0..3))
        32..34: stripe(ig_md.port(4..6))
      hash group 4:
        table: [4]
        seed: 0x0
    gateway:
      name: cond-4
      input_xbar:
        exact group 1: { 87: ig_md.flags.port_vlan_miss, 96: hdr.vlan_tag$1.$valid, 97: hdr.vlan_tag$0.$valid }
      row: 3
      bus: 1
      unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 1: hdr.vlan_tag$0.$valid, 8: hdr.vlan_tag$1.$valid, 23: ig_md.flags.port_vlan_miss }
      0b0**************0******1:  bd_stats_bd_stats
      miss: run_table
      condition: 
        expression: "(hdr.vlan_tag[0].$valid == 1 && !(hdr.vlan_tag[1].$valid == 1) && (bit<1>)ig_md.flags.port_vlan_miss == 0)"
        true:  bd_stats_bd_stats
        false:  bd_stats_bd_stats
    next:  bd_stats_bd_stats
    action_bus: { 10 : tbl_act_0$salu.SwitchIngress.ingress_port_mapping.vlan_membership(0..7) }
    stateful: tbl_act_0$salu.SwitchIngress.ingress_port_mapping.vlan_membership(hash_dist 3, meter_pfe, meter_type)
    instruction: tbl_act_0(action, $DEFAULT)
    actions:
      act_0(1, 17):
      - default_action: { allowed: true }
      - handle: 0x2000001b
      - next_table: 0
      - set ig_md.flags.port_vlan_miss, tbl_act_0$salu.SwitchIngress.ingress_port_mapping.vlan_membership
      - tbl_act_0$salu.SwitchIngress.ingress_port_mapping.vlan_membership(1, $hash_dist)
    default_action: act_0
  stateful tbl_act_0$salu.SwitchIngress.ingress_port_mapping.vlan_membership:
    p4: { name: SwitchIngress.ingress_port_mapping.vlan_membership, size: 524288 }
    row: 15
    column: [ 0, 1, 2, 3, 4 ]
    maprams: [ 0, 1, 2, 3, 4 ]
    format: { lo: 1 }
    actions:
      ingress_port_mapping_check_vlan_membership:
      - read_bitc
      - output alu_lo
      set_bit_alu$0:
      - set_bit
      clr_bit_alu$0:
      - clr_bit
  exact_match bd_stats_bd_stats 11:
    p4: { name: SwitchIngress.bd_stats.bd_stats, size: 15360 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
      ig_md.lkp.pkt_type: { type: exact, size: 2, full_size: 2, key_name: "pkt_type" }
    row: [ 4, 3 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - 2
    stash: 
      row: [ 4 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [5, 0, 0x0, [4, 2]]
      - [5, 1, 0x0, [4, 3]]
      - [5, 2, 0x0, [4, 4]]
      - [5, 3, 0x0, [3, 2]]
    input_xbar:
      exact group 2: { 64: ig_md.bd, 81: ig_md.lkp.pkt_type }
      hash 5:
        0..7: random(ig_md.bd(8..15)) ^ ig_md.bd(0..7)
        8..9: random(ig_md.bd(8..15)) ^ ig_md.lkp.pkt_type
        11..18: random(ig_md.bd(8..15)) ^ ig_md.bd(0..7)
        19: random(ig_md.bd(8..15)) ^ ig_md.lkp.pkt_type(0)
        10: random(ig_md.bd(8..15)) ^ ig_md.lkp.pkt_type(1)
        22..29: random(ig_md.bd(8..15)) ^ ig_md.bd(0..7)
        20..21: random(ig_md.bd(8..15)) ^ ig_md.lkp.pkt_type
        33..39: random(ig_md.bd(8..15)) ^ ig_md.bd(0..6)
        30: random(ig_md.bd(8..15)) ^ ig_md.bd(7)
        31..32: random(ig_md.bd(8..15)) ^ ig_md.lkp.pkt_type
      hash group 5:
        table: [5]
        seed: 0x7f3983a3ab
    format: { version(0): 112..115, match(0): 32..39, version(1): 116..119, match(1): 40..47, version(2): 120..123, match(2): 48..55, version(3): 124..127, match(3): 56..63 }
    match: [ ig_md.bd(8..15) ]
    hit: [  tbl_act_15 ]
    miss:  tbl_act_15
    stats: bd_stats_bd_stats$stats.SwitchIngress.bd_stats.stats($DIRECT, $DEFAULT)
    instruction: bd_stats_bd_stats($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.bd_stats.count(0, 0):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000023
      - next_table: 0
      - bd_stats_bd_stats$stats.SwitchIngress.bd_stats.stats($DIRECT)
      NoAction(-1, 18):
      - default_only_action: { allowed: true }
      - handle: 0x20000024
      - next_table: 0
    default_only_action: NoAction
  counter bd_stats_bd_stats$stats.SwitchIngress.bd_stats.stats:
    p4: { name: SwitchIngress.bd_stats.stats }
    row: [ 13, 11, 9 ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - 5
    - [ 0, 1 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - 5
    - [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 338078240, interval: 21129984 }
    - { threshold: 338078240, interval: 21129984 }
    - { threshold: 338078240, interval: 21129984 }
  ternary_match tbl_act_15 13:
    p4: { name: tbl_act_15 }
    hit: [  acl_lou_l4_dst_port ]
    miss:  acl_lou_l4_dst_port
    indirect: tbl_act_15$tind
  ternary_indirect tbl_act_15$tind:
    row: 2
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_act_15$tind(action, $DEFAULT)
    actions:
      act_15(0, 19):
      - default_action: { allowed: true }
      - handle: 0x200000a0
      - next_table: 0
      - set ig_md.dtel.report_type, 0
      - set ig_md.dtel.session_id, 0
    default_action: act_15
stage 2 ingress:
  ternary_match acl_lou_l4_dst_port 0:
    p4: { name: SwitchIngress.acl.lou.l4_dst_port, size: 8 }
    p4_param_order: 
      ig_md.lkp.l4_dst_port: { type: range, size: 16, full_size: 16, key_name: "dst_port" }
    row: 0
    bus: 0
    column: 0
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.l4_dst_port, 16: ig_md.lkp.l4_dst_port }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0xfa }
    hit: [  cond-17 ]
    miss:  cond-17
    indirect: acl_lou_l4_dst_port$tind
  ternary_indirect acl_lou_l4_dst_port$tind:
    row: 0
    bus: 0
    column: 3
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.l4_dst_port, 16: ig_md.lkp.l4_dst_port }
    format: { action: 0..0, immediate: 1..8 }
    action_bus: { 0 : immediate(0..7) }
    instruction: acl_lou_l4_dst_port$tind(action, $DEFAULT)
    actions:
      NoAction(0, 1):
      - default_action: { allowed: true }
      - handle: 0x20000027
      - next_table: 0
      - {  }
      - set ig_md.flags.racl_deny, 0
      - set B39(0..1), 0
      SwitchIngress.acl.lou.set_dst_port_label(1, 2):
      - p4_param_order: { label: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000028
      - next_table: 0
      - { label: immediate(0..7) }
      - set ig_md.l4_port_label.8-15, label
      - set ig_md.flags.racl_deny, 0
      - set B39(0..1), 0
    default_action: NoAction
  gateway cond-17 1:
    name: cond-17
    input_xbar:
      exact group 0: { 1: ig_md.lkp.pkt_type }
    row: 5
    bus: 1
    unit: 0
    match: { 1: ig_md.lkp.pkt_type }
    0b*****00:  unicast_rmac
    miss:  cond-22
    condition: 
      expression: "(ig_md.lkp.pkt_type == 0)"
      true:  unicast_rmac
      false:  cond-22
  exact_match unicast_rmac 11:
    p4: { name: SwitchIngress.unicast.rmac, size: 1024 }
    p4_param_order: 
      ig_md.rmac_group: { type: exact, size: 10, full_size: 10 }
      ig_md.lkp.mac_dst_addr: { type: exact, size: 48, full_size: 48, key_name: "lkp.mac_dst_addr" }
    row: 2
    bus: 0
    column: [ 2, 3, 4, 6 ]
    stash: 
      row: [ 2 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [6, 0, 0x0, [2, 2]]
      - [6, 1, 0x0, [2, 6]]
      - [6, 2, 0x0, [2, 4]]
      - [6, 3, 0x0, [2, 3]]
    input_xbar:
      exact group 7: { 0: ig_md.lkp.mac_dst_addr.16-47, 32: ig_md.lkp.mac_dst_addr.0-15, 48: ig_md.rmac_group.0-7, 62: ig_md.rmac_group.8-9 }
      hash 14:
        0..7: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.0-7
        8..9: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.8-9
        11..18: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.0-7
        19: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.8-9(0)
        10: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.8-9(1)
        22..29: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.0-7
        20..21: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.8-9
        33..39: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.0-7(0..6)
        30: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.0-7(7)
        31..32: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.rmac_group.8-9
      hash group 6:
        table: [14]
        seed: 0xc7d4fff2af
    format: { version(0): 112..115, match(0): 32..79 }
    match: [ ig_md.lkp.mac_dst_addr.0-15(0..7), ig_md.lkp.mac_dst_addr.0-15(8..15), ig_md.lkp.mac_dst_addr.16-47(0..7), ig_md.lkp.mac_dst_addr.16-47(8..15), ig_md.lkp.mac_dst_addr.16-47(16..23), ig_md.lkp.mac_dst_addr.16-47(24..31) ]
    hit: [  cond-18 ]
    miss:  dmac_dmac
    instruction: unicast_rmac($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.unicast.rmac_hit(0, 14):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000003b
      - next_table_miss:  dmac_dmac
      - next_table: 0
      - set ig_md.flags.rmac_hit, 1
      SwitchIngress.unicast.rmac_miss(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000003c
      - next_table_miss:  dmac_dmac
    default_only_action: SwitchIngress.unicast.rmac_miss
  gateway cond-18 12:
    name: cond-18
    input_xbar:
      exact group 3: { 97: ig_md.bypass(1) }
    row: 0
    bus: 1
    unit: 0
    match: { 1: ig_md.bypass(1) }
    0b******0:  cond-19
    miss:  qos_policer_meter_index
    condition: 
      expression: "(ig_md.bypass & 2 == 0)"
      true:  cond-19
      false:  qos_policer_meter_index
  gateway cond-22 2:
    name: cond-22
    input_xbar:
      exact group 0: { 1: ig_md.lkp.pkt_type, 10: ig_md.lkp.ip_type }
    row: 3
    bus: 1
    unit: 0
    match: { 2: ig_md.lkp.ip_type, 9: ig_md.lkp.pkt_type }
    0b************00:  dmac_dmac
    0b*****01*******:  cond-23
    miss:  dmac_dmac
    condition: 
      expression: "(ig_md.lkp.pkt_type == 1 && ig_md.lkp.ip_type != 0)"
      true:  cond-23
      false:  dmac_dmac
  gateway cond-23 3:
    name: cond-23
    input_xbar:
      exact group 0: { 10: ig_md.lkp.ip_type, 17: ig_md.ipv4.multicast_enable }
    row: 4
    bus: 1
    unit: 0
    match: { 2: ig_md.lkp.ip_type, 9: ig_md.ipv4.multicast_enable }
    0b******1*****01:  multicast_ipv4_multicast_route_s_g
    miss:  cond-24
    condition: 
      expression: "(ig_md.lkp.ip_type == 1 && ig_md.ipv4.multicast_enable)"
      true:  multicast_ipv4_multicast_route_s_g
      false:  cond-24
  exact_match multicast_ipv4_multicast_route_s_g 4:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_route.s_g, size: 4096 }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_src_addr: { type: exact, size: 32, full_size: 128, key_name: "src_addr" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 32, full_size: 128, key_name: "grp_addr" }
    row: [ 4, 2, 1 ]
    search_bus: [ 1, 1, 0 ]
    result_bus: [ 0, 1, 0 ]
    column:
    - 6
    - [ 7, 8 ]
    - 2
    stash: 
      row: [ 1 ]
      col: [ 2 ]
      unit: [ 1 ]
    ways:
      - [0, 0, 0x0, [1, 2]]
      - [0, 1, 0x0, [2, 8]]
      - [0, 2, 0x0, [2, 7]]
      - [0, 3, 0x0, [4, 6]]
    input_xbar:
      exact group 0: { 24: ig_md.lkp.ip_dst_addr.0-31(24..31), 32: ig_md.lkp.ip_src_addr.0-23(0..7), 45: ig_md.lkp.ip_src_addr.24-31, 56: ig_md.vrf(8..13), 64: ig_md.lkp.ip_dst_addr.0-31(0..7), 72: ig_md.lkp.ip_src_addr.0-23(8..23), 96: ig_md.vrf(0..7), 104: ig_md.lkp.ip_dst_addr.0-31(8..23) }
      hash 0:
        0..2: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        3..7: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        8..9: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.vrf(8..9)
        11..13: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        14..18: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        19: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.vrf(8)
        10: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.vrf(9)
        22..24: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        25..29: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        20..21: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.vrf(8..9)
        33..35: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        36..39: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(3..6)
        30: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.lkp.ip_src_addr.24-31(7)
        31..32: random(ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.vrf(10..13)) ^ ig_md.vrf(8..9)
      hash 1:
        0..9: random(ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        10..19: random(ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        20..29: random(ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        30..39: random(ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
      hash group 0:
        table: [0, 1]
        seed: 0xe74ac3b8d8
    format: { immediate(0): 0..31, version(0): 112..115, match(0): [32..39, 98..101, 40..95 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(10..13), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.0-23(8..15), ig_md.lkp.ip_src_addr.0-23(16..23), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  cond-25 ]
    miss:  multicast_ipv4_multicast_route_star_g
    action_bus: { 16 : immediate(0..7), 17 : immediate(8..15), 66..67 : immediate(16..31) }
    stats: multicast_ipv4_multicast_route_s_g$stats.SwitchIngress.multicast.ipv4_multicast_route.s_g_stats($DIRECT, $DEFAULT)
    action: multicast_ipv4_multicast_route_s_g$action_data($DIRECT, $DEFAULT)
    instruction: multicast_ipv4_multicast_route_s_g($DEFAULT, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000004d
      - next_table_miss:  multicast_ipv4_multicast_route_star_g
      - {  }
      SwitchIngress.multicast.ipv4_multicast_route.s_g_hit(0, 3):
      - p4_param_order: { mgid: 16, rpf_group: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000004e
      - next_table_miss:  multicast_ipv4_multicast_route_star_g
      - next_table: 0
      - { rpf_group: $adf_h0(0..15), $data0: immediate(4..7), $constant1: $data0(0..1), $constant1: 1, $constant0: $data0(3..3), $constant0: 1, $mask0: immediate(12..15), $constant2: $mask0(0..1), $constant2: 3, $constant3: $mask0(3..3), $constant3: 1, mgid: immediate(16..31) }
      - set ig_md.multicast.id, mgid
      - xor multicast_rpf_check, rpf_group, ig_md.multicast.rpf_group
      - bitmasked-set B54, $data0, B54
      - multicast_ipv4_multicast_route_s_g$stats.SwitchIngress.multicast.ipv4_multicast_route.s_g_stats($DIRECT)
    default_only_action: NoAction
  counter multicast_ipv4_multicast_route_s_g$stats.SwitchIngress.multicast.ipv4_multicast_route.s_g_stats:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_route.s_g_stats }
    row: 1
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
  action multicast_ipv4_multicast_route_s_g$action_data:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_route.s_g$action }
    row: 12
    column: 5
    vpns: [ 0 ]
    home_row:
    - 12
    format SwitchIngress.multicast.ipv4_multicast_route.s_g_hit: { $adf_h0: 0..15 }
    action_bus: { 32..33 : $adf_h0 }
  exact_match multicast_ipv4_multicast_route_star_g 5:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_route.star_g, size: 2048 }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 32, full_size: 128, key_name: "grp_addr" }
    row: 1
    bus: 1
    column: [ 3, 4, 6, 7 ]
    stash: 
      row: [ 1 ]
      col: [ 7 ]
      unit: [ 0 ]
    ways:
      - [1, 0, 0x0, [1, 7]]
      - [1, 1, 0x0, [1, 6]]
      - [1, 2, 0x0, [1, 4]]
      - [1, 3, 0x0, [1, 3]]
    input_xbar:
      exact group 1: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.vrf }
      hash 2:
        0..3: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        4..9: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(8..13)
        11..14: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        15..19: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(8..12)
        10: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(13)
        22..25: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        26..29: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(8..11)
        20..21: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(12..13)
        33..36: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        37..39: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(8..10)
        30..32: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.vrf(4..7)) ^ ig_md.vrf(11..13)
      hash group 1:
        table: [2]
        seed: 0x3b078a16c7
    format: { action(0): 0..0, immediate(0): 1..32, version(0): 112..115, match(0): 36..71 }
    match: [ ig_md.vrf(4..7), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  cond-25 ]
    miss:  cond-25
    action_bus: { 20 : immediate(0..7), 21 : immediate(8..15), 70..71 : immediate(16..31) }
    stats: multicast_ipv4_multicast_route_star_g$stats.SwitchIngress.multicast.ipv4_multicast_route.star_g_stats($DIRECT, $DEFAULT)
    action: multicast_ipv4_multicast_route_star_g$action_data($DIRECT, $DEFAULT)
    instruction: multicast_ipv4_multicast_route_star_g(action, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000004f
      - next_table: 0
      - {  }
      SwitchIngress.multicast.ipv4_multicast_route.star_g_hit_sm(0, 4):
      - p4_param_order: { mgid: 16, rpf_group: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000050
      - next_table: 0
      - { rpf_group: $adf_h0(0..15), $data0: immediate(4..7), $constant1: $data0(0..1), $constant1: 1, $constant0: $data0(3..3), $constant0: 1, $mask0: immediate(12..15), $constant2: $mask0(0..1), $constant2: 3, $constant3: $mask0(3..3), $constant3: 1, mgid: immediate(16..31) }
      - set ig_md.multicast.id, mgid
      - xor multicast_rpf_check, rpf_group, ig_md.multicast.rpf_group
      - bitmasked-set B54, $data0, B54
      - multicast_ipv4_multicast_route_star_g$stats.SwitchIngress.multicast.ipv4_multicast_route.star_g_stats($DIRECT)
      SwitchIngress.multicast.ipv4_multicast_route.star_g_hit_bidir(1, 6):
      - p4_param_order: { mgid: 16, rpf_group: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000051
      - next_table: 0
      - { rpf_group: $adf_h0(0..15), $data0: immediate(4..7), $constant1: $data0(0..1), $constant1: 2, $constant0: $data0(3..3), $constant0: 1, $mask0: immediate(12..15), $constant2: $mask0(0..1), $constant2: 3, $constant3: $mask0(3..3), $constant3: 1, mgid: immediate(16..31) }
      - set ig_md.multicast.id, mgid
      - and multicast_rpf_check, rpf_group, ig_md.multicast.rpf_group
      - bitmasked-set B54, $data0, B54
      - multicast_ipv4_multicast_route_star_g$stats.SwitchIngress.multicast.ipv4_multicast_route.star_g_stats($DIRECT)
    default_only_action: NoAction
  counter multicast_ipv4_multicast_route_star_g$stats.SwitchIngress.multicast.ipv4_multicast_route.star_g_stats:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_route.star_g_stats }
    row: 5
    column: [ 3, 4 ]
    maprams: [ 3, 4 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
  action multicast_ipv4_multicast_route_star_g$action_data:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_route.star_g$action }
    row: 13
    column: 4
    vpns: [ 0 ]
    home_row:
    - 13
    format SwitchIngress.multicast.ipv4_multicast_route.star_g_hit_sm: { $adf_h0: 0..15 }
    format SwitchIngress.multicast.ipv4_multicast_route.star_g_hit_bidir: { $adf_h0: 0..15 }
    action_bus: { 36..37 : $adf_h0 }
  gateway cond-24 6:
    name: cond-24
    input_xbar:
      exact group 0: { 10: ig_md.lkp.ip_type, 20: ig_md.ipv6.multicast_enable }
    row: 2
    bus: 1
    unit: 0
    match: { 2: ig_md.lkp.ip_type, 12: ig_md.ipv6.multicast_enable }
    0b***1********10:  multicast_ipv6_multicast_route_s_g
    miss:  cond-25
    condition: 
      expression: "(ig_md.lkp.ip_type == 2 && ig_md.ipv6.multicast_enable)"
      true:  multicast_ipv6_multicast_route_s_g
      false:  cond-25
  exact_match multicast_ipv6_multicast_route_s_g 7:
    p4: { name: SwitchIngress.multicast.ipv6_multicast_route.s_g, size: 512 }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_src_addr: { type: exact, size: 128, full_size: 128, key_name: "src_addr" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 128, full_size: 128, key_name: "grp_addr" }
    row: [ 5, 6, 7 ]
    bus: [ 0, 0, 0 ]
    column:
    - [ 2, 3, 4, 6 ]
    - [ 2, 3, 4, 6 ]
    - [ 2, 3, 4, 6 ]
    stash: 
      row: [ 5, 6, 7 ]
      col: [ 2, 2, 2 ]
      unit: [ 1, 1, 1 ]
    ways:
      - [2, 0, 0x0, [7, 2], [6, 2], [5, 2]]
      - [2, 1, 0x0, [7, 3], [6, 3], [5, 3]]
      - [2, 2, 0x0, [7, 4], [6, 4], [5, 4]]
      - [2, 3, 0x0, [7, 6], [6, 6], [5, 6]]
    input_xbar:
      exact group 1: { 64: ig_md.lkp.ip_src_addr.96-127(0..7), 77: ig_md.lkp.ip_src_addr.24-31, 88: ig_md.lkp.ip_src_addr.96-127(24..31), 96: ig_md.lkp.ip_src_addr.32-63(0..7), 104: ig_md.lkp.ip_src_addr.96-127(8..23), 120: ig_md.lkp.ip_src_addr.32-63(24..31) }
      exact group 2: { 0: ig_md.lkp.ip_src_addr.0-23(0..7), 8: ig_md.lkp.ip_src_addr.32-63(8..23), 24: ig_md.lkp.ip_src_addr.64-95(24..31), 32: ig_md.lkp.ip_src_addr.64-95(0..7), 40: ig_md.lkp.ip_src_addr.0-23(8..23), 56: ig_md.lkp.ip_dst_addr.32-63(24..31), 64: ig_md.lkp.ip_dst_addr.32-63(0..7), 72: ig_md.lkp.ip_src_addr.64-95(8..23), 88: ig_md.lkp.ip_dst_addr.64-95(24..31), 96: ig_md.lkp.ip_dst_addr.64-95(0..7), 104: ig_md.lkp.ip_dst_addr.32-63(8..23), 120: ig_md.lkp.ip_dst_addr.96-127(24..31) }
      exact group 3: { 0: ig_md.lkp.ip_dst_addr.96-127(0..7), 8: ig_md.lkp.ip_dst_addr.64-95(8..23), 24: ig_md.lkp.ip_dst_addr.0-31(24..31), 32: ig_md.lkp.ip_dst_addr.0-31(0..7), 40: ig_md.lkp.ip_dst_addr.96-127(8..23), 56: ig_md.vrf(8..13), 64: ig_md.vrf(0..7), 72: ig_md.lkp.ip_dst_addr.0-31(8..23) }
      hash 3:
        0..1: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        2..4: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        5..9: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        11..12: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        13..15: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        16..19: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..6)
        10: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(7)
        22..23: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        24..26: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        27..29: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..5)
        20..21: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(6..7)
        33..34: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        35..37: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        38..39: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..4)
        30..32: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(5..7)
      hash 4:
        0..9: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
        10..19: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
        20..29: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
        30..39: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
      hash 5:
        0..9: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
        10..19: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
        20..29: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
        30..39: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
      hash 6:
        0..9: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.vrf(8..13))
        10..19: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.vrf(8..13))
        20..29: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.vrf(8..13))
        30..39: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.vrf(8..13))
      hash 7:
        0..9: random(ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        10..19: random(ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        20..29: random(ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        30..39: random(ig_md.vrf(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
      hash group 2:
        table: [3, 4, 5, 6, 7]
        seed: 0x942d5d0025
    format: { immediate(0): 0..31, version(0): 112..115, match(0): [160..167, 128..133, 74..79, 32..63, 288..303, 64..71, 304..367, 256..287, 168..183, 368..375, 184..207, 376..383, 208..239 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(8..13), ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(8..15), ig_md.lkp.ip_src_addr.96-127(16..23), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.32-63(8..15), ig_md.lkp.ip_src_addr.32-63(16..23), ig_md.lkp.ip_src_addr.32-63(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.0-23(8..15), ig_md.lkp.ip_src_addr.0-23(16..23), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.64-95(8..15), ig_md.lkp.ip_src_addr.64-95(16..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_dst_addr.32-63(8..15), ig_md.lkp.ip_dst_addr.32-63(16..23), ig_md.lkp.ip_dst_addr.32-63(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.64-95(8..15), ig_md.lkp.ip_dst_addr.64-95(16..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.96-127(8..15), ig_md.lkp.ip_dst_addr.96-127(16..23), ig_md.lkp.ip_dst_addr.96-127(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  cond-25 ]
    miss:  multicast_ipv6_multicast_route_star_g
    action_bus: { 72..73 : immediate(0..15), 74..75 : immediate(16..31) }
    stats: multicast_ipv6_multicast_route_s_g$stats.SwitchIngress.multicast.ipv6_multicast_route.s_g_stats($DIRECT, $DEFAULT)
    instruction: multicast_ipv6_multicast_route_s_g($DEFAULT, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000052
      - next_table_miss:  multicast_ipv6_multicast_route_star_g
      - {  }
      SwitchIngress.multicast.ipv6_multicast_route.s_g_hit(0, 8):
      - p4_param_order: { mgid: 16, rpf_group: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000053
      - next_table_miss:  multicast_ipv6_multicast_route_star_g
      - next_table: 0
      - { mgid: immediate(0..15), rpf_group: immediate(16..31) }
      - set ig_md.multicast.id, mgid
      - set multicast_multicast_hit, 1
      - xor multicast_rpf_check, rpf_group, ig_md.multicast.rpf_group
      - multicast_ipv6_multicast_route_s_g$stats.SwitchIngress.multicast.ipv6_multicast_route.s_g_stats($DIRECT)
    default_only_action: NoAction
  counter multicast_ipv6_multicast_route_s_g$stats.SwitchIngress.multicast.ipv6_multicast_route.s_g_stats:
    p4: { name: SwitchIngress.multicast.ipv6_multicast_route.s_g_stats }
    row: 9
    column: [ 1, 2 ]
    maprams: [ 1, 2 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
  exact_match multicast_ipv6_multicast_route_star_g 8:
    p4: { name: SwitchIngress.multicast.ipv6_multicast_route.star_g, size: 512 }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 128, full_size: 128, key_name: "grp_addr" }
    row: [ 6, 7, 3, 4 ]
    search_bus: [ 1, 1, 0, 0 ]
    result_bus: [ 0, -1, 0, -1 ]
    column:
    - 7
    - 7
    - [ 2, 3, 4 ]
    - [ 2, 3, 4 ]
    stash: 
      row: [ 6, 7 ]
      col: [ 7, 7 ]
      unit: [ 0, 0 ]
    ways:
      - [3, 0, 0x0, [7, 7], [6, 7]]
      - [3, 1, 0x0, [4, 2], [3, 2]]
      - [3, 2, 0x0, [4, 3], [3, 3]]
      - [3, 3, 0x0, [4, 4], [3, 4]]
    input_xbar:
      exact group 4: { 0: ig_md.lkp.ip_dst_addr.32-63, 32: ig_md.lkp.ip_dst_addr.64-95, 64: ig_md.lkp.ip_dst_addr.96-127, 96: ig_md.lkp.ip_dst_addr.0-31 }
      exact group 5: { 0: ig_md.vrf }
      hash 8:
        0..9: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
        10..19: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
        20..29: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
        30..39: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
      hash 9:
        0..9: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        10..19: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        20..29: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        30..39: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
      hash 10:
        0..3: random(ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        4..9: random(ig_md.vrf(4..7)) ^ ig_md.vrf(8..13)
        11..14: random(ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        15..19: random(ig_md.vrf(4..7)) ^ ig_md.vrf(8..12)
        10: random(ig_md.vrf(4..7)) ^ ig_md.vrf(13)
        22..25: random(ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        26..29: random(ig_md.vrf(4..7)) ^ ig_md.vrf(8..11)
        20..21: random(ig_md.vrf(4..7)) ^ ig_md.vrf(12..13)
        33..36: random(ig_md.vrf(4..7)) ^ ig_md.vrf(0..3)
        37..39: random(ig_md.vrf(4..7)) ^ ig_md.vrf(8..10)
        30..32: random(ig_md.vrf(4..7)) ^ ig_md.vrf(11..13)
      hash group 3:
        table: [8, 9, 10]
        seed: 0xa38f9519d7
    format: { action(0): 0..0, immediate(0): 1..32, version(0): 112..115, match(0): [36..39, 160..239, 128..159, 240..255 ] }
    match: [ ig_md.vrf(4..7), ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_dst_addr.32-63(8..15), ig_md.lkp.ip_dst_addr.32-63(16..23), ig_md.lkp.ip_dst_addr.32-63(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.64-95(8..15), ig_md.lkp.ip_dst_addr.64-95(16..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.96-127(8..15), ig_md.lkp.ip_dst_addr.96-127(16..23), ig_md.lkp.ip_dst_addr.96-127(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  cond-25 ]
    miss:  cond-25
    action_bus: { 24 : immediate(0..7), 25 : immediate(8..15), 78..79 : immediate(16..31) }
    stats: multicast_ipv6_multicast_route_star_g$stats.SwitchIngress.multicast.ipv6_multicast_route.star_g_stats($DIRECT, $DEFAULT)
    action: multicast_ipv6_multicast_route_star_g$action_data($DIRECT, $DEFAULT)
    instruction: multicast_ipv6_multicast_route_star_g(action, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000054
      - next_table: 0
      - {  }
      SwitchIngress.multicast.ipv6_multicast_route.star_g_hit_sm(0, 10):
      - p4_param_order: { mgid: 16, rpf_group: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000055
      - next_table: 0
      - { rpf_group: $adf_h0(0..15), $data0: immediate(4..7), $constant1: $data0(0..1), $constant1: 1, $constant0: $data0(3..3), $constant0: 1, $mask0: immediate(12..15), $constant2: $mask0(0..1), $constant2: 3, $constant3: $mask0(3..3), $constant3: 1, mgid: immediate(16..31) }
      - set ig_md.multicast.id, mgid
      - xor multicast_rpf_check, rpf_group, ig_md.multicast.rpf_group
      - bitmasked-set B54, $data0, B54
      - multicast_ipv6_multicast_route_star_g$stats.SwitchIngress.multicast.ipv6_multicast_route.star_g_stats($DIRECT)
      SwitchIngress.multicast.ipv6_multicast_route.star_g_hit_bidir(1, 12):
      - p4_param_order: { mgid: 16, rpf_group: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000056
      - next_table: 0
      - { rpf_group: $adf_h0(0..15), $data0: immediate(4..7), $constant1: $data0(0..1), $constant1: 2, $constant0: $data0(3..3), $constant0: 1, $mask0: immediate(12..15), $constant2: $mask0(0..1), $constant2: 3, $constant3: $mask0(3..3), $constant3: 1, mgid: immediate(16..31) }
      - set ig_md.multicast.id, mgid
      - and multicast_rpf_check, rpf_group, ig_md.multicast.rpf_group
      - bitmasked-set B54, $data0, B54
      - multicast_ipv6_multicast_route_star_g$stats.SwitchIngress.multicast.ipv6_multicast_route.star_g_stats($DIRECT)
    default_only_action: NoAction
  counter multicast_ipv6_multicast_route_star_g$stats.SwitchIngress.multicast.ipv6_multicast_route.star_g_stats:
    p4: { name: SwitchIngress.multicast.ipv6_multicast_route.star_g_stats }
    row: 13
    column: [ 2, 3 ]
    maprams: [ 2, 3 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
  action multicast_ipv6_multicast_route_star_g$action_data:
    p4: { name: SwitchIngress.multicast.ipv6_multicast_route.star_g$action }
    row: 14
    column: 5
    vpns: [ 0 ]
    home_row:
    - 14
    format SwitchIngress.multicast.ipv6_multicast_route.star_g_hit_sm: { $adf_h0: 0..15 }
    format SwitchIngress.multicast.ipv6_multicast_route.star_g_hit_bidir: { $adf_h0: 0..15 }
    action_bus: { 40..41 : $adf_h0 }
stage 3 ingress:
  gateway cond-19 5:
    name: cond-19
    input_xbar:
      exact group 1: { 0: ig_md.ipv4.unicast_enable, 10: ig_md.lkp.ip_type }
    row: 2
    bus: 0
    unit: 1
    match: { 2: ig_md.lkp.ip_type, 8: ig_md.ipv4.unicast_enable }
    0b*******1****01:  unicast_ipv4_fib_fib
    miss:  cond-20
    condition: 
      expression: "(ig_md.lkp.ip_type == 1 && ig_md.ipv4.unicast_enable)"
      true:  unicast_ipv4_fib_fib
      false:  cond-20
  exact_match unicast_ipv4_fib_fib 6:
    p4: { name: SwitchIngress.unicast.ipv4_fib.fib, size: 16384 }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 32, full_size: 128, key_name: "dst_addr" }
    row: [ 2, 1 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4, 5, 6, 7 ]
    - [ 2, 3 ]
    stash: 
      row: [ 1 ]
      col: [ 2 ]
      unit: [ 1 ]
    ways:
      - [2, 0, 0x1, [1, 2], [1, 3]]
      - [2, 1, 0x2, [2, 6], [2, 7]]
      - [2, 2, 0x4, [2, 4], [2, 5]]
      - [2, 3, 0x8, [2, 2], [2, 3]]
    input_xbar:
      exact group 1: { 16: ig_md.lkp.ip_dst_addr.0-31(16..31), 32: ig_md.lkp.ip_dst_addr.0-31(0..15), 48: ig_md.vrf }
      hash 2:
        0..4: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(0..4)
        5..9: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(8..12)
        40: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(13)
        11..15: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(0..4)
        16..19: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(8..11)
        10: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(13)
        41: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(12)
        22..26: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(0..4)
        27..29: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(8..10)
        20..21: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(12..13)
        42: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(11)
        33..37: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(0..4)
        38..39: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(8..9)
        30..32: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(11..13)
        43: random(ig_md.lkp.ip_dst_addr.0-31(16..31), ig_md.lkp.ip_dst_addr.0-31(0..15), ig_md.vrf(5..7)) ^ ig_md.vrf(10)
      hash group 2:
        table: [2]
        seed: 0x373f22cacc3
    format: { action(0): 0..1, immediate(0): 4..19, version(0): 112..115, match(0): 37..71, action(1): 2..3, immediate(1): 20..35, version(1): 116..119, match(1): [109..111, 72..103 ] }
    match: [ ig_md.vrf(5..7), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  qos_policer_meter_index ]
    miss:  unicast_ipv4_fib_fib_lpm__alpm_preclassifier
    action_bus: { 112..115 : immediate(0..15) }
    instruction: unicast_ipv4_fib_fib(action, $DEFAULT)
    actions:
      SwitchIngress.unicast.ipv4_fib.fib_miss(0, 1):
      - default_action: { allowed: true }
      - handle: 0x2000003d
      - next_table_miss:  unicast_ipv4_fib_fib_lpm__alpm_preclassifier
      - next_table: 0
      - {  }
      - set ig_md.flags.routed, 0
      SwitchIngress.unicast.ipv4_fib.fib_hit(1, 2):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000003e
      - next_table_miss:  unicast_ipv4_fib_fib_lpm__alpm_preclassifier
      - next_table: 0
      - { nexthop_index: immediate(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.routed, 1
      SwitchIngress.unicast.ipv4_fib.fib_myip(2, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000003f
      - next_table_miss:  unicast_ipv4_fib_fib_lpm__alpm_preclassifier
      - next_table: 0
      - {  }
      - set ig_md.flags.myip, 1
    default_action: SwitchIngress.unicast.ipv4_fib.fib_miss
  ternary_match unicast_ipv4_fib_fib_lpm__alpm_preclassifier 7:
    p4: { name: SwitchIngress.unicast.ipv4_fib.fib_lpm, size: 16384, match_type: alpm }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: lpm, size: 32, full_size: 128, key_name: "dst_addr" }
    row: [ 4, 5, 6, 7, 8, 9, 10, 11 ]
    bus: [ 1, 1, 1, 1, 1, 1, 1, 1 ]
    column:
    - 1
    - 1
    - 1
    - 1
    - 1
    - 1
    - 1
    - 1
    indirect_bus: 1
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.vrf(0..7) }
      ternary group 1: { 8: ig_md.vrf(8..13) }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x155 }
    - { group: 1, dirtcam: 0x4 }
    hit: [  unicast_ipv4_fib_fib_lpm$atcam$lt0 ]
    miss:  unicast_ipv4_fib_fib_lpm$atcam$lt0
    action: unicast_ipv4_fib_fib_lpm__alpm_preclassifier$action_data($DIRECT, $DEFAULT)
    instruction: unicast_ipv4_fib_fib_lpm__alpm_preclassifier($DEFAULT, $DEFAULT)
    actions:
      unicast_ipv4_fib_fib_lpm__alpm_preclassifier__set_partition_index(0, 4):
      - p4_param_order: { partition_index: 10 }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000040
      - next_table: 0
      - { partition_index: $adf_h0(0..9) }
      - set unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index, partition_index
    default_action: unicast_ipv4_fib_fib_lpm__alpm_preclassifier__set_partition_index
  action unicast_ipv4_fib_fib_lpm__alpm_preclassifier$action_data:
    p4: { name: SwitchIngress.unicast.ipv4_fib.fib_lpm_preclassifier$action }
    row: 9
    column: 0
    vpns: [ 0 ]
    home_row:
    - 9
    format unicast_ipv4_fib_fib_lpm__alpm_preclassifier__set_partition_index: { $adf_h0: 0..15 }
    action_bus: { 40..41 : $adf_h0 }
  gateway cond-20 8:
    name: cond-20
    input_xbar:
      exact group 1: { 3: ig_md.ipv6.unicast_enable, 10: ig_md.lkp.ip_type }
    row: 1
    bus: 0
    unit: 0
    match: { 2: ig_md.lkp.ip_type, 11: ig_md.ipv6.unicast_enable }
    0b****1*******10:  unicast_ipv6_fib_fib
    miss:  qos_policer_meter_index
    condition: 
      expression: "(ig_md.lkp.ip_type == 2 && ig_md.ipv6.unicast_enable)"
      true:  unicast_ipv6_fib_fib
      false:  qos_policer_meter_index
  exact_match unicast_ipv6_fib_fib 9:
    p4: { name: SwitchIngress.unicast.ipv6_fib.fib, size: 8192 }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 128, full_size: 128, key_name: "dst_addr" }
    row: [ 6, 7, 4, 5 ]
    bus: [ 0, 0, 0, 0 ]
    column:
    - [ 2, 3, 4, 5, 6, 7 ]
    - [ 2, 3, 4, 5, 6, 7 ]
    - [ 2, 3 ]
    - [ 2, 3 ]
    stash: 
      row: [ 6, 7 ]
      col: [ 2, 2 ]
      unit: [ 0, 0 ]
    ways:
      - [3, 0, 0x1, [7, 2], [6, 2], [7, 3], [6, 3]]
      - [3, 1, 0x2, [7, 4], [6, 4], [7, 5], [6, 5]]
      - [3, 2, 0x4, [7, 6], [6, 6], [7, 7], [6, 7]]
      - [3, 3, 0x8, [5, 2], [4, 2], [5, 3], [4, 3]]
    input_xbar:
      exact group 1: { 64: ig_md.lkp.ip_dst_addr.32-63, 96: ig_md.lkp.ip_dst_addr.64-95 }
      exact group 2: { 0: ig_md.lkp.ip_dst_addr.96-127, 32: ig_md.lkp.ip_dst_addr.0-31, 64: ig_md.vrf }
      hash 3:
        0..7: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(0..7)
        8..9: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(8..9)
        40: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(10)
        11..18: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(0..7)
        19: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(8)
        10: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(10)
        41: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(9)
        22..29: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(0..7)
        20..21: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(9..10)
        42: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(8)
        33..39: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(0..6)
        30..32: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(8..10)
        43: random(ig_md.lkp.ip_dst_addr.32-63(11..31), ig_md.lkp.ip_dst_addr.64-95) ^ ig_md.lkp.ip_dst_addr.32-63(7)
      hash 4:
        0..9: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        40: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        10..19: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        41: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        20..29: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        42: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        30..39: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        43: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
      hash 5:
        0..9: random(ig_md.vrf)
        40: random(ig_md.vrf)
        10..19: random(ig_md.vrf)
        41: random(ig_md.vrf)
        20..29: random(ig_md.vrf)
        42: random(ig_md.vrf)
        30..39: random(ig_md.vrf)
        43: random(ig_md.vrf)
      hash group 3:
        table: [3, 4, 5]
        seed: 0x2b28c6372e0
    format: { action(0): 0..1, immediate(0): 2..17, version(0): 112..115, match(0): [160..167, 232..237, 83..87, 32..79, 168..231 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(8..13), ig_md.lkp.ip_dst_addr.32-63(11..15), ig_md.lkp.ip_dst_addr.32-63(16..23), ig_md.lkp.ip_dst_addr.32-63(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.64-95(8..15), ig_md.lkp.ip_dst_addr.64-95(16..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.96-127(8..15), ig_md.lkp.ip_dst_addr.96-127(16..23), ig_md.lkp.ip_dst_addr.96-127(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  qos_policer_meter_index ]
    miss:  unicast_ipv6_fib_fib_lpm__alpm_preclassifier
    action_bus: { 116..119 : immediate(0..15) }
    instruction: unicast_ipv6_fib_fib(action, $DEFAULT)
    actions:
      SwitchIngress.unicast.ipv6_fib.fib_miss(0, 5):
      - default_action: { allowed: true }
      - handle: 0x20000043
      - next_table_miss:  unicast_ipv6_fib_fib_lpm__alpm_preclassifier
      - next_table: 0
      - {  }
      - set ig_md.flags.routed, 0
      SwitchIngress.unicast.ipv6_fib.fib_hit(1, 6):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000044
      - next_table_miss:  unicast_ipv6_fib_fib_lpm__alpm_preclassifier
      - next_table: 0
      - { nexthop_index: immediate(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.routed, 1
      SwitchIngress.unicast.ipv6_fib.fib_myip(2, 7):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000045
      - next_table_miss:  unicast_ipv6_fib_fib_lpm__alpm_preclassifier
      - next_table: 0
      - {  }
      - set ig_md.flags.myip, 1
    default_action: SwitchIngress.unicast.ipv6_fib.fib_miss
  ternary_match unicast_ipv6_fib_fib_lpm__alpm_preclassifier 10:
    p4: { name: SwitchIngress.unicast.ipv6_fib.fib_lpm, size: 1024, match_type: alpm }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: lpm, size: 128, full_size: 128, key_name: "dst_addr" }
    row: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3 ]
    bus: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 1
    - 1
    - 1
    - 1
    indirect_bus: 0
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.vrf(0..7) }
      ternary group 1: { 0: ig_md.lkp.ip_dst_addr.32-63(16..23), 8: ig_md.vrf(8..13), 16: ig_md.lkp.ip_dst_addr.32-63(0..7), 24: ig_md.lkp.ip_dst_addr.64-95(8..23) }
      ternary group 2: { 0: ig_md.lkp.ip_dst_addr.32-63(24..31), 8: ig_md.lkp.ip_dst_addr.64-95(0..7), 16: ig_md.lkp.ip_dst_addr.96-127(8..23), 32: ig_md.lkp.ip_dst_addr.64-95(24..31) }
      ternary group 3: { 16: ig_md.lkp.ip_dst_addr.96-127(24..31), 24: ig_md.lkp.ip_dst_addr.96-127(0..7) }
      byte group 0: { 0: ig_md.lkp.ip_dst_addr.32-63(8..15) }
    match:
    - { group: 0, byte_group: 0, byte_config: 0, dirtcam: 0x555 }
    - { group: 1, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 2, byte_config: 3, dirtcam: 0x155 }
    - { group: 3, dirtcam: 0x50 }
    hit: [  unicast_ipv6_fib_fib_lpm$atcam$lt0 ]
    miss:  unicast_ipv6_fib_fib_lpm$atcam$lt0
    action: unicast_ipv6_fib_fib_lpm__alpm_preclassifier$action_data($DIRECT, $DEFAULT)
    instruction: unicast_ipv6_fib_fib_lpm__alpm_preclassifier($DEFAULT, $DEFAULT)
    actions:
      unicast_ipv6_fib_fib_lpm__alpm_preclassifier__set_partition_index(0, 8):
      - p4_param_order: { partition_index: 10 }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000046
      - next_table: 0
      - { partition_index: $adf_h0(0..9) }
      - set unicast_ipv6_fib_fib_lpm__metadata.unicast_ipv6_fib_fib_lpm_partition_index, partition_index
    default_action: unicast_ipv6_fib_fib_lpm__alpm_preclassifier__set_partition_index
  action unicast_ipv6_fib_fib_lpm__alpm_preclassifier$action_data:
    p4: { name: SwitchIngress.unicast.ipv6_fib.fib_lpm_preclassifier$action }
    row: 11
    column: 1
    vpns: [ 0 ]
    home_row:
    - 11
    format unicast_ipv6_fib_fib_lpm__alpm_preclassifier__set_partition_index: { $adf_h0: 0..15 }
    action_bus: { 44..45 : $adf_h0 }
  exact_match dmac_dmac 14:
    p4: { name: SwitchIngress.dmac.dmac, size: 16384 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16 }
      ig_md.lkp.mac_dst_addr: { type: exact, size: 48, full_size: 48, key_name: "dst_addr" }
    row: [ 5, 3 ]
    search_bus: [ 1, 0 ]
    result_bus: [ 0, 0 ]
    column:
    - [ 4, 5 ]
    - [ 2, 3, 4, 5, 6, 7 ]
    stash: 
      row: [ 3 ]
      col: [ 6 ]
      unit: [ 0 ]
    ways:
      - [6, 0, 0x1, [3, 6], [3, 7]]
      - [6, 1, 0x2, [3, 4], [3, 5]]
      - [6, 2, 0x4, [3, 2], [3, 3]]
      - [6, 3, 0x8, [5, 4], [5, 5]]
    input_xbar:
      exact group 5: { 0: ig_md.lkp.mac_dst_addr.16-47, 32: ig_md.bd, 48: ig_md.lkp.mac_dst_addr.0-15 }
      hash 10:
        0..7: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(0..7)
        8..9: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(8..9)
        40: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(10)
        11..18: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(0..7)
        19: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(8)
        10: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(10)
        41: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(9)
        22..29: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(0..7)
        20..21: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(9..10)
        42: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(8)
        33..39: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(0..6)
        30..32: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(8..10)
        43: random(ig_md.lkp.mac_dst_addr.16-47, ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15) ^ ig_md.bd(7)
      hash group 6:
        table: [10]
        seed: 0x90f37e78ed
    format: { action(0): 0..2, version(0): 112..115, match(0): [83..87, 32..79 ], action(1): 3..5, version(1): 116..119, match(1): [123..127, 88..111, 8..31 ] }
    match: [ ig_md.bd(11..15), ig_md.lkp.mac_dst_addr.0-15(0..7), ig_md.lkp.mac_dst_addr.0-15(8..15), ig_md.lkp.mac_dst_addr.16-47(0..7), ig_md.lkp.mac_dst_addr.16-47(8..15), ig_md.lkp.mac_dst_addr.16-47(16..23), ig_md.lkp.mac_dst_addr.16-47(24..31) ]
    gateway:
      name: cond-21
      input_xbar:
        exact group 2: { 112: ig_md.bypass(0) }
      row: 7
      bus: 0
      unit: 0
      match: { 0: ig_md.bypass(0) }
      0b*******0: run_table
      miss:  qos_policer_meter_index
      condition: 
        expression: "(ig_md.bypass & 1 == 0)"
        true:  dmac_dmac
        false:  qos_policer_meter_index
    hit: [  qos_policer_meter_index ]
    miss:  qos_policer_meter_index
    action: dmac_dmac$action_data($DIRECT, $DEFAULT)
    instruction: dmac_dmac(action, $DEFAULT)
    actions:
      SwitchIngress.dmac.dmac_miss(1, 11):
      - default_action: { allowed: true }
      - handle: 0x20000049
      - next_table: 0
      - {  }
      - set ig_md.egress_ifindex, 65535
      - set ig_md.flags.dmac_miss, 1
      SwitchIngress.dmac.dmac_hit(2, 13):
      - p4_param_order: { ifindex: 16, port_lag_index: 10 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000004a
      - next_table: 0
      - { ifindex: $adf_h0(0..15) }
      - set ig_md.egress_ifindex, ifindex
      SwitchIngress.dmac.dmac_multicast(3, 14):
      - p4_param_order: { index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000004b
      - next_table: 0
      - { index: $adf_h0(0..15) }
      - set ig_md.multicast.id, index
      SwitchIngress.dmac.dmac_redirect(4, 15):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000004c
      - next_table: 0
      - { nexthop_index: $adf_f0(0..15) }
      - set ig_md.nexthop, nexthop_index
    default_action: SwitchIngress.dmac.dmac_miss
  action dmac_dmac$action_data:
    p4: { name: SwitchIngress.dmac.dmac$action }
    row: [ 13, 11 ]
    word: [ 0, 0 ]
    column:
    - [ 3, 4, 5 ]
    - 0
    vpns: 
    - [ 0, 1, 2 ]
    - [ 3 ]
    home_row:
    - 13
    format SwitchIngress.dmac.dmac_hit: { $adf_h0: 0..15 }
    format SwitchIngress.dmac.dmac_multicast: { $adf_h0: 0..15 }
    format SwitchIngress.dmac.dmac_redirect: { $adf_f0: 0..31 }
    action_bus: { 56..57 : $adf_h0, 56..59 : $adf_f0 }
  gateway cond-25 11:
    name: cond-25
    input_xbar:
      exact group 2: { 80: multicast_rpf_check, 100: ig_md.multicast.mode, 103: multicast_multicast_hit }
    row: 5
    bus: 0
    unit: 0
    match: { 31: multicast_multicast_hit, 20: ig_md.multicast.mode, 0: multicast_rpf_check(0..7), 8: multicast_rpf_check(8..15) }
    0b0*******************************:  multicast_ipv4_multicast_bridge_s_g
    0b**********10****0000000000000000:  multicast_ipv4_multicast_bridge_s_g
    0x****0000:  multicast_fwd_result
    0b**********01********************:  multicast_ipv4_multicast_bridge_s_g
    miss:  multicast_fwd_result
    condition: 
      expression: "(multicast_multicast_hit == 0 || ig_md.multicast.mode == 1 && multicast_rpf_check != 0 || ig_md.multicast.mode == 2 && multicast_rpf_check == 0)"
      true:  multicast_ipv4_multicast_bridge_s_g
      false:  multicast_fwd_result
  exact_match multicast_ipv4_multicast_bridge_s_g 12:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_bridge.s_g, size: 4096 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
      ig_md.lkp.ip_src_addr: { type: exact, size: 32, full_size: 128, key_name: "src_addr" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 32, full_size: 128, key_name: "grp_addr" }
    row: 1
    bus: 1
    column: [ 4, 5, 6, 7 ]
    stash: 
      row: [ 1 ]
      col: [ 7 ]
      unit: [ 0 ]
    ways:
      - [4, 0, 0x0, [1, 7]]
      - [4, 1, 0x0, [1, 6]]
      - [4, 2, 0x0, [1, 5]]
      - [4, 3, 0x0, [1, 4]]
    input_xbar:
      exact group 3: { 0: ig_md.lkp.ip_src_addr.0-23(0..7), 13: ig_md.lkp.ip_src_addr.24-31, 24: ig_md.lkp.ip_dst_addr.0-31(24..31), 32: ig_md.lkp.ip_dst_addr.0-31(0..7), 40: ig_md.lkp.ip_src_addr.0-23(8..23), 56: ig_md.bd(8..15), 64: ig_md.bd(0..7), 72: ig_md.lkp.ip_dst_addr.0-31(8..23) }
      hash 6:
        8..9: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15))
        0..2: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        3..7: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        10: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15))
        19: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15))
        11..13: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        14..18: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        20..21: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15))
        22..24: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        25..29: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        31..32: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15))
        33..35: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        36..39: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(3..6)
        30: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.bd(8..15)) ^ ig_md.lkp.ip_src_addr.24-31(7)
      hash 7:
        0..7: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        8..9: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23)) ^ ig_md.bd(0..1)
        11..18: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        19: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23)) ^ ig_md.bd(0)
        10: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23)) ^ ig_md.bd(1)
        22..29: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        20..21: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23)) ^ ig_md.bd(0..1)
        30: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        33..39: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        31..32: random(ig_md.bd(2..7), ig_md.lkp.ip_dst_addr.0-31(8..23)) ^ ig_md.bd(0..1)
      hash group 4:
        table: [6, 7]
        seed: 0x8a7a7af687
    format: { action(0): 0..1, immediate(0): 2..17, version(0): 112..115, match(0): [98..103, 32..95 ] }
    match: [ ig_md.bd(2..7), ig_md.bd(8..15), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.0-23(8..15), ig_md.lkp.ip_src_addr.0-23(16..23), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    gateway:
      name: cond-26
      input_xbar:
        exact group 0: { 58: ig_md.lkp.ip_type }
      row: 2
      bus: 1
      unit: 0
      match: { 2: ig_md.lkp.ip_type }
      0b****01: run_table
      miss:  multicast_ipv6_multicast_bridge_s_g
      condition: 
        expression: "(ig_md.lkp.ip_type == 1)"
        true:  multicast_ipv4_multicast_bridge_s_g
        false:  multicast_ipv6_multicast_bridge_s_g
    hit: [ [],  multicast_ipv4_multicast_bridge_star_g,  multicast_fwd_result ]
    miss:  multicast_fwd_result
    action_bus: { 48..49 : immediate(0..15) }
    instruction: multicast_ipv4_multicast_bridge_s_g(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000057
      - next_table: 1
      - {  }
      SwitchIngress.multicast.ipv4_multicast_bridge.s_g_hit(2, 9):
      - p4_param_order: { mgid: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000005a
      - next_table: 2
      - { mgid: immediate(0..15) }
      - set ig_md.multicast.id, mgid
      - set multicast_multicast_hit, 1
    default_action: NoAction
  exact_match multicast_ipv4_multicast_bridge_star_g 13:
    p4: { name: SwitchIngress.multicast.ipv4_multicast_bridge.star_g, size: 2048 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 32, full_size: 128, key_name: "grp_addr" }
    row: 0
    bus: 1
    column: [ 3, 4, 5, 6 ]
    stash: 
      row: [ 0 ]
      col: [ 6 ]
      unit: [ 0 ]
    ways:
      - [5, 0, 0x0, [0, 6]]
      - [5, 1, 0x0, [0, 5]]
      - [5, 2, 0x0, [0, 4]]
      - [5, 3, 0x0, [0, 3]]
    input_xbar:
      exact group 4: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.bd }
      hash 8:
        0..7: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(0..7)
        8..9: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(8..9)
        11..18: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(0..7)
        19: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(8)
        10: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(9)
        22..29: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(0..7)
        20..21: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(8..9)
        33..39: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(0..6)
        30: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(7)
        31..32: random(ig_md.lkp.ip_dst_addr.0-31, ig_md.bd(10..15)) ^ ig_md.bd(8..9)
      hash group 5:
        table: [8]
        seed: 0xc7e69a3492
    format: { action(0): 0..0, immediate(0): 2..17, version(0): 112..115, match(0): 34..71, action(1): 1..1, immediate(1): 18..33, version(1): 116..119, match(1): [106..111, 72..103 ] }
    match: [ ig_md.bd(10..15), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  multicast_fwd_result ]
    miss:  multicast_fwd_result
    action_bus: { 52..53 : immediate(0..15) }
    instruction: multicast_ipv4_multicast_bridge_star_g(action, $DEFAULT)
    actions:
      SwitchIngress.multicast.ipv4_multicast_bridge.star_g_miss(0, 10):
      - default_action: { allowed: true }
      - handle: 0x20000058
      - next_table: 0
      - {  }
      - set multicast_multicast_hit, 0
      SwitchIngress.multicast.ipv4_multicast_bridge.star_g_hit(1, 12):
      - p4_param_order: { mgid: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000059
      - next_table: 0
      - { mgid: immediate(0..15) }
      - set ig_md.multicast.id, mgid
      - set multicast_multicast_hit, 1
    default_action: SwitchIngress.multicast.ipv4_multicast_bridge.star_g_miss
stage 4 ingress:
  atcam_match unicast_ipv6_fib_fib_lpm$atcam$lt0 7:
    p4: { name: SwitchIngress.unicast.ipv6_fib.fib_lpm, size: 1024, match_type: alpm }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: lpm, size: 128, full_size: 128, key_name: "dst_addr" }
    row: [ 5, 6, 7 ]
    bus: [ 0, 0, 0 ]
    column:
    - [ 8, 7 ]
    - [ 8, 7 ]
    - [ 8, 7 ]
    ways:
      - [5, 0, 0x0, [7, 8], [6, 8], [5, 8]]
      - [5, 0, 0x0, [7, 7], [6, 7], [5, 7]]
    input_xbar:
      exact group 3: { 32: ig_md.lkp.ip_dst_addr.0-31(0..7), 72: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      exact group 4: { 16: ig_md.lkp.ip_dst_addr.32-63(16..31), 48: ig_md.lkp.ip_dst_addr.64-95(16..31), 80: ig_md.lkp.ip_dst_addr.96-127(16..31), 112: ig_md.lkp.ip_dst_addr.0-31(16..31) }
      exact group 5: { 16: ig_md.vrf, 32: ig_md.lkp.ip_dst_addr.32-63(0..15), 64: ig_md.lkp.ip_dst_addr.64-95(0..15), 80: unicast_ipv6_fib_fib_lpm__metadata.unicast_ipv6_fib_fib_lpm_partition_index, 96: ig_md.lkp.ip_dst_addr.96-127(0..15) }
      hash 11:
        0..7: unicast_ipv6_fib_fib_lpm__metadata.unicast_ipv6_fib_fib_lpm_partition_index(0..7)
        8..9: unicast_ipv6_fib_fib_lpm__metadata.unicast_ipv6_fib_fib_lpm_partition_index(8..9)
      hash group 5:
        table: [11]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..16, version(0): 112..115, match(0): [160..167, 152..157, 168..199, 288..319, 200..231, 320..351, 232..239, 128..151, 352..367, 256..271, 32..63, 272..287, 368..383 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(8..13), ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_dst_addr.32-63(8..15), ig_md.lkp.ip_dst_addr.32-63(8..15), ig_md.lkp.ip_dst_addr.32-63(16..23), ig_md.lkp.ip_dst_addr.32-63(16..23), ig_md.lkp.ip_dst_addr.32-63(24..31), ig_md.lkp.ip_dst_addr.32-63(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.64-95(8..15), ig_md.lkp.ip_dst_addr.64-95(8..15), ig_md.lkp.ip_dst_addr.64-95(16..23), ig_md.lkp.ip_dst_addr.64-95(16..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.96-127(8..15), ig_md.lkp.ip_dst_addr.96-127(8..15), ig_md.lkp.ip_dst_addr.96-127(16..23), ig_md.lkp.ip_dst_addr.96-127(16..23), ig_md.lkp.ip_dst_addr.96-127(24..31), ig_md.lkp.ip_dst_addr.96-127(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    number_partitions: 1024
    subtrees_per_partition: 2
    bins_per_partition: 2
    partition_field_name: unicast_ipv6_fib_fib_lpm__metadata.unicast_ipv6_fib_fib_lpm_partition_index
    hit: [  qos_policer_meter_index ]
    miss:  qos_policer_meter_index
    action_bus: { 100..103 : immediate(0..15) }
    instruction: unicast_ipv6_fib_fib_lpm$atcam$lt0(action, $DEFAULT)
    actions:
      SwitchIngress.unicast.ipv6_fib.fib_miss(0, 3):
      - default_action: { allowed: true }
      - handle: 0x20000047
      - next_table: 0
      - {  }
      - set ig_md.flags.routed, 0
      SwitchIngress.unicast.ipv6_fib.fib_hit(1, 5):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000048
      - next_table: 0
      - { nexthop_index: immediate(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.routed, 1
    default_action: SwitchIngress.unicast.ipv6_fib.fib_miss
  exact_match multicast_ipv6_multicast_bridge_s_g 5:
    p4: { name: SwitchIngress.multicast.ipv6_multicast_bridge.s_g, size: 512 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
      ig_md.lkp.ip_src_addr: { type: exact, size: 128, full_size: 128, key_name: "src_addr" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 128, full_size: 128, key_name: "grp_addr" }
    row: [ 5, 6, 7 ]
    bus: [ 1, 1, 1 ]
    column:
    - [ 2, 3, 4, 6 ]
    - [ 2, 3, 4, 6 ]
    - [ 2, 3, 4, 6 ]
    stash: 
      row: [ 5, 6, 7 ]
      col: [ 2, 2, 2 ]
      unit: [ 0, 0, 0 ]
    ways:
      - [3, 0, 0x0, [7, 2], [6, 2], [5, 2]]
      - [3, 1, 0x0, [7, 3], [6, 3], [5, 3]]
      - [3, 2, 0x0, [7, 4], [6, 4], [5, 4]]
      - [3, 3, 0x0, [7, 6], [6, 6], [5, 6]]
    input_xbar:
      exact group 1: { 64: ig_md.lkp.ip_src_addr.96-127(0..7), 77: ig_md.lkp.ip_src_addr.24-31, 88: ig_md.lkp.ip_src_addr.96-127(24..31), 96: ig_md.lkp.ip_src_addr.32-63(0..7), 104: ig_md.lkp.ip_src_addr.96-127(8..23), 120: ig_md.lkp.ip_src_addr.32-63(24..31) }
      exact group 2: { 0: ig_md.lkp.ip_src_addr.0-23(0..7), 8: ig_md.lkp.ip_src_addr.32-63(8..23), 24: ig_md.lkp.ip_src_addr.64-95(24..31), 32: ig_md.lkp.ip_src_addr.64-95(0..7), 40: ig_md.lkp.ip_src_addr.0-23(8..23), 56: ig_md.lkp.ip_dst_addr.32-63(24..31), 64: ig_md.lkp.ip_dst_addr.32-63(0..7), 72: ig_md.lkp.ip_src_addr.64-95(8..23), 88: ig_md.lkp.ip_dst_addr.64-95(24..31), 96: ig_md.lkp.ip_dst_addr.64-95(0..7), 104: ig_md.lkp.ip_dst_addr.32-63(8..23), 120: ig_md.lkp.ip_dst_addr.96-127(24..31) }
      exact group 3: { 0: ig_md.lkp.ip_dst_addr.96-127(0..7), 8: ig_md.lkp.ip_dst_addr.64-95(8..23), 24: ig_md.lkp.ip_dst_addr.0-31(24..31), 32: ig_md.lkp.ip_dst_addr.0-31(0..7), 40: ig_md.lkp.ip_dst_addr.96-127(8..23), 56: ig_md.bd(8..15), 64: ig_md.bd(0..7), 72: ig_md.lkp.ip_dst_addr.0-31(8..23) }
      hash 3:
        0..1: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        2..4: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        5..9: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..7)
        11..12: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        13..15: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        16..19: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..6)
        10: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(7)
        22..23: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        24..26: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        27..29: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..5)
        20..21: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(6..7)
        33..34: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.96-127(0..1)
        35..37: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(0..2)
        38..39: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(3..4)
        30..32: random(ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.96-127(8..23), ig_md.lkp.ip_src_addr.32-63(24..31)) ^ ig_md.lkp.ip_src_addr.24-31(5..7)
      hash 4:
        0..9: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
        10..19: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
        20..29: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
        30..39: random(ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.32-63(8..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.0-23(8..23), ig_md.lkp.ip_dst_addr.32-63(24..31))
      hash 5:
        0..9: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
        10..19: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
        20..29: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
        30..39: random(ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_src_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.32-63(8..23), ig_md.lkp.ip_dst_addr.96-127(24..31))
      hash 6:
        0..9: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.bd(8..15))
        10..19: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.bd(8..15))
        20..29: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.bd(8..15))
        30..39: random(ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.64-95(8..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.96-127(8..23), ig_md.bd(8..15))
      hash 7:
        0..9: random(ig_md.bd(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        10..19: random(ig_md.bd(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        20..29: random(ig_md.bd(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
        30..39: random(ig_md.bd(0..7), ig_md.lkp.ip_dst_addr.0-31(8..23))
      hash group 3:
        table: [3, 4, 5, 6, 7]
        seed: 0xacfe18f7e2
    format: { action(0): 0..1, immediate(0): 2..17, version(0): 112..115, match(0): [160..175, 74..79, 32..63, 288..303, 64..71, 304..367, 256..287, 176..191, 368..375, 192..215, 376..383, 216..239, 128..135 ] }
    match: [ ig_md.bd(0..7), ig_md.bd(8..15), ig_md.lkp.ip_src_addr.96-127(2..7), ig_md.lkp.ip_src_addr.96-127(8..15), ig_md.lkp.ip_src_addr.96-127(16..23), ig_md.lkp.ip_src_addr.96-127(24..31), ig_md.lkp.ip_src_addr.32-63(0..7), ig_md.lkp.ip_src_addr.32-63(8..15), ig_md.lkp.ip_src_addr.32-63(16..23), ig_md.lkp.ip_src_addr.32-63(24..31), ig_md.lkp.ip_src_addr.0-23(0..7), ig_md.lkp.ip_src_addr.0-23(8..15), ig_md.lkp.ip_src_addr.0-23(16..23), ig_md.lkp.ip_src_addr.64-95(0..7), ig_md.lkp.ip_src_addr.64-95(8..15), ig_md.lkp.ip_src_addr.64-95(16..23), ig_md.lkp.ip_src_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_dst_addr.32-63(8..15), ig_md.lkp.ip_dst_addr.32-63(16..23), ig_md.lkp.ip_dst_addr.32-63(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.64-95(8..15), ig_md.lkp.ip_dst_addr.64-95(16..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.96-127(8..15), ig_md.lkp.ip_dst_addr.96-127(16..23), ig_md.lkp.ip_dst_addr.96-127(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    gateway:
      name: cond-27
      input_xbar:
        exact group 0: { 58: ig_md.lkp.ip_type }
      row: 2
      bus: 0
      unit: 0
      match: { 2: ig_md.lkp.ip_type }
      0b****10: run_table
      miss:  multicast_fwd_result
      condition: 
        expression: "(ig_md.lkp.ip_type == 2)"
        true:  multicast_ipv6_multicast_bridge_s_g
        false:  multicast_fwd_result
    hit: [ [],  multicast_ipv6_multicast_bridge_star_g,  multicast_fwd_result ]
    miss:  multicast_fwd_result
    action_bus: { 44..45 : immediate(0..15) }
    instruction: multicast_ipv6_multicast_bridge_s_g(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x2000005b
      - next_table: 1
      - {  }
      SwitchIngress.multicast.ipv6_multicast_bridge.s_g_hit(2, 1):
      - p4_param_order: { mgid: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000005e
      - next_table: 2
      - { mgid: immediate(0..15) }
      - set ig_md.multicast.id, mgid
      - set multicast_multicast_hit, 1
    default_action: NoAction
  exact_match multicast_ipv6_multicast_bridge_star_g 6:
    p4: { name: SwitchIngress.multicast.ipv6_multicast_bridge.star_g, size: 512 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
      ig_md.lkp.ip_dst_addr: { type: exact, size: 128, full_size: 128, key_name: "grp_addr" }
    row: [ 3, 4 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4, 6 ]
    - [ 2, 3, 4, 6 ]
    stash: 
      row: [ 3, 4 ]
      col: [ 2, 2 ]
      unit: [ 0, 0 ]
    ways:
      - [4, 0, 0x0, [4, 2], [3, 2]]
      - [4, 1, 0x0, [4, 3], [3, 3]]
      - [4, 2, 0x0, [4, 4], [3, 4]]
      - [4, 3, 0x0, [4, 6], [3, 6]]
    input_xbar:
      exact group 4: { 0: ig_md.lkp.ip_dst_addr.32-63, 32: ig_md.lkp.ip_dst_addr.64-95, 64: ig_md.lkp.ip_dst_addr.96-127, 96: ig_md.lkp.ip_dst_addr.0-31 }
      exact group 5: { 0: ig_md.bd }
      hash 8:
        0..9: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
        10..19: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
        20..29: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
        30..39: random(ig_md.lkp.ip_dst_addr.32-63, ig_md.lkp.ip_dst_addr.64-95)
      hash 9:
        0..9: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        10..19: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        20..29: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
        30..39: random(ig_md.lkp.ip_dst_addr.96-127, ig_md.lkp.ip_dst_addr.0-31)
      hash 10:
        0..7: random(ig_md.bd(10..15)) ^ ig_md.bd(0..7)
        8..9: random(ig_md.bd(10..15)) ^ ig_md.bd(8..9)
        11..18: random(ig_md.bd(10..15)) ^ ig_md.bd(0..7)
        19: random(ig_md.bd(10..15)) ^ ig_md.bd(8)
        10: random(ig_md.bd(10..15)) ^ ig_md.bd(9)
        22..29: random(ig_md.bd(10..15)) ^ ig_md.bd(0..7)
        20..21: random(ig_md.bd(10..15)) ^ ig_md.bd(8..9)
        33..39: random(ig_md.bd(10..15)) ^ ig_md.bd(0..6)
        30: random(ig_md.bd(10..15)) ^ ig_md.bd(7)
        31..32: random(ig_md.bd(10..15)) ^ ig_md.bd(8..9)
      hash group 4:
        table: [8, 9, 10]
        seed: 0xf9f98597f7
    format: { action(0): 0..0, immediate(0): 1..16, version(0): 112..115, match(0): [34..39, 160..239, 128..159, 240..255 ] }
    match: [ ig_md.bd(10..15), ig_md.lkp.ip_dst_addr.32-63(0..7), ig_md.lkp.ip_dst_addr.32-63(8..15), ig_md.lkp.ip_dst_addr.32-63(16..23), ig_md.lkp.ip_dst_addr.32-63(24..31), ig_md.lkp.ip_dst_addr.64-95(0..7), ig_md.lkp.ip_dst_addr.64-95(8..15), ig_md.lkp.ip_dst_addr.64-95(16..23), ig_md.lkp.ip_dst_addr.64-95(24..31), ig_md.lkp.ip_dst_addr.96-127(0..7), ig_md.lkp.ip_dst_addr.96-127(8..15), ig_md.lkp.ip_dst_addr.96-127(16..23), ig_md.lkp.ip_dst_addr.96-127(24..31), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    hit: [  multicast_fwd_result ]
    miss:  multicast_fwd_result
    action_bus: { 48..49 : immediate(0..15) }
    instruction: multicast_ipv6_multicast_bridge_star_g(action, $DEFAULT)
    actions:
      SwitchIngress.multicast.ipv6_multicast_bridge.star_g_miss(0, 2):
      - default_action: { allowed: true }
      - handle: 0x2000005c
      - next_table: 0
      - {  }
      - set multicast_multicast_hit, 0
      SwitchIngress.multicast.ipv6_multicast_bridge.star_g_hit(1, 4):
      - p4_param_order: { mgid: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000005d
      - next_table: 0
      - { mgid: immediate(0..15) }
      - set ig_md.multicast.id, mgid
      - set multicast_multicast_hit, 1
    default_action: SwitchIngress.multicast.ipv6_multicast_bridge.star_g_miss
stage 5 ingress:
  atcam_match unicast_ipv4_fib_fib_lpm$atcam$lt0 1:
    p4: { name: SwitchIngress.unicast.ipv4_fib.fib_lpm, size: 16384, match_type: alpm }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: lpm, size: 32, full_size: 128, key_name: "dst_addr" }
    row: 7
    bus: 0
    column: [ 11, 10, 9, 8, 7 ]
    ways:
      - [0, 0, 0x0, [7, 11]]
      - [0, 0, 0x0, [7, 10]]
      - [0, 0, 0x0, [7, 9]]
      - [0, 0, 0x0, [7, 8]]
      - [0, 0, 0x0, [7, 7]]
    input_xbar:
      exact group 0: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.vrf, 51: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index }
      hash 0:
        0..4: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(0..4)
        5..9: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(5..9)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..16, version(0): 112..115, match(0): [32..39, 104..109, 40..103 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(8..13), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    number_partitions: 1024
    subtrees_per_partition: 2
    bins_per_partition: 17
    partition_field_name: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index
    hit: [  qos_policer_meter_index ]
    miss:  unicast_ipv4_fib_fib_lpm$atcam$lt1
    action_bus: { 96..99 : immediate(0..15) }
    instruction: unicast_ipv4_fib_fib_lpm$atcam$lt0(action, $DEFAULT)
    actions:
      SwitchIngress.unicast.ipv4_fib.fib_miss(0, 6):
      - default_action: { allowed: true }
      - handle: 0x20000041
      - next_table: 0
      - {  }
      - set ig_md.flags.routed, 0
      SwitchIngress.unicast.ipv4_fib.fib_hit(1, 8):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000042
      - next_table: 0
      - { nexthop_index: immediate(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.routed, 1
    default_action: SwitchIngress.unicast.ipv4_fib.fib_miss
  atcam_match unicast_ipv4_fib_fib_lpm$atcam$lt1 2:
    p4: { name: SwitchIngress.unicast.ipv4_fib.fib_lpm, size: 16384, match_type: alpm }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: lpm, size: 32, full_size: 128, key_name: "dst_addr" }
    row: 7
    search_bus: 0
    result_bus: 1
    column: [ 2, 3, 4, 5 ]
    ways:
      - [0, 0, 0x0, [7, 2]]
      - [0, 0, 0x0, [7, 3]]
      - [0, 0, 0x0, [7, 4]]
      - [0, 0, 0x0, [7, 5]]
    input_xbar:
      exact group 0: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.vrf, 51: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index }
      hash 0:
        0..4: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(0..4)
        5..9: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(5..9)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..16, version(0): 112..115, match(0): [32..39, 104..109, 40..103 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(8..13), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    number_partitions: 1024
    subtrees_per_partition: 2
    bins_per_partition: 17
    partition_field_name: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index
    hit: [  qos_policer_meter_index ]
    miss:  unicast_ipv4_fib_fib_lpm$atcam$lt2
    action_bus: { 96..99 : immediate(0..15) }
    instruction: unicast_ipv4_fib_fib_lpm$atcam$lt1(action, $DEFAULT)
    actions:
      SwitchIngress.unicast.ipv4_fib.fib_miss(0, 6):
      - default_action: { allowed: true }
      - handle: 0x20000041
      - next_table: 0
      - {  }
      - set ig_md.flags.routed, 0
      SwitchIngress.unicast.ipv4_fib.fib_hit(1, 8):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000042
      - next_table: 0
      - { nexthop_index: immediate(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.routed, 1
    default_action: SwitchIngress.unicast.ipv4_fib.fib_miss
  atcam_match unicast_ipv4_fib_fib_lpm$atcam$lt2 3:
    p4: { name: SwitchIngress.unicast.ipv4_fib.fib_lpm, size: 16384, match_type: alpm }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: lpm, size: 32, full_size: 128, key_name: "dst_addr" }
    row: 6
    bus: 0
    column: [ 10, 9, 8, 7 ]
    ways:
      - [0, 0, 0x0, [6, 10]]
      - [0, 0, 0x0, [6, 9]]
      - [0, 0, 0x0, [6, 8]]
      - [0, 0, 0x0, [6, 7]]
    input_xbar:
      exact group 0: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.vrf, 51: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index }
      hash 0:
        0..4: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(0..4)
        5..9: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(5..9)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..16, version(0): 112..115, match(0): [32..39, 104..109, 40..103 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(8..13), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    number_partitions: 1024
    subtrees_per_partition: 2
    bins_per_partition: 17
    partition_field_name: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index
    hit: [  qos_policer_meter_index ]
    miss:  unicast_ipv4_fib_fib_lpm$atcam$lt3
    action_bus: { 96..99 : immediate(0..15) }
    instruction: unicast_ipv4_fib_fib_lpm$atcam$lt2(action, $DEFAULT)
    actions:
      SwitchIngress.unicast.ipv4_fib.fib_miss(0, 6):
      - default_action: { allowed: true }
      - handle: 0x20000041
      - next_table: 0
      - {  }
      - set ig_md.flags.routed, 0
      SwitchIngress.unicast.ipv4_fib.fib_hit(1, 8):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000042
      - next_table: 0
      - { nexthop_index: immediate(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.routed, 1
    default_action: SwitchIngress.unicast.ipv4_fib.fib_miss
  atcam_match unicast_ipv4_fib_fib_lpm$atcam$lt3 4:
    p4: { name: SwitchIngress.unicast.ipv4_fib.fib_lpm, size: 16384, match_type: alpm }
    p4_param_order: 
      ig_md.vrf: { type: exact, size: 14, full_size: 14, key_name: "vrf" }
      ig_md.lkp.ip_dst_addr: { type: lpm, size: 32, full_size: 128, key_name: "dst_addr" }
    row: 6
    search_bus: 0
    result_bus: 1
    column: [ 2, 3, 4, 5 ]
    ways:
      - [0, 0, 0x0, [6, 2]]
      - [0, 0, 0x0, [6, 3]]
      - [0, 0, 0x0, [6, 4]]
      - [0, 0, 0x0, [6, 5]]
    input_xbar:
      exact group 0: { 0: ig_md.lkp.ip_dst_addr.0-31, 32: ig_md.vrf, 51: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index }
      hash 0:
        0..4: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(0..4)
        5..9: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index(5..9)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..16, version(0): 112..115, match(0): [32..39, 104..109, 40..103 ] }
    match: [ ig_md.vrf(0..7), ig_md.vrf(8..13), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(0..7), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(8..15), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(16..23), ig_md.lkp.ip_dst_addr.0-31(24..31), ig_md.lkp.ip_dst_addr.0-31(24..31) ]
    number_partitions: 1024
    subtrees_per_partition: 2
    bins_per_partition: 17
    partition_field_name: unicast_ipv4_fib_fib_lpm__metadata.unicast_ipv4_fib_fib_lpm_partition_index
    hit: [  qos_policer_meter_index ]
    miss:  qos_policer_meter_index
    action_bus: { 96..99 : immediate(0..15) }
    instruction: unicast_ipv4_fib_fib_lpm$atcam$lt3(action, $DEFAULT)
    actions:
      SwitchIngress.unicast.ipv4_fib.fib_miss(0, 6):
      - default_action: { allowed: true }
      - handle: 0x20000041
      - next_table: 0
      - {  }
      - set ig_md.flags.routed, 0
      SwitchIngress.unicast.ipv4_fib.fib_hit(1, 8):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000042
      - next_table: 0
      - { nexthop_index: immediate(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.routed, 1
    default_action: SwitchIngress.unicast.ipv4_fib.fib_miss
  ternary_match multicast_fwd_result 0:
    p4: { name: SwitchIngress.multicast.fwd_result }
    p4_param_order: 
      multicast_multicast_hit: { type: ternary, size: 1, full_size: 1, key_name: "multicast_hit" }
      ig_md.lkp.ip_type: { type: ternary, size: 2, full_size: 2, key_name: "lkp.ip_type" }
      ig_md.ipv4.multicast_snooping: { type: ternary, size: 1, full_size: 1 }
      ig_md.ipv6.multicast_snooping: { type: ternary, size: 1, full_size: 1 }
      ig_md.multicast.mode: { type: ternary, size: 2, full_size: 2 }
      multicast_rpf_check: { type: ternary, size: 16, full_size: 16, key_name: "rpf_check" }
    row: 10
    bus: 0
    column: 0
    input_xbar:
      ternary group 0: { 0: multicast_rpf_check(0..7), 10: ig_md.lkp.ip_type, 18: ig_md.ipv4.multicast_snooping, 21: ig_md.ipv6.multicast_snooping, 24: multicast_rpf_check(8..15), 36: ig_md.multicast.mode, 39: multicast_multicast_hit }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x155 }
    hit: [  qos_policer_meter_index ]
    miss:  qos_policer_meter_index
    indirect: multicast_fwd_result$tind
  ternary_indirect multicast_fwd_result$tind:
    row: 1
    bus: 1
    column: 3
    input_xbar:
      ternary group 0: { 0: multicast_rpf_check(0..7), 10: ig_md.lkp.ip_type, 18: ig_md.ipv4.multicast_snooping, 21: ig_md.ipv6.multicast_snooping, 24: multicast_rpf_check(8..15), 36: ig_md.multicast.mode, 39: multicast_multicast_hit }
    format: { action: 0..1, immediate: 2..3 }
    action_bus: { 0 : immediate(0..1) }
    instruction: multicast_fwd_result$tind(action, $DEFAULT)
    actions:
      SwitchIngress.multicast.set_multicast_bridge(0, 1):
      - p4_param_order: { mrpf: 1 }
      - default_action: { allowed: true }
      - handle: 0x2000005f
      - next_table: 0
      - { mrpf: immediate(0..0) }
      - set ig_md.egress_ifindex, 0
      - set ig_md.checks.mrpf, mrpf
      - set ig_md.flags.routed, 0
      SwitchIngress.multicast.set_multicast_route(1, 2):
      - default_action: { allowed: true }
      - handle: 0x20000060
      - next_table: 0
      - {  }
      - set ig_md.egress_ifindex, 0
      - set ig_md.checks.mrpf, 1
      - set ig_md.flags.routed, 1
      SwitchIngress.multicast.set_multicast_flood(2, 4):
      - p4_param_order: { mrpf: 1, flood: 1 }
      - default_action: { allowed: true }
      - handle: 0x20000061
      - next_table: 0
      - { $data0: immediate(0..1), flood: $data0(0..0), mrpf: $data0(1..1) }
      - set ig_md.egress_ifindex, 65535
      - set ig_md.flags.routed, 0
      - set B39(0..1), $data0
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000062
      - next_table: 0
      - {  }
    default_only_action: NoAction
  exact_match qos_policer_meter_index 5:
    p4: { name: SwitchIngress.qos.policer.meter_index, size: 1024 }
    p4_param_order: 
      ig_md.qos.meter_index: { type: exact, size: 10, full_size: 10, key_name: "qos_md.meter_index" }
    row: 2
    bus: 1
    column: 4
    stash: 
      row: [ 2 ]
      col: [ 4 ]
      unit: [ 0 ]
    ways:
      - [1, 0, 0x0, [2, 4]]
    input_xbar:
      exact group 0: { 67: ig_md.qos.meter_index }
      hash 1:
        0..4: ig_md.qos.meter_index(0..4)
        5..9: ig_md.qos.meter_index(5..9)
      hash group 1:
        table: [1]
        seed: 0x0
    format: { action(0): 0..0, version(0): 112..115 }
    gateway:
      name: cond-37
      input_xbar:
        exact group 0: { 85: ig_md.bypass(5) }
      row: 3
      bus: 1
      unit: 1
      match: { 5: ig_md.bypass(5) }
      0b**0: run_table
      miss:  storm_control_storm_control
      condition: 
        expression: "(ig_md.bypass & 32 == 0)"
        true:  qos_policer_meter_index
        false:  storm_control_storm_control
    hit: [  storm_control_storm_control ]
    miss:  storm_control_storm_control
    action_bus: { 3 : qos_policer_meter_index$meter.SwitchIngress.qos.policer.meter color }
    meter: qos_policer_meter_index$meter.SwitchIngress.qos.policer.meter($DIRECT, $DEFAULT, $DEFAULT)
    meter_color : qos_policer_meter_index$meter.SwitchIngress.qos.policer.meter($DIRECT, $DEFAULT)
    instruction: qos_policer_meter_index(action, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000084
      - next_table: 0
      SwitchIngress.qos.policer.set_color(1, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000085
      - next_table: 0
      - set ig_md.qos.acl_policer_color, qos_policer_meter_index$meter.SwitchIngress.qos.policer.meter color(0..1)
      - qos_policer_meter_index$meter.SwitchIngress.qos.policer.meter(2, $DIRECT)
    default_only_action: NoAction
  meter qos_policer_meter_index$meter.SwitchIngress.qos.policer.meter:
    p4: { name: SwitchIngress.qos.policer.meter }
    row: 11
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    color_maprams:
      row: 5
      bus: 1
      column: 2
      address: idletime
    type: standard
    count: bytes
  ternary_match storm_control_storm_control 10:
    p4: { name: SwitchIngress.storm_control.storm_control, size: 512 }
    p4_param_order: 
      ig_md.port: { type: exact, size: 9, full_size: 9 }
      ig_md.lkp.pkt_type: { type: ternary, size: 2, full_size: 2, key_name: "pkt_type" }
      ig_md.flags.dmac_miss: { type: ternary, size: 1, full_size: 1 }
    row: 11
    bus: 0
    column: 0
    input_xbar:
      ternary group 1: { 0: ig_md.port, 17: ig_md.lkp.pkt_type, 29: ig_md.flags.dmac_miss }
    match:
    - { group: 1, byte_config: 3, dirtcam: 0x55 }
    gateway:
      name: cond-39
      input_xbar:
        exact group 0: { 86: ig_md.bypass(6) }
      row: 2
      bus: 1
      unit: 1
      match: { 6: ig_md.bypass(6) }
      0b*0: run_table
      miss:  cond-29
      condition: 
        expression: "(ig_md.bypass & 64 == 0)"
        true:  storm_control_storm_control
        false:  cond-29
    hit: [  cond-29 ]
    miss:  cond-29
    indirect: storm_control_storm_control$tind
  meter storm_control_storm_control$meter.SwitchIngress.storm_control.meter:
    p4: { name: SwitchIngress.storm_control.meter, size: 512 }
    row: [ 15, 13 ]
    column:
    - 0
    - 0
    maprams: 
    - 0
    - 0
    color_maprams:
      row: 7
      bus: 0
      column: 1
      address: idletime
    type: standard
    count: bytes
    per_flow_enable: meter_pfe
  ternary_indirect storm_control_storm_control$tind:
    row: 0
    bus: 1
    column: 3
    input_xbar:
      ternary group 1: { 0: ig_md.port, 17: ig_md.lkp.pkt_type, 29: ig_md.flags.dmac_miss }
    format: { action: 0..0, meter_addr: 1..10, meter_pfe: 11..11, meter_type: 12..14 }
    action_bus: { 7 : storm_control_storm_control$meter.SwitchIngress.storm_control.meter color }
    meter: storm_control_storm_control$meter.SwitchIngress.storm_control.meter(meter_addr, meter_pfe, meter_type)
    meter_color : storm_control_storm_control$meter.SwitchIngress.storm_control.meter(meter_addr, meter_pfe)
    instruction: storm_control_storm_control$tind(action, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000008e
      - next_table: 0
      SwitchIngress.storm_control.set_meter(1, 5):
      - p4_param_order: { index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000008f
      - next_table: 0
      - { index: meter_addr }
      - set ig_md.qos.storm_control_color, storm_control_storm_control$meter.SwitchIngress.storm_control.meter color(0..1)
      - storm_control_storm_control$meter.SwitchIngress.storm_control.meter(2, index)
    default_only_action: NoAction
  gateway cond-29 11:
    name: cond-29
    input_xbar:
      exact group 0: { 82: ig_md.bypass(2) }
    row: 2
    bus: 0
    unit: 0
    match: { 2: ig_md.bypass(2) }
    0b*****0:  racl_ipv4_racl_acl
    miss:  cond-11
    condition: 
      expression: "(ig_md.bypass & 4 == 0)"
      true:  racl_ipv4_racl_acl
      false:  cond-11
  ternary_match racl_ipv4_racl_acl 12:
    p4: { name: SwitchIngress.racl.ipv4_racl.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.ip_src_addr: { type: ternary, size: 32, full_size: 128, key_name: "lkp.ip_src_addr" }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 32, full_size: 128, key_name: "lkp.ip_dst_addr" }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_proto" }
      ig_md.lkp.ip_tos: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_src_port" }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_dst_port" }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_ttl" }
      ig_md.lkp.ip_frag: { type: ternary, size: 2, full_size: 2, key_name: "lkp.ip_frag" }
      ig_md.lkp.tcp_flags: { type: ternary, size: 8, full_size: 8, key_name: "lkp.tcp_flags" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.bd_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.l4_port_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3, 4 ]
    bus: [ 1, 1, 1, 1, 1 ]
    column:
    - 1
    - 1
    - 1
    - 1
    - 1
    input_xbar:
      ternary group 2: { 0: ig_md.lkp.l4_dst_port(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(0..7), 16: ig_md.lkp.ip_proto, 24: ig_md.lkp.ip_dst_addr.0-31(16..23), 36: ig_md.lkp.ip_frag }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.l4_dst_port(0..7), 8: ig_md.port_lag_label(8..15), 16: ig_md.lkp.ip_tos, 24: ig_md.bd_label(8..15), 32: ig_md.lkp.ip_ttl }
      ternary group 5: { 0: ig_md.port_lag_label(0..7), 8: ig_md.lkp.l4_src_port.0-7, 16: ig_md.bd_label(0..7), 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 6: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    match:
    - { group: 2, byte_group: 3, byte_config: 0, dirtcam: 0x555 }
    - { group: 3, byte_group: 3, byte_config: 1, dirtcam: 0x555 }
    - { group: 4, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 5, byte_config: 3, dirtcam: 0x155 }
    - { group: 6, dirtcam: 0x5 }
    gateway:
      name: cond-30
      input_xbar:
        exact group 1: { 26: ig_md.lkp.ip_type }
      row: 4
      bus: 1
      unit: 1
      match: { 2: ig_md.lkp.ip_type }
      0b****01: run_table
      miss:  racl_ipv6_racl_acl
      condition: 
        expression: "(ig_md.lkp.ip_type == 1)"
        true:  racl_ipv4_racl_acl
        false:  racl_ipv6_racl_acl
    hit: [  cond-11 ]
    miss:  cond-11
    indirect: racl_ipv4_racl_acl$tind
  ternary_indirect racl_ipv4_racl_acl$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 2: { 0: ig_md.lkp.l4_dst_port(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(0..7), 16: ig_md.lkp.ip_proto, 24: ig_md.lkp.ip_dst_addr.0-31(16..23), 36: ig_md.lkp.ip_frag }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.l4_dst_port(0..7), 8: ig_md.port_lag_label(8..15), 16: ig_md.lkp.ip_tos, 24: ig_md.bd_label(8..15), 32: ig_md.lkp.ip_ttl }
      ternary group 5: { 0: ig_md.port_lag_label(0..7), 8: ig_md.lkp.l4_src_port.0-7, 16: ig_md.bd_label(0..7), 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 6: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    format: { action: 0..2, immediate: 3..14 }
    action_bus: { 1 : immediate(8..11), 100..103 : immediate(0..11) }
    instruction: racl_ipv4_racl_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000063
      - next_table: 0
      - {  }
      racl_deny(2, 7):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000064
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), stats_index.8-11: immediate(8..11) }
      - set ig_md.flags.racl_deny, 1
      - set racl_stats_index.0-7, stats_index.0-7
      - set racl_stats_index.8-11, stats_index.8-11
      racl_permit(3, 9):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000065
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), stats_index.8-11: immediate(8..11) }
      - set ig_md.flags.racl_deny, 0
      - set racl_stats_index.0-7, stats_index.0-7
      - set racl_stats_index.8-11, stats_index.8-11
      racl_redirect(4, 10):
      - p4_param_order: { stats_index: 12, nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000066
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), stats_index.8-11: immediate(8..11) }
      - set racl_stats_index.0-7, stats_index.0-7
      - set racl_stats_index.8-11, stats_index.8-11
    default_action: NoAction
  ternary_match racl_ipv6_racl_acl 13:
    p4: { name: SwitchIngress.racl.ipv6_racl.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.ip_src_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_src_addr" }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_dst_addr" }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_proto" }
      ig_md.lkp.ip_tos: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_src_port" }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_dst_port" }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_ttl" }
      ig_md.lkp.tcp_flags: { type: ternary, size: 8, full_size: 8, key_name: "lkp.tcp_flags" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.bd_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.l4_port_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    bus: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 2: { 0: ig_md.lkp.l4_dst_port(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(0..7), 16: ig_md.lkp.ip_proto, 24: ig_md.lkp.ip_dst_addr.0-31(16..23) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.l4_dst_port(0..7), 8: ig_md.port_lag_label(8..15), 16: ig_md.lkp.ip_tos, 24: ig_md.bd_label(8..15), 32: ig_md.lkp.ip_ttl }
      ternary group 5: { 0: ig_md.port_lag_label(0..7), 8: ig_md.lkp.l4_src_port.0-7, 16: ig_md.bd_label(0..7), 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 6: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15, 16: ig_md.lkp.ip_src_addr.96-127(24..31), 24: ig_md.lkp.ip_src_addr.96-127(0..15) }
      ternary group 7: { 0: ig_md.lkp.ip_src_addr.64-95(24..31), 8: ig_md.lkp.ip_src_addr.64-95(0..23), 32: ig_md.lkp.ip_dst_addr.32-63(24..31) }
      ternary group 8: { 0: ig_md.lkp.ip_dst_addr.32-63(0..23), 24: ig_md.lkp.ip_dst_addr.64-95(24..31), 32: ig_md.lkp.ip_dst_addr.64-95(0..7) }
      ternary group 9: { 0: ig_md.lkp.ip_src_addr.96-127(16..23), 8: ig_md.lkp.ip_src_addr.32-63(24..31), 16: ig_md.lkp.ip_src_addr.32-63(0..23) }
      ternary group 10: { 24: ig_md.lkp.ip_dst_addr.96-127(16..23) }
      ternary group 11: { 0: ig_md.lkp.ip_dst_addr.64-95(8..23), 16: ig_md.lkp.ip_dst_addr.96-127(24..31), 24: ig_md.lkp.ip_dst_addr.96-127(0..15) }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    match:
    - { group: 2, byte_group: 3, byte_config: 0, dirtcam: 0x455 }
    - { group: 3, byte_group: 3, byte_config: 1, dirtcam: 0x555 }
    - { group: 4, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 5, byte_config: 3, dirtcam: 0x155 }
    - { group: 6, dirtcam: 0x155 }
    - { group: 7, dirtcam: 0x155 }
    - { group: 8, dirtcam: 0x155 }
    - { group: 9, dirtcam: 0x155 }
    - { group: 10, dirtcam: 0x40 }
    - { group: 11, dirtcam: 0x155 }
    gateway:
      name: cond-31
      input_xbar:
        exact group 1: { 26: ig_md.lkp.ip_type }
      row: 4
      bus: 0
      unit: 0
      match: { 2: ig_md.lkp.ip_type }
      0b****10: run_table
      miss:  cond-11
      condition: 
        expression: "(ig_md.lkp.ip_type == 2)"
        true:  racl_ipv6_racl_acl
        false:  cond-11
    hit: [  cond-11 ]
    miss:  cond-11
    indirect: racl_ipv6_racl_acl$tind
  ternary_indirect racl_ipv6_racl_acl$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 2: { 0: ig_md.lkp.l4_dst_port(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(0..7), 16: ig_md.lkp.ip_proto, 24: ig_md.lkp.ip_dst_addr.0-31(16..23) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.l4_dst_port(0..7), 8: ig_md.port_lag_label(8..15), 16: ig_md.lkp.ip_tos, 24: ig_md.bd_label(8..15), 32: ig_md.lkp.ip_ttl }
      ternary group 5: { 0: ig_md.port_lag_label(0..7), 8: ig_md.lkp.l4_src_port.0-7, 16: ig_md.bd_label(0..7), 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 6: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15, 16: ig_md.lkp.ip_src_addr.96-127(24..31), 24: ig_md.lkp.ip_src_addr.96-127(0..15) }
      ternary group 7: { 0: ig_md.lkp.ip_src_addr.64-95(24..31), 8: ig_md.lkp.ip_src_addr.64-95(0..23), 32: ig_md.lkp.ip_dst_addr.32-63(24..31) }
      ternary group 8: { 0: ig_md.lkp.ip_dst_addr.32-63(0..23), 24: ig_md.lkp.ip_dst_addr.64-95(24..31), 32: ig_md.lkp.ip_dst_addr.64-95(0..7) }
      ternary group 9: { 0: ig_md.lkp.ip_src_addr.96-127(16..23), 8: ig_md.lkp.ip_src_addr.32-63(24..31), 16: ig_md.lkp.ip_src_addr.32-63(0..23) }
      ternary group 10: { 24: ig_md.lkp.ip_dst_addr.96-127(16..23) }
      ternary group 11: { 0: ig_md.lkp.ip_dst_addr.64-95(8..23), 16: ig_md.lkp.ip_dst_addr.96-127(24..31), 24: ig_md.lkp.ip_dst_addr.96-127(0..15) }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    format: { action: 0..2, immediate: 3..14 }
    action_bus: { 5 : immediate(8..11), 104..107 : immediate(0..11) }
    instruction: racl_ipv6_racl_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000067
      - next_table: 0
      - {  }
      racl_deny(2, 12):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000068
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), stats_index.8-11: immediate(8..11) }
      - set ig_md.flags.racl_deny, 1
      - set racl_stats_index.0-7, stats_index.0-7
      - set racl_stats_index.8-11, stats_index.8-11
      racl_permit(3, 14):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000069
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), stats_index.8-11: immediate(8..11) }
      - set ig_md.flags.racl_deny, 0
      - set racl_stats_index.0-7, stats_index.0-7
      - set racl_stats_index.8-11, stats_index.8-11
      racl_redirect(4, 16):
      - p4_param_order: { stats_index: 12, nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000006a
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), stats_index.8-11: immediate(8..11) }
      - set racl_stats_index.0-7, stats_index.0-7
      - set racl_stats_index.8-11, stats_index.8-11
    default_action: NoAction
  gateway cond-11 14:
    name: cond-11
    input_xbar:
      exact group 0: { 82: ig_md.bypass(2) }
    row: 0
    bus: 0
    unit: 0
    match: { 2: ig_md.bypass(2) }
    0b*****0:  acl_ipv6_acl_acl
    miss:  qos_policer_meter_action
    condition: 
      expression: "(ig_md.bypass & 4 == 0)"
      true:  acl_ipv6_acl_acl
      false:  qos_policer_meter_action
stage 6 ingress:
  ternary_match acl_ipv6_acl_acl 1:
    p4: { name: SwitchIngress.acl.ipv6_acl.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.ip_src_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_src_addr" }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_dst_addr" }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_proto" }
      ig_md.lkp.ip_tos: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_src_port" }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_dst_port" }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_ttl" }
      ig_md.lkp.tcp_flags: { type: ternary, size: 8, full_size: 8, key_name: "lkp.tcp_flags" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.bd_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.l4_port_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    bus: [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.ip_src_addr.96-127, 32: ig_md.lkp.ip_src_addr.32-63(0..7) }
      ternary group 1: { 0: ig_md.lkp.ip_src_addr.32-63(16..31), 16: ig_md.lkp.ip_src_addr.0-23(0..7), 24: ig_md.lkp.ip_src_addr.32-63(8..15), 32: ig_md.lkp.ip_src_addr.0-23(16..23) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..15), 8: ig_md.lkp.ip_src_addr.64-95(16..31), 24: ig_md.lkp.ip_src_addr.64-95(0..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.32-63(16..31), 16: ig_md.lkp.ip_dst_addr.32-63(0..15), 32: ig_md.lkp.ip_dst_addr.64-95(16..23) }
      ternary group 5: { 0: ig_md.lkp.ip_dst_addr.64-95(0..15), 16: ig_md.lkp.ip_dst_addr.96-127(16..23), 24: ig_md.lkp.ip_dst_addr.64-95(24..31), 32: ig_md.lkp.ip_dst_addr.96-127(0..7) }
      ternary group 6: { 0: ig_md.lkp.ip_dst_addr.96-127(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(16..23), 16: ig_md.lkp.ip_dst_addr.96-127(24..31), 24: ig_md.lkp.ip_dst_addr.0-31(0..15) }
      ternary group 7: { 0: ig_md.lkp.ip_dst_addr.0-31(24..31), 8: ig_md.lkp.l4_dst_port, 24: ig_md.lkp.ip_tos, 32: ig_md.lkp.ip_proto }
      ternary group 8: { 0: ig_md.lkp.ip_ttl, 8: ig_md.port_lag_label(8..15), 16: ig_md.port_lag_label(0..7), 24: ig_md.bd_label(8..15), 32: ig_md.bd_label(0..7) }
      ternary group 9: { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.tcp_flags, 24: ig_md.l4_port_label.0-7, 32: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    match:
    - { group: 0, byte_group: 3, byte_config: 0, dirtcam: 0x555 }
    - { group: 1, byte_group: 3, byte_config: 1, dirtcam: 0x555 }
    - { group: 3, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 4, byte_config: 3, dirtcam: 0x155 }
    - { group: 5, dirtcam: 0x155 }
    - { group: 6, dirtcam: 0x155 }
    - { group: 7, dirtcam: 0x155 }
    - { group: 8, dirtcam: 0x155 }
    - { group: 9, dirtcam: 0x155 }
    gateway:
      name: cond-12
      input_xbar:
        exact group 0: { 90: ig_md.lkp.ip_type }
      row: 1
      bus: 0
      unit: 0
      match: { 2: ig_md.lkp.ip_type }
      0b****10: run_table
      miss:  acl_ipv4_acl_acl
      condition: 
        expression: "(ig_md.lkp.ip_type == 2)"
        true:  acl_ipv6_acl_acl
        false:  acl_ipv4_acl_acl
    hit: [  qos_policer_meter_action ]
    miss:  qos_policer_meter_action
    indirect: acl_ipv6_acl_acl$tind
  ternary_indirect acl_ipv6_acl_acl$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: ig_md.lkp.ip_src_addr.96-127, 32: ig_md.lkp.ip_src_addr.32-63(0..7) }
      ternary group 1: { 0: ig_md.lkp.ip_src_addr.32-63(16..31), 16: ig_md.lkp.ip_src_addr.0-23(0..7), 24: ig_md.lkp.ip_src_addr.32-63(8..15), 32: ig_md.lkp.ip_src_addr.0-23(16..23) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..15), 8: ig_md.lkp.ip_src_addr.64-95(16..31), 24: ig_md.lkp.ip_src_addr.64-95(0..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.32-63(16..31), 16: ig_md.lkp.ip_dst_addr.32-63(0..15), 32: ig_md.lkp.ip_dst_addr.64-95(16..23) }
      ternary group 5: { 0: ig_md.lkp.ip_dst_addr.64-95(0..15), 16: ig_md.lkp.ip_dst_addr.96-127(16..23), 24: ig_md.lkp.ip_dst_addr.64-95(24..31), 32: ig_md.lkp.ip_dst_addr.96-127(0..7) }
      ternary group 6: { 0: ig_md.lkp.ip_dst_addr.96-127(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(16..23), 16: ig_md.lkp.ip_dst_addr.96-127(24..31), 24: ig_md.lkp.ip_dst_addr.0-31(0..15) }
      ternary group 7: { 0: ig_md.lkp.ip_dst_addr.0-31(24..31), 8: ig_md.lkp.l4_dst_port, 24: ig_md.lkp.ip_tos, 32: ig_md.lkp.ip_proto }
      ternary group 8: { 0: ig_md.lkp.ip_ttl, 8: ig_md.port_lag_label(8..15), 16: ig_md.port_lag_label(0..7), 24: ig_md.bd_label(8..15), 32: ig_md.bd_label(0..7) }
      ternary group 9: { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.tcp_flags, 24: ig_md.l4_port_label.0-7, 32: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    format: { action: 0..2, immediate: 3..15 }
    action_bus: { 1 : immediate(8..12), 32..33 : immediate(0..12) }
    instruction: acl_ipv6_acl_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x2000002d
      - next_table: 0
      - {  }
      ingress_acl_deny(2, 1):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000002e
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 1 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
      ingress_acl_permit(3, 2):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000002f
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 0 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
      ingress_acl_redirect(4, 4):
      - p4_param_order: { nexthop_index: 16, stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000030
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 0 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
    default_action: NoAction
  ternary_match acl_ipv4_acl_acl 2:
    p4: { name: SwitchIngress.acl.ipv4_acl.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.ip_src_addr: { type: ternary, size: 32, full_size: 128, key_name: "lkp.ip_src_addr" }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 32, full_size: 128, key_name: "lkp.ip_dst_addr" }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_proto" }
      ig_md.lkp.ip_tos: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_src_port" }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_dst_port" }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_ttl" }
      ig_md.lkp.ip_frag: { type: ternary, size: 2, full_size: 2, key_name: "lkp.ip_frag" }
      ig_md.lkp.tcp_flags: { type: ternary, size: 8, full_size: 8, key_name: "lkp.tcp_flags" }
      ig_md.lkp.mac_type: { type: ternary, size: 16, full_size: 16, key_name: "lkp.mac_type" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.bd_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.l4_port_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3, 4, 5 ]
    bus: [ 1, 1, 1, 1, 1, 1 ]
    column:
    - 1
    - 1
    - 1
    - 1
    - 1
    - 1
    input_xbar:
      ternary group 1: { 16: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_src_addr.0-23(16..23) }
      ternary group 2: { 0: ig_md.lkp.mac_type(8..15), 8: ig_md.lkp.mac_type(0..7), 16: ig_md.lkp.ip_src_addr.0-23(8..15), 36: ig_md.lkp.ip_frag }
      ternary group 6: { 8: ig_md.lkp.ip_dst_addr.0-31(16..23), 24: ig_md.lkp.ip_dst_addr.0-31(0..15) }
      ternary group 7: { 0: ig_md.lkp.ip_dst_addr.0-31(24..31), 8: ig_md.lkp.l4_dst_port, 24: ig_md.lkp.ip_tos, 32: ig_md.lkp.ip_proto }
      ternary group 8: { 0: ig_md.lkp.ip_ttl, 8: ig_md.port_lag_label(8..15), 16: ig_md.port_lag_label(0..7), 24: ig_md.bd_label(8..15), 32: ig_md.bd_label(0..7) }
      ternary group 9: { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.tcp_flags, 24: ig_md.l4_port_label.0-7, 32: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    match:
    - { group: 1, byte_group: 3, byte_config: 0, dirtcam: 0x510 }
    - { group: 2, byte_group: 3, byte_config: 1, dirtcam: 0x515 }
    - { group: 6, byte_group: 0, byte_config: 1, dirtcam: 0x544 }
    - { group: 7, byte_config: 3, dirtcam: 0x155 }
    - { group: 8, dirtcam: 0x155 }
    - { group: 9, dirtcam: 0x155 }
    gateway:
      name: cond-13
      input_xbar:
        exact group 0: { 90: ig_md.lkp.ip_type }
      row: 0
      bus: 1
      unit: 1
      match: { 2: ig_md.lkp.ip_type }
      0b****01: run_table
      miss:  qos_policer_meter_action
      condition: 
        expression: "(ig_md.lkp.ip_type == 1)"
        true:  acl_ipv4_acl_acl
        false:  qos_policer_meter_action
    hit: [  qos_policer_meter_action ]
    miss:  qos_policer_meter_action
    indirect: acl_ipv4_acl_acl$tind
  ternary_indirect acl_ipv4_acl_acl$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 16: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_src_addr.0-23(16..23) }
      ternary group 2: { 0: ig_md.lkp.mac_type(8..15), 8: ig_md.lkp.mac_type(0..7), 16: ig_md.lkp.ip_src_addr.0-23(8..15), 36: ig_md.lkp.ip_frag }
      ternary group 6: { 8: ig_md.lkp.ip_dst_addr.0-31(16..23), 24: ig_md.lkp.ip_dst_addr.0-31(0..15) }
      ternary group 7: { 0: ig_md.lkp.ip_dst_addr.0-31(24..31), 8: ig_md.lkp.l4_dst_port, 24: ig_md.lkp.ip_tos, 32: ig_md.lkp.ip_proto }
      ternary group 8: { 0: ig_md.lkp.ip_ttl, 8: ig_md.port_lag_label(8..15), 16: ig_md.port_lag_label(0..7), 24: ig_md.bd_label(8..15), 32: ig_md.bd_label(0..7) }
      ternary group 9: { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.tcp_flags, 24: ig_md.l4_port_label.0-7, 32: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    format: { action: 0..2, immediate: 3..15 }
    action_bus: { 5 : immediate(8..12), 36..37 : immediate(0..12) }
    instruction: acl_ipv4_acl_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000031
      - next_table: 0
      - {  }
      ingress_acl_deny(2, 6):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000032
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 1 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
      ingress_acl_permit(3, 8):
      - p4_param_order: { stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000033
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 0 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
      ingress_acl_redirect(4, 10):
      - p4_param_order: { nexthop_index: 16, stats_index: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000034
      - next_table: 0
      - { stats_index.0-7: immediate(0..7), $data0: immediate(8..12), stats_index.8-11: $data0(0..3), $constant0: $data0(4..4), $constant0: 0 }
      - set acl_stats_index.0-7, stats_index.0-7
      - set B7(3..7), $data0
    default_action: NoAction
  exact_match qos_policer_meter_action 3:
    p4: { name: SwitchIngress.qos.policer.meter_action, size: 3072 }
    p4_param_order: 
      ig_md.qos.acl_policer_color: { type: exact, size: 2, full_size: 2, key_name: "qos_md.acl_policer_color" }
      ig_md.qos.meter_index: { type: exact, size: 10, full_size: 10, key_name: "qos_md.meter_index" }
    row: [ 5, 4 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - 2
    stash: 
      row: [ 5 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [1, 0, 0x0, [5, 2]]
      - [1, 1, 0x0, [5, 3]]
      - [1, 2, 0x0, [5, 4]]
      - [1, 3, 0x0, [4, 2]]
    input_xbar:
      exact group 0: { 99: ig_md.qos.meter_index, 114: ig_md.qos.acl_policer_color }
      hash 1:
        0..4: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(0..4)
        5..7: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(5..7)
        8..9: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.acl_policer_color
        11..15: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(0..4)
        16..18: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(5..7)
        19: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.acl_policer_color(0)
        10: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.acl_policer_color(1)
        22..26: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(0..4)
        27..29: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(5..7)
        20..21: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.acl_policer_color
        33..37: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(0..4)
        38..39: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(5..6)
        30: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.meter_index(7)
        31..32: random(ig_md.qos.meter_index(8..9)) ^ ig_md.qos.acl_policer_color
      hash group 1:
        table: [1]
        seed: 0x6a30c36c3b
    format: { action(0): 0..1, version(0): 112..115, match(0): 35..36 }
    match: [ ig_md.qos.meter_index(8..9) ]
    gateway:
      name: cond-38
      input_xbar:
        exact group 1: { 5: ig_md.bypass(5) }
      row: 0
      bus: 0
      unit: 0
      match: { 5: ig_md.bypass(5) }
      0b**0: run_table
      miss:  tbl_compute_ip_hash
      condition: 
        expression: "(ig_md.bypass & 32 == 0)"
        true:  qos_policer_meter_action
        false:  tbl_compute_ip_hash
    hit: [  tbl_compute_ip_hash ]
    miss:  tbl_compute_ip_hash
    stats: qos_policer_meter_action$stats.SwitchIngress.qos.policer.stats($DIRECT, $DEFAULT)
    instruction: qos_policer_meter_action(action, $DEFAULT)
    actions:
      SwitchIngress.qos.policer.meter_permit(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000086
      - next_table: 0
      - qos_policer_meter_action$stats.SwitchIngress.qos.policer.stats($DIRECT)
      SwitchIngress.qos.policer.meter_deny(2, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000087
      - next_table: 0
      - set ig_md.qos.color, ig_md.qos.acl_policer_color
      - qos_policer_meter_action$stats.SwitchIngress.qos.policer.stats($DIRECT)
    default_action: SwitchIngress.qos.policer.meter_permit
  counter qos_policer_meter_action$stats.SwitchIngress.qos.policer.stats:
    p4: { name: SwitchIngress.qos.policer.stats }
    row: 13
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 379488784, interval: 23718144 }
    - { threshold: 379488784, interval: 23718144 }
    - { threshold: 379488784, interval: 23718144 }
  hash_action tbl_compute_ip_hash 4:
    p4: { name: tbl_compute_ip_hash }
    row: 0
    bus: 1
    hash_dist:
      1: { hash: 0, mask: 0xffff, shift: 0 }
      2: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 1: { 13: ig_md.lkp.ip_src_addr.24-31, 24: ig_md.lkp.ip_src_addr.96-127(24..31), 32: ig_md.lkp.ip_src_addr.96-127(0..23), 56: ig_md.lkp.ip_src_addr.32-63(24..31), 64: ig_md.lkp.ip_src_addr.32-63(0..23), 88: ig_md.lkp.ip_src_addr.64-95(24..31), 96: ig_md.lkp.ip_src_addr.0-23, 120: ig_md.lkp.ip_dst_addr.32-63(24..31) }
      exact group 2: { 0: ig_md.lkp.ip_src_addr.64-95(0..23), 24: ig_md.lkp.ip_dst_addr.64-95(24..31), 32: ig_md.lkp.ip_dst_addr.32-63(0..23), 56: ig_md.lkp.ip_dst_addr.96-127(24..31), 64: ig_md.lkp.ip_dst_addr.64-95(0..23), 88: ig_md.lkp.ip_dst_addr.0-31(24..31), 96: ig_md.lkp.ip_dst_addr.96-127(0..23), 120: ig_md.lkp.l4_dst_port(8..15) }
      exact group 3: { 0: ig_md.lkp.ip_dst_addr.0-31(0..23), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.l4_dst_port(0..7), 40: ig_md.lkp.l4_src_port.0-7, 48: ig_md.lkp.l4_src_port.8-15 }
      hash 2:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 192: ig_md.lkp.ip_src_addr.24-31, 224: ig_md.lkp.ip_src_addr.32-63(24..31), 264: ig_md.lkp.ip_src_addr.96-127(0..23), 288: ig_md.lkp.ip_src_addr.96-127(24..31) }, { })), 0..15)
      hash 3:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 96: ig_md.lkp.ip_dst_addr.32-63(24..31), 168: ig_md.lkp.ip_src_addr.0-23, 200: ig_md.lkp.ip_src_addr.32-63(0..23), 256: ig_md.lkp.ip_src_addr.64-95(24..31) }, { })), 0..15)
      hash 4:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 72: ig_md.lkp.ip_dst_addr.32-63(0..23), 128: ig_md.lkp.ip_dst_addr.64-95(24..31), 160: ig_md.lkp.ip_dst_addr.96-127(24..31), 232: ig_md.lkp.ip_src_addr.64-95(0..23) }, { })), 0..15)
      hash 5:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 24: ig_md.lkp.l4_dst_port(8..15), 64: ig_md.lkp.ip_dst_addr.0-31(24..31), 104: ig_md.lkp.ip_dst_addr.64-95(0..23), 136: ig_md.lkp.ip_dst_addr.96-127(0..23) }, { })), 0..15)
      hash 6:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.l4_dst_port(0..7), 32: ig_md.lkp.ip_proto, 40: ig_md.lkp.ip_dst_addr.0-31(0..23) }, { })), 0..15)
      hash group 0:
        table: [2, 3, 4, 5, 6]
        seed: 0x7f640000
      exact group 1: { 13: ig_md.lkp.ip_src_addr.24-31, 24: ig_md.lkp.ip_src_addr.96-127(24..31), 32: ig_md.lkp.ip_src_addr.96-127(0..23), 56: ig_md.lkp.ip_src_addr.32-63(24..31), 64: ig_md.lkp.ip_src_addr.32-63(0..23), 88: ig_md.lkp.ip_src_addr.64-95(24..31), 96: ig_md.lkp.ip_src_addr.0-23, 120: ig_md.lkp.ip_dst_addr.32-63(24..31) }
      exact group 2: { 0: ig_md.lkp.ip_src_addr.64-95(0..23), 24: ig_md.lkp.ip_dst_addr.64-95(24..31), 32: ig_md.lkp.ip_dst_addr.32-63(0..23), 56: ig_md.lkp.ip_dst_addr.96-127(24..31), 64: ig_md.lkp.ip_dst_addr.64-95(0..23), 88: ig_md.lkp.ip_dst_addr.0-31(24..31), 96: ig_md.lkp.ip_dst_addr.96-127(0..23), 120: ig_md.lkp.l4_dst_port(8..15) }
      exact group 3: { 0: ig_md.lkp.ip_dst_addr.0-31(0..23), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.l4_dst_port(0..7), 40: ig_md.lkp.l4_src_port.0-7, 48: ig_md.lkp.l4_src_port.8-15 }
      hash 2:
        32..47: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 192: ig_md.lkp.ip_src_addr.24-31, 224: ig_md.lkp.ip_src_addr.32-63(24..31), 264: ig_md.lkp.ip_src_addr.96-127(0..23), 288: ig_md.lkp.ip_src_addr.96-127(24..31) }, { })), 16..31)
      hash 3:
        32..47: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 96: ig_md.lkp.ip_dst_addr.32-63(24..31), 168: ig_md.lkp.ip_src_addr.0-23, 200: ig_md.lkp.ip_src_addr.32-63(0..23), 256: ig_md.lkp.ip_src_addr.64-95(24..31) }, { })), 16..31)
      hash 4:
        32..47: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 72: ig_md.lkp.ip_dst_addr.32-63(0..23), 128: ig_md.lkp.ip_dst_addr.64-95(24..31), 160: ig_md.lkp.ip_dst_addr.96-127(24..31), 232: ig_md.lkp.ip_src_addr.64-95(0..23) }, { })), 16..31)
      hash 5:
        32..47: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 24: ig_md.lkp.l4_dst_port(8..15), 64: ig_md.lkp.ip_dst_addr.0-31(24..31), 104: ig_md.lkp.ip_dst_addr.64-95(0..23), 136: ig_md.lkp.ip_dst_addr.96-127(0..23) }, { })), 16..31)
      hash 6:
        32..47: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 296, { 0: ig_md.lkp.l4_src_port.0-7, 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.l4_dst_port(0..7), 32: ig_md.lkp.ip_proto, 40: ig_md.lkp.ip_dst_addr.0-31(0..23) }, { })), 16..31)
      hash group 0:
        table: [2, 3, 4, 5, 6]
        seed: 0x24d100000000
    gateway:
      name: cond-33
      input_xbar:
        exact group 0: { 90: ig_md.lkp.ip_type }
      row: 4
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 2: ig_md.lkp.ip_type }
      0b****00: run_table
      miss:  nexthop_nexthop
      condition: 
        expression: "(ig_md.lkp.ip_type == 0)"
        true:  tbl_compute_non_ip_hash
        false:  nexthop_nexthop
    next:  tbl_compute_non_ip_hash
    action_bus: { 96..99 : hash_dist(1, 2) }
    instruction: tbl_compute_ip_hash(action, $DEFAULT)
    actions:
      compute_ip_hash(1, 5):
      - default_action: { allowed: true }
      - handle: 0x2000006d
      - next_table: 0
      - set W1, hash_dist(1, 2, 0..31)
    default_action: compute_ip_hash
  hash_action tbl_compute_non_ip_hash 5:
    p4: { name: tbl_compute_non_ip_hash }
    row: 0
    bus: 0
    hash_dist:
      3: { hash: 2, mask: 0xffff, shift: 0 }
      4: { hash: 2, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 4: { 0: ig_md.lkp.mac_dst_addr.16-47, 32: ig_md.lkp.mac_src_addr.16-47, 64: ig_md.lkp.mac_type, 80: ig_md.lkp.mac_src_addr.0-15, 96: ig_md.lkp.mac_dst_addr.0-15 }
      hash 8:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 112, { 16: ig_md.lkp.mac_dst_addr.16-47, 64: ig_md.lkp.mac_src_addr.16-47 }, { })), 0..15)
      hash 9:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 112, { 0: ig_md.lkp.mac_dst_addr.0-15, 48: ig_md.lkp.mac_src_addr.0-15, 96: ig_md.lkp.mac_type }, { })), 0..15)
      hash group 2:
        table: [8, 9]
        seed: 0x79c7
      exact group 4: { 0: ig_md.lkp.mac_dst_addr.16-47, 32: ig_md.lkp.mac_src_addr.16-47, 64: ig_md.lkp.mac_type, 80: ig_md.lkp.mac_src_addr.0-15, 96: ig_md.lkp.mac_dst_addr.0-15 }
      hash 8:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 112, { 16: ig_md.lkp.mac_dst_addr.16-47, 64: ig_md.lkp.mac_src_addr.16-47 }, { })), 16..31)
      hash 9:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 112, { 0: ig_md.lkp.mac_dst_addr.0-15, 48: ig_md.lkp.mac_src_addr.0-15, 96: ig_md.lkp.mac_type }, { })), 16..31)
      hash group 2:
        table: [8, 9]
        seed: 0xd1bb0000
    gateway:
      name: tbl_compute_non_ip_hash-gateway
      row: 1
      bus: 0
      unit: 1
      0x0:  nexthop_nexthop
      miss:  nexthop_nexthop
      condition: 
        expression: "true(always hit)"
        true:  nexthop_nexthop
        false:  nexthop_nexthop
    next: []
    action_bus: { 100..103 : hash_dist(3, 4) }
    instruction: tbl_compute_non_ip_hash($DEFAULT, $DEFAULT)
    actions:
      compute_non_ip_hash(0, 7):
      - default_action: { allowed: true }
      - handle: 0x2000006c
      - next_table: 0
      - set W1, hash_dist(3, 4, 0..31)
    default_action: compute_non_ip_hash
  exact_match nexthop_nexthop 6:
    p4: { name: SwitchIngress.nexthop.nexthop, size: 16384 }
    p4_param_order: 
      ig_md.nexthop: { type: exact, size: 16, full_size: 16 }
    row: [ 7, 6 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - [ 2, 3, 4 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [3, 0, 0x1, [7, 2], [7, 3]]
      - [3, 1, 0x2, [7, 4], [6, 2]]
      - [3, 2, 0x0, [6, 3]]
      - [3, 3, 0x0, [6, 4]]
    input_xbar:
      exact group 3: { 80: ig_md.nexthop }
      hash 7:
        0..7: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..7)
        8..9: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8..9)
        40: random(ig_md.nexthop(10..15))
        11..18: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..7)
        19: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8)
        10: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(9)
        41: random(ig_md.nexthop(10..15))
        22..29: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..7)
        20..21: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8..9)
        33..39: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..6)
        30: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(7)
        31..32: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8..9)
      hash group 3:
        table: [7]
        seed: 0x3d8e572ebf
    format: { action(0): 0..2, immediate(0): 9..24, version(0): 112..115, match(0): 58..63, action(1): 3..5, immediate(1): 25..40, version(1): 116..119, match(1): 66..71, action(2): 6..8, immediate(2): 41..56, version(2): 120..123, match(2): 74..79 }
    match: [ ig_md.nexthop(10..15) ]
    hit: [  nexthop_ecmp,  qos_traffic_class,  qos_traffic_class,  qos_traffic_class,  qos_traffic_class,  qos_traffic_class ]
    miss:  qos_traffic_class
    action_bus: { 40..41 : immediate(0..15) }
    instruction: nexthop_nexthop(action, $DEFAULT)
    actions:
      NoAction(0, 9):
      - default_action: { allowed: true }
      - handle: 0x2000006e
      - next_table: 0
      - {  }
      - set ig_md.flags.glean, 0
      SwitchIngress.nexthop.set_nexthop_properties(1, 11):
      - p4_param_order: { ifindex: 16, port_lag_index: 10, bd: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000074
      - next_table: 1
      - { ifindex: immediate(0..15) }
      - set ig_md.egress_ifindex, ifindex
      - set ig_md.flags.glean, 0
      SwitchIngress.nexthop.set_nexthop_properties_drop(2, 12):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000075
      - next_table: 2
      - {  }
      - set ig_md.drop_reason, 93
      - set ig_md.flags.glean, 0
      SwitchIngress.nexthop.set_nexthop_properties_glean(3, 14):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000076
      - next_table: 3
      - {  }
      - set ig_md.flags.glean, 1
      SwitchIngress.nexthop.set_nexthop_properties_post_routed_flood(4, 16):
      - p4_param_order: { bd: 16, mgid: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000077
      - next_table: 4
      - { mgid: immediate(0..15) }
      - set ig_md.egress_ifindex, 0
      - set ig_md.multicast.id, mgid
      - set ig_md.flags.glean, 0
      SwitchIngress.nexthop.set_tunnel_properties(5, 18):
      - p4_param_order: { bd: 16, tunnel_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000078
      - next_table: 5
      - {  }
      - set ig_md.egress_ifindex, 0
      - set ig_md.flags.glean, 0
    default_action: NoAction
stage 7 ingress:
  exact_match nexthop_ecmp 2:
    p4: { name: SwitchIngress.nexthop.ecmp, size: 1024, action_profile: SwitchIngress.nexthop.ecmp_selector }
    p4_param_order: 
      ig_md.nexthop: { type: exact, size: 16, full_size: 16 }
    row: [ 6, 5 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - 2
    stash: 
      row: [ 6 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [2, 0, 0x0, [6, 2]]
      - [2, 1, 0x0, [6, 3]]
      - [2, 2, 0x0, [6, 4]]
      - [2, 3, 0x0, [5, 2]]
    input_xbar:
      exact group 1: { 16: ig_md.nexthop }
      hash 2:
        0..7: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..7)
        8..9: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8..9)
        11..18: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..7)
        19: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8)
        10: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(9)
        22..29: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..7)
        20..21: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8..9)
        33..39: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(0..6)
        30: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(7)
        31..32: random(ig_md.nexthop(10..15)) ^ ig_md.nexthop(8..9)
      hash group 2:
        table: [2]
        seed: 0xd8f25a28e9
    format: { action(0): 0..2, version(0): 112..115, meter_addr(0): 3..12, meter_pfe(0): 13..13, action_addr(0): 14..28, match(0): 34..39 }
    match: [ ig_md.nexthop(10..15) ]
    hit: [  qos_traffic_class ]
    miss:  qos_traffic_class
    selector: nexthop_ecmp$selector.SwitchIngress.nexthop.ecmp_selector_sel(meter_addr, meter_pfe, $DEFAULT)
    selector_length: nexthop_ecmp$selector.SwitchIngress.nexthop.ecmp_selector_sel($DEFAULT, $DEFAULT)
    action: nexthop_ecmp$action_data.SwitchIngress.nexthop.ecmp_selector(action_addr, $DEFAULT)
    instruction: nexthop_ecmp(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x2000006f
      - next_table: 0
      - {  }
      SwitchIngress.nexthop.set_ecmp_properties(1, 1):
      - p4_param_order: { ifindex: 16, port_lag_index: 10, bd: 16, nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000070
      - next_table: 0
      - { nexthop_index: $adf_f0(0..15), ifindex: $adf_h1(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.egress_ifindex, ifindex
      SwitchIngress.nexthop.set_ecmp_properties_glean(2, 2):
      - p4_param_order: { nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000071
      - next_table: 0
      - { nexthop_index: $adf_f0(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.flags.glean, 1
      SwitchIngress.nexthop.set_ecmp_properties_post_routed_flood(3, 4):
      - p4_param_order: { bd: 16, mgid: 16, nexthop_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000072
      - next_table: 0
      - { nexthop_index: $adf_f0(0..15), mgid: $adf_h1(0..15) }
      - set ig_md.nexthop, nexthop_index
      - set ig_md.egress_ifindex, 0
      - set ig_md.multicast.id, mgid
      SwitchIngress.nexthop.set_tunnel_properties(4, 3):
      - p4_param_order: { bd: 16, tunnel_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000073
      - next_table: 0
      - {  }
      - set ig_md.egress_ifindex, 0
    default_action: NoAction
  selection nexthop_ecmp$selector.SwitchIngress.nexthop.ecmp_selector_sel:
    p4: { name: SwitchIngress.nexthop.ecmp_selector_sel, size: 4 }
    row: 11
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    input_xbar:
      exact group 1: { 64: ig_md.hash(0..15) }
      hash 3:
        0..13: ig_md.hash(0..13)
      hash group 3:
        table: [3]
        seed: 0x0
    mode: fair 0
    non_linear: true
    pool_sizes: [120]
  action nexthop_ecmp$action_data.SwitchIngress.nexthop.ecmp_selector:
    p4: { name: SwitchIngress.nexthop.ecmp_selector, size: 16384 }
    row: 11
    column: [ 2, 3, 4, 5 ]
    vpns: [ 0, 1, 2, 3 ]
    home_row:
    - 11
    format SwitchIngress.nexthop.set_ecmp_properties: { $adf_f0: 0..31, $adf_h1: 16..31 }
    format SwitchIngress.nexthop.set_ecmp_properties_glean: { $adf_f0: 0..31 }
    format SwitchIngress.nexthop.set_ecmp_properties_post_routed_flood: { $adf_f0: 0..31, $adf_h1: 16..31 }
    action_bus: { 34..35 : $adf_h1, 32..35 : $adf_f0 }
  stateful nexthop_ecmp$salu.SwitchIngress.nexthop.ecmp_selector_sel$salu:
    p4: { name: SwitchIngress.nexthop.ecmp_selector_sel$salu, size: 122880, hidden: true }
    selection_table: nexthop_ecmp$selector.SwitchIngress.nexthop.ecmp_selector_sel
    row: 11
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    format: { lo: 1 }
    actions:
      set_bit_at_alu$0:
      - set_bit_at
      clr_bit_at_alu$0:
      - clr_bit_at
  ternary_match qos_traffic_class 3:
    p4: { name: SwitchIngress.qos.traffic_class, size: 1024 }
    p4_param_order: 
      ig_md.port: { type: ternary, size: 9, full_size: 9, key_name: "port" }
      ig_md.qos.color: { type: ternary, size: 2, full_size: 2, key_name: "color" }
      ig_md.qos.tc: { type: exact, size: 8, full_size: 8, key_name: "tc" }
    row: [ 11, 5 ]
    bus: [ 0, 1 ]
    column:
    - 0
    - 1
    input_xbar:
      ternary group 0: { 0: ig_md.port, 16: ig_md.qos.tc, 24: ig_md.qos.color }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x55 }
    hit: [  smac_learning ]
    miss:  smac_learning
    indirect: qos_traffic_class$tind
  ternary_indirect qos_traffic_class$tind:
    row: 0
    bus: 1
    column: 3
    input_xbar:
      ternary group 0: { 0: ig_md.port, 16: ig_md.qos.tc, 24: ig_md.qos.color }
    format: { action: 0..1, immediate: 2..9 }
    action_bus: { 4 : immediate(0..7) }
    instruction: qos_traffic_class$tind(action, $DEFAULT)
    actions:
      SwitchIngress.qos.set_icos(0, 5):
      - p4_param_order: { icos: 3 }
      - default_action: { allowed: true }
      - handle: 0x20000088
      - next_table: 0
      - { icos: immediate(0..2) }
      - set ig_md.qos.icos, icos
      SwitchIngress.qos.set_queue(1, 6):
      - p4_param_order: { qid: 5 }
      - default_action: { allowed: true }
      - handle: 0x20000089
      - next_table: 0
      - { qid: immediate(0..4) }
      - set ig_md.qos.qid, qid
      SwitchIngress.qos.set_icos_and_queue(2, 8):
      - p4_param_order: { icos: 3, qid: 5 }
      - default_action: { allowed: true }
      - handle: 0x2000008a
      - next_table: 0
      - { icos: immediate(0..2), qid: immediate(3..7) }
      - set ig_md.qos.icos, icos
      - set ig_md.qos.qid, qid
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000008b
      - next_table: 0
      - {  }
    default_only_action: NoAction
  ternary_match smac_learning 4:
    p4: { name: SwitchIngress.smac.learning }
    p4_param_order: 
      smac_src_miss: { type: exact, size: 1, full_size: 1, key_name: "src_miss" }
      smac_src_move: { type: ternary, size: 16, full_size: 16, key_name: "src_move" }
    row: 6
    bus: 1
    column: 1
    input_xbar:
      ternary group 1: { 0: smac_src_move, 30: smac_src_miss }
    match:
    - { group: 1, byte_config: 3, dirtcam: 0x45 }
    gateway:
      name: cond-8
      input_xbar:
        exact group 0: { 110: ig_md.learning.bd_mode, 119: ig_md.learning.port_mode }
      row: 7
      bus: 0
      unit: 0
      match: { 6: ig_md.learning.bd_mode, 15: ig_md.learning.port_mode }
      0b1********1: run_table
      miss:  storm_control_stats
      condition: 
        expression: "(ig_md.learning.bd_mode == 1 && ig_md.learning.port_mode == 1)"
        true:  smac_learning
        false:  storm_control_stats
    hit: [  storm_control_stats ]
    miss:  storm_control_stats
    indirect: smac_learning$tind
  ternary_indirect smac_learning$tind:
    row: 3
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 0: smac_src_move, 30: smac_src_miss }
    format: { action: 0..1 }
    instruction: smac_learning$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000021
      - next_table: 0
      SwitchIngress.smac.notify(2, 7):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000022
      - next_table: 0
      - set ig_intr_md_for_dprsr.digest_type, 1
    default_action: NoAction
  ternary_match storm_control_stats 5:
    p4: { name: SwitchIngress.storm_control.stats, size: 512 }
    p4_param_order: 
      ig_md.qos.storm_control_color: { type: exact, size: 2, full_size: 2 }
      ig_md.lkp.pkt_type: { type: ternary, size: 2, full_size: 2, key_name: "pkt_type" }
      ig_md.port: { type: exact, size: 9, full_size: 9 }
      ig_md.flags.dmac_miss: { type: ternary, size: 1, full_size: 1 }
    row: 10
    bus: 0
    column: 0
    input_xbar:
      ternary group 2: { 0: ig_md.port(8), 8: ig_md.port(0..7), 21: ig_md.flags.dmac_miss, 25: ig_md.lkp.pkt_type, 37: ig_md.qos.storm_control_color }
    match:
    - { group: 2, byte_config: 3, dirtcam: 0x155 }
    gateway:
      name: cond-40
      input_xbar:
        exact group 1: { 6: ig_md.bypass(6) }
      row: 0
      bus: 1
      unit: 1
      match: { 6: ig_md.bypass(6) }
      0b*0: run_table
      miss:  tbl_act_9
      condition: 
        expression: "(ig_md.bypass & 64 == 0)"
        true:  storm_control_stats
        false:  tbl_act_9
    hit: [  tbl_act_9 ]
    miss:  tbl_act_9
    indirect: storm_control_stats$tind
  counter storm_control_stats$stats.SwitchIngress.storm_control.storm_control_stats:
    p4: { name: SwitchIngress.storm_control.storm_control_stats }
    row: 5
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
  ternary_indirect storm_control_stats$tind:
    row: 2
    bus: 0
    column: 2
    input_xbar:
      ternary group 2: { 0: ig_md.port(8), 8: ig_md.port(0..7), 21: ig_md.flags.dmac_miss, 25: ig_md.lkp.pkt_type, 37: ig_md.qos.storm_control_color }
    format: { action: 0..1 }
    stats: storm_control_stats$stats.SwitchIngress.storm_control.storm_control_stats($DIRECT, $DEFAULT)
    instruction: storm_control_stats$tind(action, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000090
      - next_table: 0
      SwitchIngress.storm_control.count(1, 9):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000091
      - next_table: 0
      - storm_control_stats$stats.SwitchIngress.storm_control.storm_control_stats($DIRECT)
      SwitchIngress.storm_control.drop_and_count(2, 10):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000092
      - next_table: 0
      - storm_control_stats$stats.SwitchIngress.storm_control.storm_control_stats($DIRECT)
    default_only_action: NoAction
  hash_action tbl_act_9 6:
    p4: { name: tbl_act_9 }
    row: 1
    bus: 1
    hash_dist:
      1: { hash: 0, mask: 0xfff, shift: 2 }
    input_xbar:
      exact group 0: { 16: racl_stats_index.8-11, 24: racl_stats_index.0-7 }
      hash 0:
        24..27: stripe(racl_stats_index.8-11)
        16..23: stripe(racl_stats_index.0-7)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: cond-32
      input_xbar:
        exact group 1: { 8: ig_md.flags.routed }
      row: 4
      bus: 0
      unit: 0
      payload: 0x3
      format: { action: 0..0, counter_pfe: 1..1 }
      match: { 0: ig_md.flags.routed }
      0b*******1:  cond-14
      miss: run_table
      condition: 
        expression: "(ig_md.flags.routed)"
        true:  cond-14
        false:  cond-14
    next:  cond-14
    stats: tbl_act_9$stats.SwitchIngress.racl.stats(hash_dist 1, counter_pfe)
    instruction: tbl_act_9(action, $DEFAULT)
    actions:
      act_9(1, 0):
      - default_action: { allowed: true }
      - handle: 0x2000006b
      - next_table: 0
      - tbl_act_9$stats.SwitchIngress.racl.stats($hash_dist)
    default_action: act_9
  counter tbl_act_9$stats.SwitchIngress.racl.stats:
    p4: { name: SwitchIngress.racl.stats, size: 1024 }
    row: 9
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 404246592, interval: 25265664 }
    - { threshold: 404246592, interval: 25265664 }
    - { threshold: 404246592, interval: 25265664 }
  gateway cond-14 7:
    name: cond-14
    input_xbar:
      exact group 1: { 2: ig_md.bypass(2) }
    row: 0
    bus: 0
    unit: 0
    match: { 2: ig_md.bypass(2) }
    0b*****0:  mirror_acl_ipv4_acl
    miss:  tbl_act_4
    condition: 
      expression: "(ig_md.bypass & 4 == 0)"
      true:  mirror_acl_ipv4_acl
      false:  tbl_act_4
  ternary_match mirror_acl_ipv4_acl 8:
    p4: { name: SwitchIngress.mirror_acl.ipv4.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.ip_src_addr: { type: ternary, size: 32, full_size: 128, key_name: "lkp.ip_src_addr" }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 32, full_size: 128, key_name: "lkp.ip_dst_addr" }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_proto" }
      ig_md.lkp.ip_tos: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_src_port" }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_dst_port" }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_ttl" }
      ig_md.lkp.ip_frag: { type: ternary, size: 2, full_size: 2, key_name: "lkp.ip_frag" }
      ig_md.lkp.tcp_flags: { type: ternary, size: 8, full_size: 8, key_name: "lkp.tcp_flags" }
      ig_md.lkp.mac_type: { type: ternary, size: 16, full_size: 16, key_name: "lkp.mac_type" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.l4_port_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3, 4 ]
    bus: [ 1, 1, 1, 1, 1 ]
    column:
    - 1
    - 1
    - 1
    - 1
    - 1
    input_xbar:
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.0-31(16..23), 8: ig_md.lkp.l4_dst_port(8..15), 16: ig_md.lkp.ip_dst_addr.0-31(0..7), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.l4_dst_port(0..7) }
      ternary group 5: { 0: ig_md.lkp.ip_tos, 8: ig_md.lkp.mac_type(8..15), 16: ig_md.lkp.ip_ttl, 28: ig_md.lkp.ip_frag, 32: ig_md.lkp.mac_type(0..7) }
      ternary group 6: { 0: ig_md.port_lag_label(8..15), 8: ig_md.port_lag_label(0..7), 16: ig_md.lkp.l4_src_port.0-7, 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 7: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    match:
    - { group: 3, byte_group: 3, byte_config: 0, dirtcam: 0x555 }
    - { group: 4, byte_group: 3, byte_config: 1, dirtcam: 0x555 }
    - { group: 5, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 6, byte_config: 3, dirtcam: 0x155 }
    - { group: 7, dirtcam: 0x5 }
    gateway:
      name: cond-15
      input_xbar:
        exact group 1: { 42: ig_md.lkp.ip_type }
      row: 6
      bus: 0
      unit: 0
      match: { 2: ig_md.lkp.ip_type }
      0b****01: run_table
      miss:  mirror_acl_ipv6_acl
      condition: 
        expression: "(ig_md.lkp.ip_type == 1)"
        true:  mirror_acl_ipv4_acl
        false:  mirror_acl_ipv6_acl
    hit: [  tbl_act_4 ]
    miss:  tbl_act_4
    indirect: mirror_acl_ipv4_acl$tind
  ternary_indirect mirror_acl_ipv4_acl$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.0-31(16..23), 8: ig_md.lkp.l4_dst_port(8..15), 16: ig_md.lkp.ip_dst_addr.0-31(0..7), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.l4_dst_port(0..7) }
      ternary group 5: { 0: ig_md.lkp.ip_tos, 8: ig_md.lkp.mac_type(8..15), 16: ig_md.lkp.ip_ttl, 28: ig_md.lkp.ip_frag, 32: ig_md.lkp.mac_type(0..7) }
      ternary group 6: { 0: ig_md.port_lag_label(8..15), 8: ig_md.port_lag_label(0..7), 16: ig_md.lkp.l4_src_port.0-7, 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 7: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    format: { action: 0..1, immediate: 2..23 }
    action_bus: { 1 : immediate(8..15), 36..37 : immediate(0..15), 96..99 : immediate(0..21) }
    instruction: mirror_acl_ipv4_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000036
      - next_table: 0
      - {  }
      ingress_acl_mirror(2, 11):
      - p4_param_order: { stats_index: 12, session_id: 10 }
      - default_action: { allowed: true }
      - handle: 0x20000037
      - next_table: 0
      - { session_id: immediate(0..9), stats_index.8-11: immediate(10..13), stats_index.0-7: immediate(14..21) }
      - set ig_md.mirror.src, 1
      - set ig_md.mirror.type, 1
      - set ig_md.mirror.session_id, session_id
      - set mirror_acl_stats_index.0-7, stats_index.0-7
      - set mirror_acl_stats_index.8-11, stats_index.8-11
    default_action: NoAction
  ternary_match mirror_acl_ipv6_acl 9:
    p4: { name: SwitchIngress.mirror_acl.ipv6.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.ip_src_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_src_addr" }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_dst_addr" }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_proto" }
      ig_md.lkp.ip_tos: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_src_port" }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_dst_port" }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_ttl" }
      ig_md.lkp.tcp_flags: { type: ternary, size: 8, full_size: 8, key_name: "lkp.tcp_flags" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.l4_port_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    bus: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 1: { 16: ig_md.lkp.ip_src_addr.96-127(0..7), 32: ig_md.lkp.ip_src_addr.32-63(16..23) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.0-31(16..23), 8: ig_md.lkp.l4_dst_port(8..15), 16: ig_md.lkp.ip_dst_addr.0-31(0..7), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.l4_dst_port(0..7) }
      ternary group 5: { 0: ig_md.lkp.ip_tos, 16: ig_md.lkp.ip_ttl }
      ternary group 6: { 0: ig_md.port_lag_label(8..15), 8: ig_md.port_lag_label(0..7), 16: ig_md.lkp.l4_src_port.0-7, 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 7: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15, 16: ig_md.lkp.ip_src_addr.96-127(8..31) }
      ternary group 8: { 0: ig_md.lkp.ip_src_addr.32-63(0..15), 16: ig_md.lkp.ip_src_addr.64-95(16..23), 24: ig_md.lkp.ip_src_addr.32-63(24..31), 32: ig_md.lkp.ip_src_addr.64-95(0..7) }
      ternary group 9: { 0: ig_md.lkp.ip_dst_addr.96-127(16..31), 16: ig_md.lkp.ip_dst_addr.96-127(0..15) }
      ternary group 10: { 0: ig_md.lkp.ip_src_addr.64-95(24..31), 8: ig_md.lkp.ip_dst_addr.32-63(0..7), 16: ig_md.lkp.ip_src_addr.64-95(8..15), 24: ig_md.lkp.ip_dst_addr.32-63(16..31) }
      ternary group 11: { 0: ig_md.lkp.ip_dst_addr.32-63(8..15), 8: ig_md.lkp.ip_dst_addr.64-95(16..31), 24: ig_md.lkp.ip_dst_addr.64-95(0..15) }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    match:
    - { group: 1, byte_group: 3, byte_config: 0, dirtcam: 0x510 }
    - { group: 3, byte_group: 3, byte_config: 1, dirtcam: 0x555 }
    - { group: 4, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 5, byte_config: 3, dirtcam: 0x11 }
    - { group: 6, dirtcam: 0x155 }
    - { group: 7, dirtcam: 0x155 }
    - { group: 8, dirtcam: 0x155 }
    - { group: 9, dirtcam: 0x55 }
    - { group: 10, dirtcam: 0x155 }
    - { group: 11, dirtcam: 0x155 }
    gateway:
      name: cond-16
      input_xbar:
        exact group 1: { 42: ig_md.lkp.ip_type }
      row: 5
      bus: 0
      unit: 1
      match: { 2: ig_md.lkp.ip_type }
      0b****10: run_table
      miss:  tbl_act_4
      condition: 
        expression: "(ig_md.lkp.ip_type == 2)"
        true:  mirror_acl_ipv6_acl
        false:  tbl_act_4
    hit: [  tbl_act_4 ]
    miss:  tbl_act_4
    indirect: mirror_acl_ipv6_acl$tind
  ternary_indirect mirror_acl_ipv6_acl$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 16: ig_md.lkp.ip_src_addr.96-127(0..7), 32: ig_md.lkp.ip_src_addr.32-63(16..23) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.0-23(8..23), 16: ig_md.lkp.ip_dst_addr.0-31(24..31), 24: ig_md.lkp.ip_src_addr.0-23(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.0-31(16..23), 8: ig_md.lkp.l4_dst_port(8..15), 16: ig_md.lkp.ip_dst_addr.0-31(0..7), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.l4_dst_port(0..7) }
      ternary group 5: { 0: ig_md.lkp.ip_tos, 16: ig_md.lkp.ip_ttl }
      ternary group 6: { 0: ig_md.port_lag_label(8..15), 8: ig_md.port_lag_label(0..7), 16: ig_md.lkp.l4_src_port.0-7, 24: ig_md.lkp.l4_src_port.8-15, 32: ig_md.lkp.tcp_flags }
      ternary group 7: { 0: ig_md.l4_port_label.0-7, 8: ig_md.l4_port_label.8-15, 16: ig_md.lkp.ip_src_addr.96-127(8..31) }
      ternary group 8: { 0: ig_md.lkp.ip_src_addr.32-63(0..15), 16: ig_md.lkp.ip_src_addr.64-95(16..23), 24: ig_md.lkp.ip_src_addr.32-63(24..31), 32: ig_md.lkp.ip_src_addr.64-95(0..7) }
      ternary group 9: { 0: ig_md.lkp.ip_dst_addr.96-127(16..31), 16: ig_md.lkp.ip_dst_addr.96-127(0..15) }
      ternary group 10: { 0: ig_md.lkp.ip_src_addr.64-95(24..31), 8: ig_md.lkp.ip_dst_addr.32-63(0..7), 16: ig_md.lkp.ip_src_addr.64-95(8..15), 24: ig_md.lkp.ip_dst_addr.32-63(16..31) }
      ternary group 11: { 0: ig_md.lkp.ip_dst_addr.32-63(8..15), 8: ig_md.lkp.ip_dst_addr.64-95(16..31), 24: ig_md.lkp.ip_dst_addr.64-95(0..15) }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
    format: { action: 0..1, immediate: 2..23 }
    action_bus: { 5 : immediate(8..15), 40..41 : immediate(0..15), 100..103 : immediate(0..21) }
    instruction: mirror_acl_ipv6_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000038
      - next_table: 0
      - {  }
      ingress_acl_mirror(2, 12):
      - p4_param_order: { stats_index: 12, session_id: 10 }
      - default_action: { allowed: true }
      - handle: 0x20000039
      - next_table: 0
      - { session_id: immediate(0..9), stats_index.8-11: immediate(10..13), stats_index.0-7: immediate(14..21) }
      - set ig_md.mirror.src, 1
      - set ig_md.mirror.type, 1
      - set ig_md.mirror.session_id, session_id
      - set mirror_acl_stats_index.0-7, stats_index.0-7
      - set mirror_acl_stats_index.8-11, stats_index.8-11
    default_action: NoAction
  hash_action tbl_act_4 10:
    p4: { name: tbl_act_4 }
    row: 0
    bus: 0
    hash_dist:
      2: { hash: 0, mask: 0xfff, shift: 2 }
    input_xbar:
      exact group 0: { 37: acl_stats_index.0-7, 51: acl_stats_index.8-11 }
      hash 0:
        32..39: stripe(acl_stats_index.0-7)
        40..43: stripe(acl_stats_index.8-11)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_act_4-gateway
      row: 1
      bus: 0
      unit: 1
      0x0:  dtel_mirror_session
      miss:  dtel_mirror_session
      condition: 
        expression: "true(always hit)"
        true:  dtel_mirror_session
        false:  dtel_mirror_session
    next: []
    stats: tbl_act_4$stats.SwitchIngress.acl.stats(hash_dist 2, $DEFAULT)
    instruction: tbl_act_4($DEFAULT, $DEFAULT)
    actions:
      act_4(0, 0):
      - default_action: { allowed: true }
      - handle: 0x20000035
      - next_table: 0
      - tbl_act_4$stats.SwitchIngress.acl.stats($hash_dist)
    default_action: act_4
  counter tbl_act_4$stats.SwitchIngress.acl.stats:
    p4: { name: SwitchIngress.acl.stats, size: 1536 }
    row: 13
    column: [ 3, 4 ]
    maprams: [ 3, 4 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 404246592, interval: 25265664 }
    - { threshold: 404246592, interval: 25265664 }
    - { threshold: 404246592, interval: 25265664 }
  ternary_match dtel_mirror_session 11:
    p4: { name: SwitchIngress.dtel.mirror_session, action_profile: SwitchIngress.dtel.session_selector }
    p4_param_order: 
    hit: [  qos_ppg ]
    miss:  qos_ppg
    indirect: dtel_mirror_session$tind
  selection dtel_mirror_session$selector.SwitchIngress.dtel.session_selector_sel:
    p4: { name: SwitchIngress.dtel.session_selector_sel, size: 4 }
    row: 7
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    input_xbar:
      exact group 2: { 0: ig_md.hash(0..15) }
      hash 4:
        0..13: ig_md.hash(0..13)
      hash group 4:
        table: [4]
        seed: 0x0
    mode: fair 0
    non_linear: true
    pool_sizes: [120]
  action dtel_mirror_session$action_data.SwitchIngress.dtel.session_selector:
    p4: { name: SwitchIngress.dtel.session_selector, size: 120 }
    row: 7
    column: 2
    vpns: [ 0 ]
    home_row:
    - 7
    format SwitchIngress.dtel.set_mirror_session: { $adf_h0: 0..15 }
    action_bus: { 44..45 : $adf_h0 }
  stateful dtel_mirror_session$salu.SwitchIngress.dtel.session_selector_sel$salu:
    p4: { name: SwitchIngress.dtel.session_selector_sel$salu, size: 122880, hidden: true }
    selection_table: dtel_mirror_session$selector.SwitchIngress.dtel.session_selector_sel
    row: 7
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    format: { lo: 1 }
    actions:
      set_bit_at_alu$0:
      - set_bit_at
      clr_bit_at_alu$0:
      - clr_bit_at
  ternary_indirect dtel_mirror_session$tind:
    row: 3
    bus: 1
    format: { action: 0..0, meter_addr: 1..10, meter_pfe: 11..11, action_addr: 12..22 }
    selector: dtel_mirror_session$selector.SwitchIngress.dtel.session_selector_sel(meter_addr, meter_pfe, $DEFAULT)
    selector_length: dtel_mirror_session$selector.SwitchIngress.dtel.session_selector_sel($DEFAULT, $DEFAULT)
    action: dtel_mirror_session$action_data.SwitchIngress.dtel.session_selector(action_addr, $DEFAULT)
    instruction: dtel_mirror_session$tind(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000a6
      - next_table: 0
      - {  }
      SwitchIngress.dtel.set_mirror_session(1, 13):
      - p4_param_order: { session_id: 10 }
      - default_action: { allowed: true }
      - handle: 0x200000a7
      - next_table: 0
      - { session_id: $adf_h0(0..9) }
      - set ig_md.dtel.session_id, session_id
    default_action: NoAction
stage 8 ingress:
  exact_match qos_ppg 0:
    p4: { name: SwitchIngress.qos.ppg, size: 1024 }
    p4_param_order: 
      ig_md.port: { type: exact, size: 9, full_size: 9, key_name: "port" }
      ig_md.qos.icos: { type: exact, size: 3, full_size: 3, key_name: "icos" }
    row: [ 5, 4 ]
    bus: [ 1, 0 ]
    column:
    - [ 3, 4, 6 ]
    - 2
    stash: 
      row: [ 4 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [0, 0, 0x0, [4, 2]]
      - [0, 1, 0x0, [5, 6]]
      - [0, 2, 0x0, [5, 4]]
      - [0, 3, 0x0, [5, 3]]
    input_xbar:
      exact group 0: { 0: ig_md.port, 18: ig_md.qos.icos }
      hash 0:
        0..5: random(ig_md.port(6..7)) ^ ig_md.port(0..5)
        6: random(ig_md.port(6..7)) ^ ig_md.port(8)
        7..9: random(ig_md.port(6..7)) ^ ig_md.qos.icos
        11..16: random(ig_md.port(6..7)) ^ ig_md.port(0..5)
        17: random(ig_md.port(6..7)) ^ ig_md.port(8)
        18..19: random(ig_md.port(6..7)) ^ ig_md.qos.icos(0..1)
        10: random(ig_md.port(6..7)) ^ ig_md.qos.icos(2)
        22..27: random(ig_md.port(6..7)) ^ ig_md.port(0..5)
        28: random(ig_md.port(6..7)) ^ ig_md.port(8)
        29: random(ig_md.port(6..7)) ^ ig_md.qos.icos(0)
        20..21: random(ig_md.port(6..7)) ^ ig_md.qos.icos(1..2)
        33..38: random(ig_md.port(6..7)) ^ ig_md.port(0..5)
        39: random(ig_md.port(6..7)) ^ ig_md.port(8)
        30..32: random(ig_md.port(6..7)) ^ ig_md.qos.icos
      hash group 0:
        table: [0]
        seed: 0x4941aea336
    format: { version(0): 112..115, match(0): 38..39 }
    match: [ ig_md.port(6..7) ]
    hit: [  dtel_dtel_acl_acl ]
    miss:  dtel_dtel_acl_acl
    stats: qos_ppg$stats.SwitchIngress.qos.ppg_stats($DIRECT, $DEFAULT)
    instruction: qos_ppg($DEFAULT, $DEFAULT)
    actions:
      NoAction(-1, 1):
      - default_only_action: { allowed: true }
      - handle: 0x2000008c
      - next_table: 0
      - set hdr.bridged_md.base_cpu_reason, 0
      - set ig_intr_md_for_tm.copy_to_cpu, 0
      - set ig_intr_md_for_tm.packet_color, 0
      - set ig_intr_md_for_dprsr.drop_ctl, 0
      - set system_acl_copp_meter_id, 0
      SwitchIngress.qos.count(0, 2):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000008d
      - next_table: 0
      - set hdr.bridged_md.base_cpu_reason, 0
      - set ig_intr_md_for_tm.copy_to_cpu, 0
      - set ig_intr_md_for_tm.packet_color, 0
      - set ig_intr_md_for_dprsr.drop_ctl, 0
      - set system_acl_copp_meter_id, 0
      - qos_ppg$stats.SwitchIngress.qos.ppg_stats($DIRECT)
    default_only_action: NoAction
  counter qos_ppg$stats.SwitchIngress.qos.ppg_stats:
    p4: { name: SwitchIngress.qos.ppg_stats }
    row: 9
    column: [ 2, 3, 4 ]
    maprams: [ 2, 3, 4 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 379488784, interval: 23718144 }
    - { threshold: 379488784, interval: 23718144 }
    - { threshold: 379488784, interval: 23718144 }
  ternary_match dtel_dtel_acl_acl 4:
    p4: { name: SwitchIngress.dtel.dtel_acl.acl, size: 512 }
    p4_param_order: 
      ig_md.lkp.mac_type: { type: ternary, size: 16, full_size: 16, key_name: "lkp.mac_type" }
      ig_md.lkp.ip_src_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_src_addr" }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 128, full_size: 128, key_name: "lkp.ip_dst_addr" }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_proto" }
      ig_md.lkp.ip_tos: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_tos" }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_src_port" }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16, key_name: "lkp.l4_dst_port" }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8, key_name: "lkp.ip_ttl" }
      ig_md.lkp.tcp_flags: { type: ternary, size: 8, full_size: 8, key_name: "lkp.tcp_flags" }
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.bd_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.l4_port_label: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    bus: [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 1: { 0: ig_md.lkp.ip_src_addr.96-127(16..31), 16: ig_md.lkp.ip_src_addr.32-63(0..23) }
      ternary group 2: { 0: ig_md.lkp.ip_src_addr.32-63(24..31), 8: ig_md.lkp.ip_src_addr.0-23, 32: ig_md.lkp.ip_src_addr.64-95(24..31) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.64-95(8..23), 16: ig_md.lkp.ip_dst_addr.32-63(24..31), 24: ig_md.lkp.ip_src_addr.64-95(0..7), 32: ig_md.lkp.ip_dst_addr.32-63(8..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.32-63(16..23), 8: ig_md.lkp.ip_dst_addr.64-95(24..31), 16: ig_md.lkp.ip_dst_addr.32-63(0..7), 24: ig_md.lkp.ip_dst_addr.64-95(8..23) }
      ternary group 5: { 0: ig_md.lkp.ip_dst_addr.64-95(0..7), 8: ig_md.lkp.ip_dst_addr.96-127(8..31), 32: ig_md.lkp.ip_dst_addr.96-127(0..7) }
      ternary group 6: { 0: ig_md.lkp.ip_dst_addr.0-31(8..31), 24: ig_md.lkp.ip_dst_addr.0-31(0..7), 32: ig_md.lkp.l4_dst_port(8..15) }
      ternary group 7: { 0: ig_md.lkp.ip_proto, 8: ig_md.lkp.l4_dst_port(0..7), 16: ig_md.lkp.mac_type(8..15), 24: ig_md.lkp.ip_tos, 32: ig_md.port_lag_label(8..15) }
      ternary group 8: { 0: ig_md.lkp.ip_ttl, 8: ig_md.bd_label(8..15), 16: ig_md.lkp.mac_type(0..7), 24: ig_md.lkp.l4_src_port.0-7, 32: ig_md.port_lag_label(0..7) }
      ternary group 9: { 0: ig_md.bd_label(0..7), 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.tcp_flags, 24: ig_md.l4_port_label.0-7, 32: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 1: { 0: ig_md.lkp.ip_src_addr.96-127(0..7) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
      byte group 4: { 0: ig_md.lkp.ip_src_addr.96-127(8..15) }
    match:
    - { group: 1, byte_group: 1, byte_config: 0, dirtcam: 0x555 }
    - { group: 2, byte_group: 1, byte_config: 1, dirtcam: 0x555 }
    - { group: 3, byte_group: 3, byte_config: 0, dirtcam: 0x555 }
    - { group: 4, byte_group: 3, byte_config: 1, dirtcam: 0x555 }
    - { group: 5, byte_group: 4, byte_config: 0, dirtcam: 0x555 }
    - { group: 6, byte_group: 4, byte_config: 1, dirtcam: 0x555 }
    - { group: 7, byte_group: 0, byte_config: 1, dirtcam: 0x555 }
    - { group: 8, byte_config: 3, dirtcam: 0x155 }
    - { group: 9, dirtcam: 0x155 }
    gateway:
      name: cond-43
      input_xbar:
        exact group 1: { 114: ig_md.bypass(2) }
      row: 0
      bus: 1
      unit: 1
      match: { 2: ig_md.bypass(2) }
      0b*****0: run_table
      miss:  lag_lag
      condition: 
        expression: "(ig_md.bypass & 4 == 0)"
        true:  dtel_dtel_acl_acl
        false:  lag_lag
    hit: [  lag_lag ]
    miss:  lag_lag
    indirect: dtel_dtel_acl_acl$tind
  ternary_indirect dtel_dtel_acl_acl$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 0: ig_md.lkp.ip_src_addr.96-127(16..31), 16: ig_md.lkp.ip_src_addr.32-63(0..23) }
      ternary group 2: { 0: ig_md.lkp.ip_src_addr.32-63(24..31), 8: ig_md.lkp.ip_src_addr.0-23, 32: ig_md.lkp.ip_src_addr.64-95(24..31) }
      ternary group 3: { 0: ig_md.lkp.ip_src_addr.64-95(8..23), 16: ig_md.lkp.ip_dst_addr.32-63(24..31), 24: ig_md.lkp.ip_src_addr.64-95(0..7), 32: ig_md.lkp.ip_dst_addr.32-63(8..15) }
      ternary group 4: { 0: ig_md.lkp.ip_dst_addr.32-63(16..23), 8: ig_md.lkp.ip_dst_addr.64-95(24..31), 16: ig_md.lkp.ip_dst_addr.32-63(0..7), 24: ig_md.lkp.ip_dst_addr.64-95(8..23) }
      ternary group 5: { 0: ig_md.lkp.ip_dst_addr.64-95(0..7), 8: ig_md.lkp.ip_dst_addr.96-127(8..31), 32: ig_md.lkp.ip_dst_addr.96-127(0..7) }
      ternary group 6: { 0: ig_md.lkp.ip_dst_addr.0-31(8..31), 24: ig_md.lkp.ip_dst_addr.0-31(0..7), 32: ig_md.lkp.l4_dst_port(8..15) }
      ternary group 7: { 0: ig_md.lkp.ip_proto, 8: ig_md.lkp.l4_dst_port(0..7), 16: ig_md.lkp.mac_type(8..15), 24: ig_md.lkp.ip_tos, 32: ig_md.port_lag_label(8..15) }
      ternary group 8: { 0: ig_md.lkp.ip_ttl, 8: ig_md.bd_label(8..15), 16: ig_md.lkp.mac_type(0..7), 24: ig_md.lkp.l4_src_port.0-7, 32: ig_md.port_lag_label(0..7) }
      ternary group 9: { 0: ig_md.bd_label(0..7), 8: ig_md.lkp.l4_src_port.8-15, 16: ig_md.lkp.tcp_flags, 24: ig_md.l4_port_label.0-7, 32: ig_md.l4_port_label.8-15 }
      byte group 0: { 5: ig_md.lkp.ip_src_addr.24-31(0..2) }
      byte group 1: { 0: ig_md.lkp.ip_src_addr.96-127(0..7) }
      byte group 3: { 0: ig_md.lkp.ip_src_addr.24-31(3..7) }
      byte group 4: { 0: ig_md.lkp.ip_src_addr.96-127(8..15) }
    format: { action: 0..0 }
    action: dtel_dtel_acl_acl$action_data($DIRECT, $DEFAULT)
    instruction: dtel_dtel_acl_acl$tind(action, $DEFAULT)
    actions:
      SwitchIngress.dtel.dtel_acl.acl_hit(1, 3):
      - p4_param_order: { type: 4 }
      - default_action: { allowed: true }
      - handle: 0x200000a1
      - next_table: 0
      - { type: $adf_b0(0..3) }
      - set ig_md.dtel.report_type, type
    default_action: SwitchIngress.dtel.dtel_acl.acl_hit
    default_action_parameters:
      type: "0x0"
  action dtel_dtel_acl_acl$action_data:
    p4: { name: SwitchIngress.dtel.dtel_acl.acl$action }
    row: 15
    column: 3
    vpns: [ 0 ]
    home_row:
    - 15
    format SwitchIngress.dtel.dtel_acl.acl_hit: { $adf_b0: 0..7 }
    action_bus: { 0 : $adf_b0 }
  exact_match lag_lag 5:
    p4: { name: SwitchIngress.lag.lag, size: 1024, action_profile: SwitchIngress.lag.lag_selector }
    p4_param_order: 
      ig_md.egress_ifindex: { type: exact, size: 16, full_size: 16, key_name: "port_lag_index" }
    row: 6
    bus: 0
    column: [ 2, 3, 4, 6 ]
    stash: 
      row: [ 6 ]
      col: [ 6 ]
      unit: [ 0 ]
    ways:
      - [4, 0, 0x0, [6, 6]]
      - [4, 1, 0x0, [6, 4]]
      - [4, 2, 0x0, [6, 3]]
      - [4, 3, 0x0, [6, 2]]
    input_xbar:
      exact group 2: { 0: ig_md.egress_ifindex }
      hash 4:
        0..7: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(0..7)
        8..9: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(8..9)
        11..18: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(0..7)
        19: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(8)
        10: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(9)
        22..29: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(0..7)
        20..21: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(8..9)
        33..39: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(0..6)
        30: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(7)
        31..32: random(ig_md.egress_ifindex(10..15)) ^ ig_md.egress_ifindex(8..9)
      hash group 4:
        table: [4]
        seed: 0xa5a3bdf549
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 2..11, meter_pfe(0): 12..12, action_addr(0): 13..23, match(0): 34..39 }
    match: [ ig_md.egress_ifindex(10..15) ]
    gateway:
      name: cond-41
      input_xbar:
        exact group 2: { 0: ig_md.egress_ifindex }
      row: 2
      bus: 0
      unit: 0
      match: { 0: ig_md.egress_ifindex(0..7), 8: ig_md.egress_ifindex(8..15) }
      0xffff:  flood_bd_flood
      miss: run_table
      condition: 
        expression: "(ig_md.egress_ifindex == 65535)"
        true:  flood_bd_flood
        false:  lag_lag
    hit: [  tbl_act_5 ]
    miss:  tbl_act_5
    selector: lag_lag$selector.SwitchIngress.lag.lag_selector_sel(meter_addr, meter_pfe, $DEFAULT)
    selector_length: lag_lag$selector.SwitchIngress.lag.lag_selector_sel($DEFAULT, $DEFAULT)
    action: lag_lag$action_data.SwitchIngress.lag.lag_selector(action_addr, $DEFAULT)
    instruction: lag_lag(action, $DEFAULT)
    actions:
      SwitchIngress.lag.lag_miss(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000095
      - next_table: 0
      - {  }
      SwitchIngress.lag.set_lag_port(2, 4):
      - p4_param_order: { port: 9 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000096
      - next_table: 0
      - { port: $adf_h0(0..8) }
      - set ig_intr_md_for_tm.ucast_egress_port, port
      SwitchIngress.lag.set_peer_link_port(3, 5):
      - p4_param_order: { port: 9, ifindex: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000097
      - next_table: 0
      - {  }
    default_action: SwitchIngress.lag.lag_miss
  selection lag_lag$selector.SwitchIngress.lag.lag_selector_sel:
    p4: { name: SwitchIngress.lag.lag_selector_sel, size: 4 }
    row: 15
    column: [ 1, 2 ]
    maprams: [ 1, 2 ]
    input_xbar:
      exact group 2: { 80: ig_md.hash(16..31) }
      hash 5:
        0..13: ig_md.hash(16..29)
      hash group 5:
        table: [5]
        seed: 0x0
    mode: fair 0
    non_linear: true
    pool_sizes: [120]
  action lag_lag$action_data.SwitchIngress.lag.lag_selector:
    p4: { name: SwitchIngress.lag.lag_selector, size: 1024 }
    row: 10
    column: 5
    vpns: [ 0 ]
    home_row:
    - 10
    format SwitchIngress.lag.set_lag_port: { $adf_h0: 0..15 }
    action_bus: { 40..41 : $adf_h0 }
  stateful lag_lag$salu.SwitchIngress.lag.lag_selector_sel$salu:
    p4: { name: SwitchIngress.lag.lag_selector_sel$salu, size: 122880, hidden: true }
    selection_table: lag_lag$selector.SwitchIngress.lag.lag_selector_sel
    row: 15
    column: [ 1, 2 ]
    maprams: [ 1, 2 ]
    format: { lo: 1 }
    actions:
      set_bit_at_alu$0:
      - set_bit_at
      clr_bit_at_alu$0:
      - clr_bit_at
  exact_match flood_bd_flood 6:
    p4: { name: SwitchIngress.flood.bd_flood, size: 16384 }
    p4_param_order: 
      ig_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
      ig_md.lkp.pkt_type: { type: exact, size: 2, full_size: 2, key_name: "pkt_type" }
      ig_md.flags.flood_to_multicast_routers: { type: exact, size: 1, full_size: 1, key_name: "flood_to_multicast_routers" }
    row: [ 7, 2 ]
    bus: [ 0, 1 ]
    column:
    - [ 2, 3, 4, 6 ]
    - [ 3, 4 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [6, 0, 0x1, [7, 2], [7, 3]]
      - [6, 1, 0x2, [7, 4], [7, 6]]
      - [6, 2, 0x0, [2, 4]]
      - [6, 3, 0x0, [2, 3]]
    input_xbar:
      exact group 3: { 0: ig_md.bd, 16: ig_md.flags.flood_to_multicast_routers, 25: ig_md.lkp.pkt_type }
      hash 6:
        0..6: random(ig_md.bd(7..15)) ^ ig_md.bd(0..6)
        7: random(ig_md.bd(7..15)) ^ ig_md.flags.flood_to_multicast_routers
        8..9: random(ig_md.bd(7..15)) ^ ig_md.lkp.pkt_type
        40: random(ig_md.bd(7..15))
        11..17: random(ig_md.bd(7..15)) ^ ig_md.bd(0..6)
        18: random(ig_md.bd(7..15)) ^ ig_md.flags.flood_to_multicast_routers
        19: random(ig_md.bd(7..15)) ^ ig_md.lkp.pkt_type(0)
        10: random(ig_md.bd(7..15)) ^ ig_md.lkp.pkt_type(1)
        41: random(ig_md.bd(7..15))
        22..28: random(ig_md.bd(7..15)) ^ ig_md.bd(0..6)
        29: random(ig_md.bd(7..15)) ^ ig_md.flags.flood_to_multicast_routers
        20..21: random(ig_md.bd(7..15)) ^ ig_md.lkp.pkt_type
        33..39: random(ig_md.bd(7..15)) ^ ig_md.bd(0..6)
        30: random(ig_md.bd(7..15)) ^ ig_md.flags.flood_to_multicast_routers
        31..32: random(ig_md.bd(7..15)) ^ ig_md.lkp.pkt_type
      hash group 6:
        table: [6]
        seed: 0x37c9d099d15
    format: { immediate(0): 0..15, version(0): 112..115, match(0): [63..63, 48..55 ], immediate(1): 16..31, version(1): 116..119, match(1): [79..79, 64..71 ], immediate(2): 32..47, version(2): 120..123, match(2): [95..95, 80..87 ] }
    match: [ ig_md.bd(7), ig_md.bd(8..15) ]
    hit: [  tbl_act_5 ]
    miss:  tbl_act_5
    action_bus: { 44..45 : immediate(0..15) }
    instruction: flood_bd_flood($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.flood.flood(0, 6):
      - p4_param_order: { mgid: 16 }
      - default_action: { allowed: true }
      - handle: 0x20000093
      - next_table: 0
      - { mgid: immediate(0..15) }
      - set ig_md.multicast.id, mgid
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000094
      - next_table: 0
      - {  }
    default_only_action: NoAction
  hash_action tbl_act_5 7:
    p4: { name: tbl_act_5 }
    row: 0
    bus: 0
    hash_dist:
      1: { hash: 2, mask: 0xfff, shift: 2 }
    input_xbar:
      exact group 1: { 21: mirror_acl_stats_index.0-7, 36: mirror_acl_stats_index.8-11 }
      hash 2:
        16..23: stripe(mirror_acl_stats_index.0-7)
        24..27: stripe(mirror_acl_stats_index.8-11)
      hash group 2:
        table: [2]
        seed: 0x0
    gateway:
      name: tbl_act_5-gateway
      row: 1
      bus: 0
      unit: 1
      0x0:  system_acl_system_acl
      miss:  system_acl_system_acl
      condition: 
        expression: "true(always hit)"
        true:  system_acl_system_acl
        false:  system_acl_system_acl
    next: []
    stats: tbl_act_5$stats.SwitchIngress.mirror_acl.stats(hash_dist 1, $DEFAULT)
    instruction: tbl_act_5($DEFAULT, $DEFAULT)
    actions:
      act_7(0, 0):
      - default_action: { allowed: true }
      - handle: 0x2000003a
      - next_table: 0
      - tbl_act_5$stats.SwitchIngress.mirror_acl.stats($hash_dist)
    default_action: act_7
  counter tbl_act_5$stats.SwitchIngress.mirror_acl.stats:
    p4: { name: SwitchIngress.mirror_acl.stats, size: 1024 }
    row: 5
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 404246592, interval: 25265664 }
    - { threshold: 404246592, interval: 25265664 }
    - { threshold: 404246592, interval: 25265664 }
stage 9 ingress:
  ternary_match system_acl_system_acl 1:
    p4: { name: SwitchIngress.system_acl.system_acl, size: 512 }
    p4_param_order: 
      ig_md.port_lag_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.bd_label: { type: ternary, size: 16, full_size: 16 }
      ig_md.ifindex: { type: ternary, size: 16, full_size: 16 }
      ig_md.lkp.pkt_type: { type: ternary, size: 2, full_size: 2 }
      ig_md.lkp.mac_type: { type: ternary, size: 16, full_size: 16 }
      ig_md.lkp.mac_dst_addr: { type: ternary, size: 48, full_size: 48 }
      ig_md.lkp.ip_type: { type: ternary, size: 2, full_size: 2 }
      ig_md.lkp.ip_ttl: { type: ternary, size: 8, full_size: 8 }
      ig_md.lkp.ip_proto: { type: ternary, size: 8, full_size: 8 }
      ig_md.lkp.ip_frag: { type: ternary, size: 2, full_size: 2 }
      ig_md.lkp.ip_dst_addr: { type: ternary, size: 128, full_size: 128 }
      ig_md.lkp.l4_src_port: { type: ternary, size: 16, full_size: 16 }
      ig_md.lkp.l4_dst_port: { type: ternary, size: 16, full_size: 16 }
      ig_md.lkp.arp_opcode: { type: ternary, size: 16, full_size: 16 }
      ig_md.flags.port_vlan_miss: { type: ternary, size: 1, full_size: 1 }
      ig_md.flags.acl_deny: { type: ternary, size: 1, full_size: 1 }
      ig_md.flags.racl_deny: { type: ternary, size: 1, full_size: 1 }
      ig_md.flags.rmac_hit: { type: ternary, size: 1, full_size: 1 }
      ig_md.flags.dmac_miss: { type: ternary, size: 1, full_size: 1 }
      ig_md.flags.myip: { type: ternary, size: 1, full_size: 1 }
      ig_md.flags.glean: { type: ternary, size: 1, full_size: 1 }
      ig_md.flags.routed: { type: ternary, size: 1, full_size: 1 }
      ig_md.qos.acl_policer_color: { type: ternary, size: 2, full_size: 2 }
      ig_md.qos.storm_control_color: { type: ternary, size: 2, full_size: 2 }
      ig_md.flags.link_local: { type: ternary, size: 1, full_size: 1 }
      ig_md.stp.state_: { type: ternary, size: 2, full_size: 2 }
      ig_md.ipv4.unicast_enable: { type: ternary, size: 1, full_size: 1 }
      ig_md.ipv6.unicast_enable: { type: ternary, size: 1, full_size: 1 }
      ig_md.checks.mrpf: { type: ternary, size: 1, full_size: 1 }
      ig_md.ipv4.multicast_enable: { type: ternary, size: 1, full_size: 1 }
      ig_md.ipv4.multicast_snooping: { type: ternary, size: 1, full_size: 1 }
      ig_md.ipv6.multicast_enable: { type: ternary, size: 1, full_size: 1 }
      ig_md.ipv6.multicast_snooping: { type: ternary, size: 1, full_size: 1 }
      ig_md.drop_reason: { type: ternary, size: 8, full_size: 8 }
    row: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    bus: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 1: { 0: ig_md.lkp.ip_dst_addr.32-63(16..31), 16: ig_md.lkp.ip_dst_addr.32-63(0..15), 32: ig_md.lkp.ip_dst_addr.64-95(16..23) }
      ternary group 2: { 0: ig_md.lkp.ip_dst_addr.64-95(24..31), 8: ig_md.lkp.ip_dst_addr.64-95(0..15), 24: ig_md.lkp.ip_dst_addr.96-127(16..31) }
      ternary group 3: { 0: ig_md.lkp.ip_dst_addr.96-127(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(16..31), 24: ig_md.lkp.ip_dst_addr.96-127(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.l4_dst_port, 16: ig_md.lkp.ip_dst_addr.0-31(0..7), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.ip_ttl }
      ternary group 5: { 0: ig_md.lkp.arp_opcode(0..7), 8: ig_md.flags.link_local, 16: ig_md.lkp.mac_type(0..7), 24: ig_md.lkp.arp_opcode(8..15), 32: ig_md.lkp.mac_dst_addr.0-15(0..7) }
      ternary group 6: { 0: ig_md.lkp.mac_type(8..15), 8: ig_md.ifindex(0..7), 18: ig_md.lkp.ip_type, 20: ig_md.lkp.ip_frag, 24: ig_md.port_lag_label(0..7), 32: ig_md.lkp.mac_dst_addr.0-15(8..15) }
      ternary group 7: { 5: ig_md.stp.state_, 8: ig_md.bd_label(0..7), 16: ig_md.ifindex(8..15), 24: ig_md.lkp.l4_src_port.0-7, 32: ig_md.port_lag_label(8..15) }
      ternary group 8: { 0: ig_md.lkp.l4_src_port.8-15, 8: ig_md.bd_label(8..15), 17: ig_md.checks.mrpf, 29: ig_md.flags.dmac_miss, 30: ig_md.flags.myip, 32: ig_md.drop_reason }
      ternary group 9: { 0: ig_md.ipv4.unicast_enable, 1: ig_md.ipv4.multicast_enable, 2: ig_md.ipv4.multicast_snooping, 3: ig_md.ipv6.unicast_enable, 4: ig_md.ipv6.multicast_enable, 5: ig_md.ipv6.multicast_snooping, 7: ig_md.flags.port_vlan_miss, 14: ig_md.flags.rmac_hit, 18: ig_md.qos.acl_policer_color, 24: ig_md.flags.routed, 25: ig_md.lkp.pkt_type, 31: ig_md.flags.acl_deny, 37: ig_md.qos.storm_control_color }
      byte group 1: { 2: ig_md.flags.glean, 3: ig_md.flags.racl_deny }
      byte group 2: { 0: ig_md.lkp.mac_dst_addr.16-47(24..31) }
      byte group 3: { 0: ig_md.lkp.mac_dst_addr.16-47(16..23) }
      byte group 4: { 0: ig_md.lkp.mac_dst_addr.16-47(8..15) }
      byte group 5: { 0: ig_md.lkp.mac_dst_addr.16-47(0..7) }
    match:
    - { group: 1, byte_group: 2, byte_config: 0, dirtcam: 0x555 }
    - { group: 2, byte_group: 2, byte_config: 1, dirtcam: 0x555 }
    - { group: 3, byte_group: 3, byte_config: 0, dirtcam: 0x555 }
    - { group: 4, byte_group: 3, byte_config: 1, dirtcam: 0x555 }
    - { group: 5, byte_group: 4, byte_config: 0, dirtcam: 0x555 }
    - { group: 6, byte_group: 4, byte_config: 1, dirtcam: 0x555 }
    - { group: 7, byte_group: 5, byte_config: 0, dirtcam: 0x555 }
    - { group: 8, byte_group: 5, byte_config: 1, dirtcam: 0x555 }
    - { group: 9, byte_group: 1, byte_config: 0, dirtcam: 0x555 }
    - { byte_config: 3, dirtcam: 0x0 }
    gateway:
      name: cond-42
      input_xbar:
        exact group 0: { 19: ig_md.bypass(3) }
      row: 0
      bus: 0
      unit: 0
      match: { 3: ig_md.bypass(3) }
      0b****0: run_table
      miss:  tbl_set_ig_intr_md
      condition: 
        expression: "(ig_md.bypass & 8 == 0)"
        true:  system_acl_system_acl
        false:  tbl_set_ig_intr_md
    hit: [  tbl_set_ig_intr_md ]
    miss:  tbl_set_ig_intr_md
    indirect: system_acl_system_acl$tind
  meter system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter:
    p4: { name: SwitchIngress.system_acl.copp_meter, size: 256 }
    row: 15
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    color_maprams:
      row: 7
      bus: 0
      column: 2
      address: idletime
    type: standard
    count: packets
    per_flow_enable: meter_pfe
  ternary_indirect system_acl_system_acl$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 0: ig_md.lkp.ip_dst_addr.32-63(16..31), 16: ig_md.lkp.ip_dst_addr.32-63(0..15), 32: ig_md.lkp.ip_dst_addr.64-95(16..23) }
      ternary group 2: { 0: ig_md.lkp.ip_dst_addr.64-95(24..31), 8: ig_md.lkp.ip_dst_addr.64-95(0..15), 24: ig_md.lkp.ip_dst_addr.96-127(16..31) }
      ternary group 3: { 0: ig_md.lkp.ip_dst_addr.96-127(8..15), 8: ig_md.lkp.ip_dst_addr.0-31(16..31), 24: ig_md.lkp.ip_dst_addr.96-127(0..7), 32: ig_md.lkp.ip_dst_addr.0-31(8..15) }
      ternary group 4: { 0: ig_md.lkp.l4_dst_port, 16: ig_md.lkp.ip_dst_addr.0-31(0..7), 24: ig_md.lkp.ip_proto, 32: ig_md.lkp.ip_ttl }
      ternary group 5: { 0: ig_md.lkp.arp_opcode(0..7), 8: ig_md.flags.link_local, 16: ig_md.lkp.mac_type(0..7), 24: ig_md.lkp.arp_opcode(8..15), 32: ig_md.lkp.mac_dst_addr.0-15(0..7) }
      ternary group 6: { 0: ig_md.lkp.mac_type(8..15), 8: ig_md.ifindex(0..7), 18: ig_md.lkp.ip_type, 20: ig_md.lkp.ip_frag, 24: ig_md.port_lag_label(0..7), 32: ig_md.lkp.mac_dst_addr.0-15(8..15) }
      ternary group 7: { 5: ig_md.stp.state_, 8: ig_md.bd_label(0..7), 16: ig_md.ifindex(8..15), 24: ig_md.lkp.l4_src_port.0-7, 32: ig_md.port_lag_label(8..15) }
      ternary group 8: { 0: ig_md.lkp.l4_src_port.8-15, 8: ig_md.bd_label(8..15), 17: ig_md.checks.mrpf, 29: ig_md.flags.dmac_miss, 30: ig_md.flags.myip, 32: ig_md.drop_reason }
      ternary group 9: { 0: ig_md.ipv4.unicast_enable, 1: ig_md.ipv4.multicast_enable, 2: ig_md.ipv4.multicast_snooping, 3: ig_md.ipv6.unicast_enable, 4: ig_md.ipv6.multicast_enable, 5: ig_md.ipv6.multicast_snooping, 7: ig_md.flags.port_vlan_miss, 14: ig_md.flags.rmac_hit, 18: ig_md.qos.acl_policer_color, 24: ig_md.flags.routed, 25: ig_md.lkp.pkt_type, 31: ig_md.flags.acl_deny, 37: ig_md.qos.storm_control_color }
      byte group 1: { 2: ig_md.flags.glean, 3: ig_md.flags.racl_deny }
      byte group 2: { 0: ig_md.lkp.mac_dst_addr.16-47(24..31) }
      byte group 3: { 0: ig_md.lkp.mac_dst_addr.16-47(16..23) }
      byte group 4: { 0: ig_md.lkp.mac_dst_addr.16-47(8..15) }
      byte group 5: { 0: ig_md.lkp.mac_dst_addr.16-47(0..7) }
    format: { action: 0..2, meter_addr: 3..12, meter_pfe: 13..13, meter_type: 14..16 }
    action_bus: { 3 : system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter color }
    meter: system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter(meter_addr, meter_pfe, meter_type)
    meter_color : system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter(meter_addr, meter_pfe)
    action: system_acl_system_acl$action_data($DIRECT, $DEFAULT)
    instruction: system_acl_system_acl$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000098
      - next_table: 0
      - {  }
      SwitchIngress.system_acl.drop(2, 1):
      - p4_param_order: { drop_reason: 8, disable_learning: 1 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000099
      - next_table: 0
      - mod_cond_value: {disable_learning: [ action_data_table(0..2) ] }
      - { $data0: $adf_b0(0..2), $constant0: $data0(0..2), $constant0: 0, $mask0: $adf_b1(0..2), disable_learning: $mask0(0..0), disable_learning: $mask0(1..1), disable_learning: $mask0(2..2), drop_reason: $adf_b2(0..7) }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      - set ig_md.drop_reason, drop_reason
      - bitmasked-set B2, $constant0, B2
      SwitchIngress.system_acl.copy_to_cpu(3, 2):
      - p4_param_order: { reason_code: 16, qid: 5, meter_id: 8, disable_learning: 1 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000009a
      - next_table: 0
      - mod_cond_value: {disable_learning: [ action_data_table(16..18) ] }
      - { reason_code: $adf_f0(0..15), $data0: $adf_b2(0..2), $constant0: $data0(0..2), $constant0: 0, $mask0: $adf_b3(0..2), disable_learning: $mask0(0..0), disable_learning: $mask0(1..1), disable_learning: $mask0(2..2), qid: $adf_b4(0..4), meter_id: $adf_b5(0..7) }
      - { meter_id: meter_addr }
      - set ig_md.qos.qid, qid
      - set ig_intr_md_for_tm.copy_to_cpu, 1
      - set ig_intr_md_for_tm.packet_color, system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter color(0..1)
      - set system_acl_copp_meter_id, meter_id
      - set ig_md.cpu_reason, reason_code
      - bitmasked-set B2, $constant0, B2
      - system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter(2, meter_id)
      SwitchIngress.system_acl.redirect_to_cpu(4, 4):
      - p4_param_order: { reason_code: 16, qid: 5, meter_id: 8, disable_learning: 1 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000009b
      - next_table: 0
      - mod_cond_value: {disable_learning: [ action_data_table(16..18) ] }
      - { reason_code: $adf_f0(0..15), $data0: $adf_b2(0..2), $constant0: $data0(0..2), $constant0: 0, $mask0: $adf_b3(0..2), disable_learning: $mask0(0..0), disable_learning: $mask0(1..1), disable_learning: $mask0(2..2), qid: $adf_b4(0..4), meter_id: $adf_b5(0..7) }
      - { meter_id: meter_addr }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      - set ig_md.qos.qid, qid
      - set ig_intr_md_for_tm.copy_to_cpu, 1
      - set ig_intr_md_for_tm.packet_color, system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter color(0..1)
      - set system_acl_copp_meter_id, meter_id
      - set ig_md.cpu_reason, reason_code
      - bitmasked-set B2, $constant0, B2
      - system_acl_system_acl$meter.SwitchIngress.system_acl.copp_meter(2, meter_id)
    default_action: NoAction
  action system_acl_system_acl$action_data:
    p4: { name: SwitchIngress.system_acl.system_acl$action }
    row: 15
    column: 2
    vpns: [ 0 ]
    home_row:
    - 15
    format SwitchIngress.system_acl.drop: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23 }
    format SwitchIngress.system_acl.copy_to_cpu: { $adf_f0: 0..31, $adf_b2: 16..23, $adf_b3: 24..31, $adf_b4: 32..39, $adf_b5: 40..47 }
    format SwitchIngress.system_acl.redirect_to_cpu: { $adf_f0: 0..31, $adf_b2: 16..23, $adf_b3: 24..31, $adf_b4: 32..39, $adf_b5: 40..47 }
    action_bus: { 16 : $adf_b4, 17 : $adf_b5, 20 : $adf_b0, 21 : $adf_b1, 22 : $adf_b2, 23 : $adf_b3, 20..23 : $adf_f0 }
  ternary_match tbl_set_ig_intr_md 2:
    p4: { name: tbl_set_ig_intr_md }
    hit: [  tbl_add_bridged_md ]
    miss:  tbl_add_bridged_md
    indirect: tbl_set_ig_intr_md$tind
  ternary_indirect tbl_set_ig_intr_md$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_set_ig_intr_md$tind(action, $DEFAULT)
    actions:
      set_ig_intr_md(0, 3):
      - default_action: { allowed: true }
      - handle: 0x200000a9
      - next_table: 0
      - set ig_intr_md_for_tm.mcast_grp_b, ig_md.multicast.id
      - set ig_intr_md_for_tm.level2_mcast_hash, ig_md.hash(16..28)
      - set hdr.bridged_md.base_peer_link, 0
    default_action: set_ig_intr_md
stage 10 ingress:
  ternary_match tbl_add_bridged_md 2:
    p4: { name: tbl_add_bridged_md }
    gateway:
      name: cond-45
      input_xbar:
        exact group 0: { 32: ig_intr_md_for_tm.bypass_egress }
      row: 6
      bus: 0
      unit: 0
      match: { 0: ig_intr_md_for_tm.bypass_egress }
      0b*******0: run_table
      miss:  dtel_mod_config
      condition: 
        expression: "(ig_intr_md_for_tm.bypass_egress == 0)"
        true:  tbl_add_bridged_md
        false:  dtel_mod_config
    hit: [  dtel_mod_config ]
    miss:  dtel_mod_config
    indirect: tbl_add_bridged_md$tind
  ternary_indirect tbl_add_bridged_md$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_add_bridged_md$tind(action, $DEFAULT)
    actions:
      add_bridged_md(1, 1):
      - default_action: { allowed: true }
      - handle: 0x200000a8
      - next_table: 0
      - set hdr.bridged_md.$valid, 1
      - set hdr.bridged_md.base_qid, ig_md.qos.qid
      - set hdr.bridged_md.dtel_egress_port, ig_md.egress_port
    default_action: add_bridged_md
  ternary_match dtel_mod_config 3:
    p4: { name: SwitchIngress.dtel.mod.config }
    p4_param_order: 
      ig_md.drop_reason: { type: ternary, size: 8, full_size: 8, key_name: "drop_reason" }
      ig_md.dtel.report_type: { type: ternary, size: 4, full_size: 4, key_name: "dtel_md.report_type" }
    row: 4
    bus: 0
    column: 0
    input_xbar:
      ternary group 0: { 0: ig_md.drop_reason, 8: ig_md.dtel.report_type }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x5 }
    gateway:
      name: cond-44
      input_xbar:
        exact group 0: { 24: ig_md.mirror.type }
      row: 5
      bus: 0
      unit: 0
      match: { 0: ig_md.mirror.type }
      0x00: run_table
      miss:  dtel_dod_config
      condition: 
        expression: "(ig_md.mirror.type == 0)"
        true:  dtel_mod_config
        false:  dtel_dod_config
    hit: [  dtel_dod_config ]
    miss:  dtel_dod_config
    indirect: dtel_mod_config$tind
  ternary_indirect dtel_mod_config$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: ig_md.drop_reason, 8: ig_md.dtel.report_type }
    format: { action: 0..1 }
    instruction: dtel_mod_config$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000a4
      - next_table: 0
      SwitchIngress.dtel.mod.mirror(2, 2):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000a5
      - next_table: 0
      - set ig_md.mirror.type, 3
      - set ig_md.mirror.src, 1
    default_action: NoAction
  ternary_match dtel_dod_config 4:
    p4: { name: SwitchIngress.dtel.dod.config, size: 1024 }
    p4_param_order: 
      ig_md.dtel.report_type: { type: ternary, size: 4, full_size: 4 }
      ig_intr_md_for_tm.ucast_egress_port: { type: ternary, size: 9, full_size: 9, key_name: "egress_port" }
      ig_md.qos.qid: { type: ternary, size: 5, full_size: 5, key_name: "qid" }
      ig_md.multicast.id: { type: ternary, size: 16, full_size: 16 }
    row: [ 0, 1, 2, 3 ]
    bus: [ 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 1: { 0: ig_intr_md_for_tm.ucast_egress_port(0..7), 8: ig_md.multicast.id(8..15), 16: ig_md.multicast.id(0..7), 24: ig_md.qos.qid, 32: ig_md.dtel.report_type }
      byte group 0: { 0: ig_intr_md_for_tm.ucast_egress_port(8) }
    match:
    - { group: 1, byte_group: 0, byte_config: 0, dirtcam: 0x555 }
    - { byte_config: 3, dirtcam: 0x0 }
    hit: [  system_acl_drop_stats ]
    miss:  system_acl_drop_stats
    indirect: dtel_dod_config$tind
  ternary_indirect dtel_dod_config$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 0: ig_intr_md_for_tm.ucast_egress_port(0..7), 8: ig_md.multicast.id(8..15), 16: ig_md.multicast.id(0..7), 24: ig_md.qos.qid, 32: ig_md.dtel.report_type }
      byte group 0: { 0: ig_intr_md_for_tm.ucast_egress_port(8) }
    format: { action: 0..0 }
    instruction: dtel_dod_config$tind(action, $DEFAULT)
    actions:
      SwitchIngress.dtel.dod.enable_dod(0, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000a2
      - next_table: 0
      - set ig_intr_md_for_tm.deflect_on_drop, 1
      SwitchIngress.dtel.dod.disable_dod(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000a3
      - next_table: 0
    default_action: SwitchIngress.dtel.dod.disable_dod
  exact_match system_acl_drop_stats 5:
    p4: { name: SwitchIngress.system_acl.drop_stats, size: 8192 }
    p4_param_order: 
      ig_md.drop_reason: { type: exact, size: 8, full_size: 8, key_name: "drop_reason" }
      ig_md.port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: [ 7, 6 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [1, 0, 0x0, [7, 2]]
      - [1, 1, 0x0, [7, 3]]
      - [1, 2, 0x0, [7, 4]]
      - [1, 3, 0x0, [6, 2]]
    input_xbar:
      exact group 0: { 64: ig_md.port, 80: ig_md.drop_reason }
      hash 1:
        0: random(ig_md.port(1..7)) ^ ig_md.port(0)
        1: random(ig_md.port(1..7)) ^ ig_md.port(8)
        2..9: random(ig_md.port(1..7)) ^ ig_md.drop_reason
        11: random(ig_md.port(1..7)) ^ ig_md.port(0)
        12: random(ig_md.port(1..7)) ^ ig_md.port(8)
        13..19: random(ig_md.port(1..7)) ^ ig_md.drop_reason(0..6)
        10: random(ig_md.port(1..7)) ^ ig_md.drop_reason(7)
        22: random(ig_md.port(1..7)) ^ ig_md.port(0)
        23: random(ig_md.port(1..7)) ^ ig_md.port(8)
        24..29: random(ig_md.port(1..7)) ^ ig_md.drop_reason(0..5)
        20..21: random(ig_md.port(1..7)) ^ ig_md.drop_reason(6..7)
        33: random(ig_md.port(1..7)) ^ ig_md.port(0)
        34: random(ig_md.port(1..7)) ^ ig_md.port(8)
        35..39: random(ig_md.port(1..7)) ^ ig_md.drop_reason(0..4)
        30..32: random(ig_md.port(1..7)) ^ ig_md.drop_reason(5..7)
      hash group 1:
        table: [1]
        seed: 0xe5ea92f313
    format: { version(0): 112..115, match(0): 33..39, version(1): 116..119, match(1): 41..47 }
    match: [ ig_md.port(1..7) ]
    hit: [  system_acl_copp ]
    miss:  system_acl_copp
    stats: system_acl_drop_stats$stats.SwitchIngress.system_acl.stats($DIRECT, $DEFAULT)
    instruction: system_acl_drop_stats($DEFAULT, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000009e
      - next_table: 0
      SwitchIngress.system_acl.count(0, 4):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000009f
      - next_table: 0
      - system_acl_drop_stats$stats.SwitchIngress.system_acl.stats($DIRECT)
    default_only_action: NoAction
  counter system_acl_drop_stats$stats.SwitchIngress.system_acl.stats:
    p4: { name: SwitchIngress.system_acl.stats }
    row: 13
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 22349296, interval: 268435200 }
    - { threshold: 22349296, interval: 268435200 }
    - { threshold: 22349296, interval: 268435200 }
  ternary_match system_acl_copp 6:
    p4: { name: SwitchIngress.system_acl.copp, size: 512 }
    p4_param_order: 
      ig_intr_md_for_tm.packet_color: { type: ternary, size: 2, full_size: 2 }
      system_acl_copp_meter_id: { type: ternary, size: 8, full_size: 8, key_name: "copp_meter_id" }
    row: 5
    bus: 0
    column: 0
    input_xbar:
      ternary group 0: { 16: ig_intr_md_for_tm.packet_color, 24: system_acl_copp_meter_id }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x50 }
    hit: [  END ]
    miss:  END
    indirect: system_acl_copp$tind
  counter system_acl_copp$stats.SwitchIngress.system_acl.copp_stats:
    p4: { name: SwitchIngress.system_acl.copp_stats }
    row: 5
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
  ternary_indirect system_acl_copp$tind:
    row: 2
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 16: ig_intr_md_for_tm.packet_color, 24: system_acl_copp_meter_id }
    format: { action: 0..0 }
    stats: system_acl_copp$stats.SwitchIngress.system_acl.copp_stats($DIRECT, $DEFAULT)
    instruction: system_acl_copp$tind(action, $DEFAULT)
    actions:
      SwitchIngress.system_acl.copp_permit(0, 0):
      - default_action: { allowed: true }
      - handle: 0x2000009c
      - next_table: 0
      - system_acl_copp$stats.SwitchIngress.system_acl.copp_stats($DIRECT)
      SwitchIngress.system_acl.copp_drop(1, 5):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000009d
      - next_table: 0
      - set ig_intr_md_for_tm.copy_to_cpu, 0
      - system_acl_copp$stats.SwitchIngress.system_acl.copp_stats($DIRECT)
    default_action: SwitchIngress.system_acl.copp_permit
stage 0 egress:
  exact_match egress_port_mapping_port_mirror_port_mirror 0:
    p4: { name: SwitchEgress.egress_port_mapping.port_mirror.port_mirror, size: 576 }
    p4_param_order: 
      eg_intr_md.egress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 6
    bus: 0
    column: 6
    stash: 
      row: [ 6 ]
      col: [ 6 ]
      unit: [ 1 ]
    ways:
      - [0, 0, 0x0, [6, 6]]
    input_xbar:
      exact group 0: { 0: eg_intr_md.egress_port }
      hash 0:
        0..7: eg_intr_md.egress_port(0..7)
        8: eg_intr_md.egress_port(8)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..10, version(0): 112..115 }
    hit: [  tbl_act_24 ]
    miss:  tbl_act_24
    action_bus: { 32..33 : immediate(0..9) }
    instruction: egress_port_mapping_port_mirror_port_mirror(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000ae
      - next_table: 0
      - {  }
      SwitchEgress.egress_port_mapping.port_mirror.set_mirror_id(1, 1):
      - p4_param_order: { session_id: 10 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000af
      - next_table: 0
      - { session_id: immediate(0..9) }
      - set eg_md.mirror.type, 1
      - set eg_md.mirror.src, 2
      - set eg_md.mirror.session_id, session_id
    default_action: NoAction
  ternary_match tbl_act_24 3:
    p4: { name: tbl_act_24 }
    gateway:
      name: cond-59
      input_xbar:
        exact group 0: { 32: hdr.dtel_drop_report.$valid, 40: eg_md.pkt_src }
      row: 0
      bus: 1
      unit: 1
      match: { 0: eg_md.pkt_src, 8: hdr.dtel_drop_report.$valid }
      0b*******100000011: run_table
      miss:  multicast_replication_rid
      condition: 
        expression: "(eg_md.pkt_src == 3 && hdr.dtel_drop_report.$valid == 1)"
        true:  tbl_act_24
        false:  multicast_replication_rid
    hit: [  multicast_replication_rid ]
    miss:  multicast_replication_rid
    indirect: tbl_act_24$tind
  ternary_indirect tbl_act_24$tind:
    row: 2
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_act_24$tind(action, $DEFAULT)
    actions:
      act_23(1, 2):
      - default_action: { allowed: true }
      - handle: 0x200000e2
      - next_table: 0
      - set eg_md.port.0-7, hdr.dtel_drop_report.egress_port.0-7
      - set eg_md.port.8-8, hdr.dtel_drop_report.egress_port.8-8
    default_action: act_23
  exact_match multicast_replication_rid 4:
    p4: { name: SwitchEgress.multicast_replication.rid, size: 4096 }
    p4_param_order: 
      eg_intr_md.egress_rid: { type: exact, size: 16, full_size: 16, key_name: "replication_id" }
    row: 5
    bus: 0
    column: [ 6, 7, 8, 9 ]
    stash: 
      row: [ 5 ]
      col: [ 9 ]
      unit: [ 1 ]
    ways:
      - [1, 0, 0x0, [5, 9]]
      - [1, 1, 0x0, [5, 8]]
      - [1, 2, 0x0, [5, 7]]
      - [1, 3, 0x0, [5, 6]]
    input_xbar:
      exact group 0: { 64: eg_intr_md.egress_rid }
      hash 1:
        0..7: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(0..7)
        8..9: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(8..9)
        11..18: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(0..7)
        19: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(8)
        10: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(9)
        22..29: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(0..7)
        20..21: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(8..9)
        33..39: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(0..6)
        30: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(7)
        31..32: random(eg_intr_md.egress_rid(10..15)) ^ eg_intr_md.egress_rid(8..9)
      hash group 1:
        table: [1]
        seed: 0x6cd601f81b
    format: { action(0): 0..1, immediate(0): 2..17, version(0): 112..115, match(0): 34..39 }
    match: [ eg_intr_md.egress_rid(10..15) ]
    gateway:
      name: cond-47
      input_xbar:
        exact group 0: { 64: eg_intr_md.egress_rid }
      row: 0
      bus: 0
      unit: 0
      match: { 0: eg_intr_md.egress_rid(0..7), 8: eg_intr_md.egress_rid(8..15) }
      0x0000:  tbl_act_23
      miss: run_table
      condition: 
        expression: "(eg_intr_md.egress_rid != 0)"
        true:  multicast_replication_rid
        false:  tbl_act_23
    hit: [  tbl_act_23 ]
    miss:  tbl_act_23
    action_bus: { 36..37 : immediate(0..15) }
    instruction: multicast_replication_rid(action, $DEFAULT)
    actions:
      SwitchEgress.multicast_replication.rid_miss(1, 3):
      - default_action: { allowed: true }
      - handle: 0x200000bd
      - next_table: 0
      - {  }
      - set eg_md.flags.routed, 0
      SwitchEgress.multicast_replication.rid_hit(2, 4):
      - p4_param_order: { bd: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000be
      - next_table: 0
      - { $data0: immediate(0..15), bd: $data0(0..15), $data1: immediate(0..15), bd: $data1(0..15) }
      - set H64, $data0
      - xor H72, $data1, H64
    default_action: SwitchEgress.multicast_replication.rid_miss
  ternary_match tbl_act_23 5:
    p4: { name: tbl_act_23 }
    hit: [  egress_port_mapping_port_mapping ]
    miss:  egress_port_mapping_port_mapping
    indirect: tbl_act_23$tind
  ternary_indirect tbl_act_23$tind:
    row: 1
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_act_23$tind(action, $DEFAULT)
    actions:
      act_24(0, 5):
      - default_action: { allowed: true }
      - handle: 0x200000e1
      - next_table: 0
      - sub eg_md.dtel.latency, eg_intr_md_from_prsr.global_tstamp.0-31, eg_md.ingress_timestamp.0-31
      - set dtel_queue_report_flag, 0
    default_action: act_24
  exact_match egress_port_mapping_port_mapping 14:
    p4: { name: SwitchEgress.egress_port_mapping.port_mapping, size: 576 }
    p4_param_order: 
      eg_intr_md.egress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 5
    bus: 1
    column: 10
    stash: 
      row: [ 5 ]
      col: [ 10 ]
      unit: [ 0 ]
    ways:
      - [0, 2, 0x0, [5, 10]]
    input_xbar:
      exact group 0: { 0: eg_intr_md.egress_port }
      hash 0:
        20..27: eg_intr_md.egress_port(0..7)
        28: eg_intr_md.egress_port(8)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, version(0): 112..115 }
    hit: [  dtel_egress_port_conversion ]
    miss:  dtel_egress_port_conversion
    action: egress_port_mapping_port_mapping$action_data($DIRECT, $DEFAULT)
    instruction: egress_port_mapping_port_mapping(action, $DEFAULT)
    actions:
      SwitchEgress.egress_port_mapping.port_normal(0, 6):
      - p4_param_order: { port_lag_index: 10, port_lag_label: 16, qos_group: 5, mlag_member: 1 }
      - default_action: { allowed: true }
      - handle: 0x200000ab
      - next_table: 0
      - { qos_group: $adf_f0(0..4), port_lag_index: $adf_h0(5..14) }
      - set eg_md.port_lag_index, port_lag_index
      - set eg_md.qos.group, qos_group
      SwitchEgress.egress_port_mapping.port_cpu(1, 8):
      - p4_param_order: { port_lag_index: 10 }
      - default_action: { allowed: true }
      - handle: 0x200000ac
      - next_table: 0
      - { $data0: $adf_f0(1..4), $constant1: $data0(0..0), $constant1: 1, $constant0: $data0(3..3), $constant0: 1, $mask0: $adf_f1(1..4), $constant2: $mask0(0..0), $constant2: 1, $constant3: $mask0(3..3), $constant3: 1 }
      - set hdr.cpu.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, 36864
      - deposit-field H31(9..15), 0, H30
      - bitmasked-set W31, $data0, W31
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x200000ad
      - next_table: 0
      - {  }
    default_only_action: NoAction
  action egress_port_mapping_port_mapping$action_data:
    p4: { name: SwitchEgress.egress_port_mapping.port_mapping$action }
    row: 14
    column: 2
    vpns: [ 0 ]
    home_row:
    - 14
    format SwitchEgress.egress_port_mapping.port_normal: { $adf_f0: 0..31, $adf_h0: 0..15 }
    format SwitchEgress.egress_port_mapping.port_cpu: { $adf_f0: 0..31, $adf_f1: 32..63 }
    action_bus: { 56..57 : $adf_h0, 96..99 : $adf_f0, 100..103 : $adf_f1 }
  exact_match dtel_egress_port_conversion 15:
    p4: { name: SwitchEgress.dtel.egress_port_conversion }
    p4_param_order: 
      hdr.dtel_drop_report.egress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 7
    bus: 1
    column: 10
    stash: 
      row: [ 7 ]
      col: [ 10 ]
      unit: [ 1 ]
    ways:
      - [5, 0, 0x0, [7, 10]]
    input_xbar:
      exact group 2: { 64: hdr.dtel_drop_report.egress_port.8-8, 72: hdr.dtel_drop_report.egress_port.0-7 }
      hash 5:
        0: hdr.dtel_drop_report.egress_port.8-8
        1..8: hdr.dtel_drop_report.egress_port.0-7
      hash group 5:
        table: [5]
        seed: 0x0
    format: { action(0): 0..1, immediate(0): 2..17, version(0): 112..115 }
    gateway:
      name: cond-60
      input_xbar:
        exact group 0: { 32: hdr.dtel_drop_report.$valid }
      row: 1
      bus: 0
      unit: 0
      match: { 0: hdr.dtel_drop_report.$valid }
      0b*******1: run_table
      miss:  mirror_rewrite_pkt_length
      condition: 
        expression: "(hdr.dtel_drop_report.$valid == 1)"
        true:  dtel_egress_port_conversion
        false:  mirror_rewrite_pkt_length
    hit: [  tbl_act_26 ]
    miss:  tbl_act_26
    action_bus: { 16 : immediate(0..7), 17 : immediate(8..15) }
    instruction: dtel_egress_port_conversion(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000e7
      - next_table: 0
      - {  }
      SwitchEgress.dtel.convert_egress_port(2, 7):
      - p4_param_order: { port: 9 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000e8
      - next_table: 0
      - { port.8-8: immediate(0..0), port.0-7: immediate(8..15) }
      - set hdr.dtel_drop_report.egress_port.0-7, port.0-7
      - set hdr.dtel_drop_report.egress_port.8-8, port.8-8
    default_action: NoAction
stage 1 egress:
  hash_action tbl_act_26 3:
    p4: { name: tbl_act_26 }
    row: 4
    bus: 1
    hash_dist:
      0: { hash: 1, mask: 0x1ffff, shift: 0, expand: 0 }
    input_xbar:
      exact group 0: { 64: eg_md.dtel.hash.0-15, 80: eg_md.dtel.hash.16-31(0) }
      hash 1:
        0..15: stripe(eg_md.dtel.hash.0-15)
        32..32: stripe(eg_md.dtel.hash.16-31(0))
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: cond-61
      input_xbar:
        exact group 0: { 34: eg_md.dtel.report_type(2..3) }
      row: 1
      bus: 0
      unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 2: eg_md.dtel.report_type(2..3) }
      0b****01:  dtel_ingress_port_conversion
      miss: run_table
      condition: 
        expression: "(eg_md.dtel.report_type & 12 == 4)"
        true:  dtel_ingress_port_conversion
        false:  dtel_ingress_port_conversion
    next:  dtel_ingress_port_conversion
    action_bus: { 40..41 : tbl_act_26$salu.SwitchEgress.dtel.drop_report.array1(0..15) }
    stateful: tbl_act_26$salu.SwitchEgress.dtel.drop_report.array1(hash_dist 0, meter_pfe, meter_type)
    instruction: tbl_act_26(action, $DEFAULT)
    actions:
      act_25(1, 1):
      - default_action: { allowed: true }
      - handle: 0x200000e3
      - next_table: 0
      - set dtel_drop_report_flag(0..0), tbl_act_26$salu.SwitchEgress.dtel.drop_report.array1
      - tbl_act_26$salu.SwitchEgress.dtel.drop_report.array1(1, $hash_dist)
    default_action: act_25
  stateful tbl_act_26$salu.SwitchEgress.dtel.drop_report.array1:
    p4: { name: SwitchEgress.dtel.drop_report.array1, size: 131072 }
    row: 7
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    format: { lo: 1 }
    actions:
      dtel_drop_report_filter1:
      - set_bit
      - output alu_lo
      clr_bit_alu$0:
      - clr_bit
  exact_match dtel_ingress_port_conversion 12:
    p4: { name: SwitchEgress.dtel.ingress_port_conversion }
    p4_param_order: 
      hdr.dtel_drop_report.ingress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 5
    bus: 1
    column: 4
    stash: 
      row: [ 5 ]
      col: [ 4 ]
      unit: [ 0 ]
    ways:
      - [3, 1, 0x0, [5, 4]]
    input_xbar:
      exact group 1: { 104: hdr.dtel_drop_report.ingress_port(8), 112: hdr.dtel_drop_report.ingress_port(0..7) }
      hash 3:
        10: hdr.dtel_drop_report.ingress_port(8)
        11..18: hdr.dtel_drop_report.ingress_port(0..7)
      hash group 3:
        table: [3]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..9, version(0): 112..115 }
    hit: [  tbl_act_27 ]
    miss:  tbl_act_27
    action_bus: { 60..61 : immediate(0..8) }
    instruction: dtel_ingress_port_conversion(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000e5
      - next_table: 0
      - {  }
      SwitchEgress.dtel.convert_ingress_port(1, 2):
      - p4_param_order: { port: 9 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000e6
      - next_table: 0
      - { port: immediate(0..8) }
      - set hdr.dtel_drop_report.ingress_port, port
    default_action: NoAction
stage 2 egress:
  hash_action tbl_act_27 9:
    p4: { name: tbl_act_27 }
    row: 0
    bus: 1
    hash_dist:
      0: { hash: 4, mask: 0x1ffff, shift: 0, expand: 0 }
    input_xbar:
      exact group 5: { 64: eg_md.dtel.hash.16-31(0..7), 79: eg_md.dtel.hash.0-15(15), 88: eg_md.dtel.hash.16-31(8..15) }
      hash 11:
        1..8: stripe(eg_md.dtel.hash.16-31(0..7))
        0..0: stripe(eg_md.dtel.hash.0-15(15))
        9..15: stripe(eg_md.dtel.hash.16-31(8..14))
        32..32: stripe(eg_md.dtel.hash.16-31(15))
      hash group 4:
        table: [11]
        seed: 0x0
    gateway:
      name: cond-62
      input_xbar:
        exact group 0: { 90: eg_md.dtel.report_type(2..3) }
      row: 1
      bus: 0
      unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 2: eg_md.dtel.report_type(2..3) }
      0b****01:  mirror_rewrite_pkt_length
      miss: run_table
      condition: 
        expression: "(eg_md.dtel.report_type & 12 == 4)"
        true:  mirror_rewrite_pkt_length
        false:  mirror_rewrite_pkt_length
    next:  mirror_rewrite_pkt_length
    action_bus: { 44..45 : tbl_act_27$salu.SwitchEgress.dtel.drop_report.array2(0..15) }
    stateful: tbl_act_27$salu.SwitchEgress.dtel.drop_report.array2(hash_dist 0, meter_pfe, meter_type)
    instruction: tbl_act_27(action, $DEFAULT)
    actions:
      act_27(1, 1):
      - default_action: { allowed: true }
      - handle: 0x200000e4
      - next_table: 0
      - set dtel_drop_report_flag(1..1), tbl_act_27$salu.SwitchEgress.dtel.drop_report.array2
      - tbl_act_27$salu.SwitchEgress.dtel.drop_report.array2(1, $hash_dist)
    default_action: act_27
  stateful tbl_act_27$salu.SwitchEgress.dtel.drop_report.array2:
    p4: { name: SwitchEgress.dtel.drop_report.array2, size: 131072 }
    row: 15
    column: [ 2, 3 ]
    maprams: [ 2, 3 ]
    format: { lo: 1 }
    actions:
      dtel_drop_report_filter2:
      - set_bit
      - output alu_lo
      clr_bit_alu$0:
      - clr_bit
  exact_match mirror_rewrite_pkt_length 10:
    p4: { name: SwitchEgress.mirror_rewrite.pkt_length }
    p4_param_order: 
      eg_md.mirror.type: { type: exact, size: 8, full_size: 8 }
    row: 0
    bus: 0
    column: 2
    stash: 
      row: [ 0 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [5, 0, 0x0, [0, 2]]
    input_xbar:
      exact group 6: { 0: eg_md.mirror.type }
      hash 12:
        0..7: eg_md.mirror.type
      hash group 5:
        table: [12]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..16, version(0): 112..115 }
    gateway:
      name: cond-46
      input_xbar:
        exact group 1: { 48: eg_md.pkt_src }
      row: 1
      bus: 1
      unit: 1
      match: { 0: eg_md.pkt_src }
      0x00:  tbl_act_17
      miss: run_table
      condition: 
        expression: "(eg_md.pkt_src != 0)"
        true:  mirror_rewrite_pkt_length
        false:  tbl_act_17
    hit: [  mirror_rewrite_rewrite_1 ]
    miss:  mirror_rewrite_rewrite_1
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: eg_md.mirror.type
          value: "0x1"
        action_handle: 0x200000b0
        is_default_entry: false
        action_parameters_values:
        - parameter_name: length_offset
          value: "0xfff2"
      - priority: 1
        match_key_fields_values:
        - field_name: eg_md.mirror.type
          value: "0x2"
        action_handle: 0x200000b0
        is_default_entry: false
        action_parameters_values:
        - parameter_name: length_offset
          value: "0xfff2"
      - priority: 2
        match_key_fields_values:
        - field_name: eg_md.mirror.type
          value: "0x3"
        action_handle: 0x200000b0
        is_default_entry: false
        action_parameters_values:
        - parameter_name: length_offset
          value: "0xfff3"
      - priority: 3
        match_key_fields_values:
        - field_name: eg_md.mirror.type
          value: "0x4"
        action_handle: 0x200000b0
        is_default_entry: false
        action_parameters_values:
        - parameter_name: length_offset
          value: "0xfff1"
    action_bus: { 48..49 : immediate(0..15) }
    instruction: mirror_rewrite_pkt_length(action, $DEFAULT)
    actions:
      SwitchEgress.mirror_rewrite.adjust_length(1, 2):
      - p4_param_order: { length_offset: 16 }
      - default_action: { allowed: true }
      - handle: 0x200000b0
      - next_table: 0
      - { length_offset: immediate(0..15) }
      - add eg_md.pkt_length, eg_md.pkt_length, length_offset
      - set eg_md.mirror.type, 0
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x200000b1
      - next_table: 0
      - {  }
    default_only_action: NoAction
stage 3 egress:
  exact_match mirror_rewrite_rewrite_1 0:
    p4: { name: SwitchEgress.mirror_rewrite.rewrite, size: 1024 }
    p4_param_order: 
      eg_md.mirror.session_id: { type: exact, size: 10, full_size: 10 }
    row: 0
    bus: 0
    column: 2
    stash: 
      row: [ 0 ]
      col: [ 2 ]
      unit: [ 1 ]
    ways:
      - [0, 0, 0x0, [0, 2]]
    input_xbar:
      exact group 0: { 0: eg_md.mirror.session_id }
      hash 0:
        0..7: eg_md.mirror.session_id(0..7)
        8..9: eg_md.mirror.session_id(8..9)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..5, version(0): 112..115 }
    hit: [  tbl_act_17 ]
    miss:  tbl_act_17
    action: mirror_rewrite_rewrite_1$action_data($DIRECT, $DEFAULT)
    instruction: mirror_rewrite_rewrite_1(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000b2
      - next_table: 0
      - {  }
      SwitchEgress.mirror_rewrite.rewrite_(1, 1):
      - p4_param_order: { qid: 5 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000b3
      - next_table: 0
      - { qid: $adf_b0(0..4) }
      - set eg_md.qos.qid, qid
      SwitchEgress.mirror_rewrite.rewrite_rspan(2, 2):
      - p4_param_order: { qid: 5, pcp: 3, vid: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000b4
      - next_table: 0
      - {  }
      SwitchEgress.mirror_rewrite.rewrite_erspan_type2(3, 3):
      - p4_param_order: { qid: 5, smac: 48, dmac: 48, sip: 32, dip: 32, tos: 8, ttl: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000b5
      - next_table: 0
      - { ttl: $adf_b0(0..7), qid: $adf_b1(0..4), tos: $adf_b2(0..7), $constant0: $adf_h2(0..15), $constant0: 32, smac.0-15: $adf_h3(0..15), dmac.0-15: $adf_h8(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f5(0..31), dip: $adf_f6(0..31) }
      - set eg_md.qos.qid, qid
      - set hdr.gre.proto, 35006
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 47
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant0
      - set hdr.inner_ethernet.dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set hdr.inner_ethernet.dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set hdr.inner_ethernet.src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set hdr.inner_ethernet.src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set hdr.inner_ethernet.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, 2048
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set B38, 69
      - deposit-field B48(1..1), 1, B49
      - set B49(0..2), 7
      - deposit-field H21(10..15), 0, H20
      - set H65, 4096
      - set W26, 0
      SwitchEgress.mirror_rewrite.rewrite_erspan_type3(4, 4):
      - p4_param_order: { qid: 5, smac: 48, dmac: 48, sip: 32, dip: 32, tos: 8, ttl: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000b6
      - next_table: 0
      - { ttl: $adf_b0(0..7), qid: $adf_b1(0..4), tos: $adf_b2(0..7), $constant0: $adf_h2(0..15), $constant0: 36, smac.0-15: $adf_h3(0..15), dmac.0-15: $adf_h8(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f5(0..31), dip: $adf_f6(0..31) }
      - set eg_md.qos.qid, qid
      - set hdr.erspan_type3.timestamp, eg_md.ingress_timestamp.0-31
      - set hdr.gre.proto, 8939
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 47
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant0
      - set hdr.inner_ethernet.$valid, hdr.ethernet.$valid
      - set hdr.inner_ethernet.dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set hdr.inner_ethernet.dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set hdr.inner_ethernet.src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set hdr.inner_ethernet.src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set hdr.inner_ethernet.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, 2048
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set B38, 69
      - set B49(0..3), 255
      - deposit-field H22(10..15), 0, H20
      - set H52, 4
      - set H66, 8192
      - set W26, 0
      SwitchEgress.mirror_rewrite.rewrite_erspan_type3_platform_specific(6, 6):
      - p4_param_order: { qid: 5, smac: 48, dmac: 48, sip: 32, dip: 32, tos: 8, ttl: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000b7
      - next_table: 0
      - { ttl: $adf_b0(0..7), qid: $adf_b1(0..4), tos: $adf_b2(0..7), $constant0: $adf_h2(0..15), $constant0: 44, smac.0-15: $adf_h3(0..15), dmac.0-15: $adf_h8(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f5(0..31), dip: $adf_f6(0..31) }
      - set eg_md.qos.qid, qid
      - set hdr.erspan_type3.timestamp, eg_md.ingress_timestamp.0-31
      - set hdr.gre.proto, 8939
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 47
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant0
      - set hdr.inner_ethernet.$valid, hdr.ethernet.$valid
      - set hdr.inner_ethernet.dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set hdr.inner_ethernet.dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set hdr.inner_ethernet.src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set hdr.inner_ethernet.src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set hdr.inner_ethernet.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, 2048
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set B38, 69
      - set B49(0..4), 255
      - deposit-field H22(10..15), 0, H20
      - set H52, 5
      - set H66, 8192
      - set W26, 0
      SwitchEgress.mirror_rewrite.rewrite_erspan_type2_with_vlan(8, 8):
      - p4_param_order: { qid: 5, ether_type: 16, smac: 48, dmac: 48, pcp: 3, vid: 12, sip: 32, dip: 32, tos: 8, ttl: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000b8
      - next_table: 0
      - { ttl: $adf_b0(0..7), qid: $adf_b1(0..4), tos: $adf_b2(0..7), $data0: $adf_h2(0..15), vid: $data0(0..11), pcp: $data0(13..15), $mask0: $adf_h3(0..15), $constant1: $mask0(0..11), $constant1: 4095, $constant2: $mask0(13..15), $constant2: 7, $constant0: $adf_h8(0..15), $constant0: 32, ether_type: $adf_h9(0..15), smac.0-15: $adf_h10(0..15), dmac.0-15: $adf_h11(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f6(0..31), dip: $adf_f7(0..31) }
      - set eg_md.qos.qid, qid
      - set hdr.gre.proto, 35006
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 47
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant0
      - set hdr.inner_ethernet.dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set hdr.inner_ethernet.dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set hdr.inner_ethernet.src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set hdr.inner_ethernet.src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set hdr.inner_ethernet.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, ether_type
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set hdr.vlan_tag$0.$valid, 1
      - set hdr.vlan_tag$0.ether_type, 2048
      - set B38, 69
      - deposit-field B48(1..1), 1, B49
      - set B49(0..2), 7
      - deposit-field H21(10..15), 0, H20
      - bitmasked-set H54, $data0, H54
      - set H65, 4096
      - set W26, 0
      SwitchEgress.mirror_rewrite.rewrite_erspan_type3_with_vlan(10, 10):
      - p4_param_order: { qid: 5, ether_type: 16, smac: 48, dmac: 48, pcp: 3, vid: 12, sip: 32, dip: 32, tos: 8, ttl: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000b9
      - next_table: 0
      - { ttl: $adf_b0(0..7), qid: $adf_b1(0..4), tos: $adf_b2(0..7), $data0: $adf_h2(0..15), vid: $data0(0..11), pcp: $data0(13..15), $mask0: $adf_h3(0..15), $constant1: $mask0(0..11), $constant1: 4095, $constant2: $mask0(13..15), $constant2: 7, $constant0: $adf_h8(0..15), $constant0: 36, ether_type: $adf_h9(0..15), smac.0-15: $adf_h10(0..15), dmac.0-15: $adf_h11(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f6(0..31), dip: $adf_f7(0..31) }
      - set eg_md.qos.qid, qid
      - set hdr.erspan_type3.timestamp, eg_md.ingress_timestamp.0-31
      - set hdr.gre.proto, 8939
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 47
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant0
      - set hdr.inner_ethernet.$valid, hdr.ethernet.$valid
      - set hdr.inner_ethernet.dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set hdr.inner_ethernet.dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set hdr.inner_ethernet.src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set hdr.inner_ethernet.src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set hdr.inner_ethernet.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, ether_type
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set hdr.vlan_tag$0.$valid, 1
      - set hdr.vlan_tag$0.ether_type, 2048
      - set B38, 69
      - set B49(0..3), 255
      - deposit-field H22(10..15), 0, H20
      - set H52, 4
      - bitmasked-set H54, $data0, H54
      - set H66, 8192
      - set W26, 0
      SwitchEgress.mirror_rewrite.rewrite_erspan_type3_platform_specific_with_vlan(12, 12):
      - p4_param_order: { qid: 5, ether_type: 16, smac: 48, dmac: 48, pcp: 3, vid: 12, sip: 32, dip: 32, tos: 8, ttl: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000ba
      - next_table: 0
      - { ttl: $adf_b0(0..7), qid: $adf_b1(0..4), tos: $adf_b2(0..7), $data0: $adf_h2(0..15), vid: $data0(0..11), pcp: $data0(13..15), $mask0: $adf_h3(0..15), $constant1: $mask0(0..11), $constant1: 4095, $constant2: $mask0(13..15), $constant2: 7, $constant0: $adf_h8(0..15), $constant0: 44, ether_type: $adf_h9(0..15), smac.0-15: $adf_h10(0..15), dmac.0-15: $adf_h11(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f6(0..31), dip: $adf_f7(0..31) }
      - set eg_md.qos.qid, qid
      - set hdr.erspan_type3.timestamp, eg_md.ingress_timestamp.0-31
      - set hdr.gre.proto, 8939
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 47
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant0
      - set hdr.inner_ethernet.$valid, hdr.ethernet.$valid
      - set hdr.inner_ethernet.dst_addr.0-15, hdr.ethernet.dst_addr.0-15
      - set hdr.inner_ethernet.dst_addr.16-47, hdr.ethernet.dst_addr.16-47
      - set hdr.inner_ethernet.src_addr.0-15, hdr.ethernet.src_addr.0-15
      - set hdr.inner_ethernet.src_addr.16-47, hdr.ethernet.src_addr.16-47
      - set hdr.inner_ethernet.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, ether_type
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set hdr.vlan_tag$0.$valid, 1
      - set hdr.vlan_tag$0.ether_type, 2048
      - set B38, 69
      - set B49(0..4), 255
      - deposit-field H22(10..15), 0, H20
      - set H52, 5
      - bitmasked-set H54, $data0, H54
      - set H66, 8192
      - set W26, 0
      SwitchEgress.mirror_rewrite.rewrite_dtel_report_with_entropy(14, 14):
      - p4_param_order: { smac: 48, dmac: 48, sip: 32, dip: 32, tos: 8, ttl: 8, udp_dst_port: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000bb
      - next_table: 0
      - { $data0: $adf_b0(0..5), $constant2: $data0(0..0), $constant2: 1, $constant1: $data0(1..1), $constant1: 1, $constant0: $data0(5..5), $constant0: 1, $mask0: $adf_b1(0..5), $constant3: $mask0(0..1), $constant3: 3, $constant4: $mask0(5..5), $constant4: 1, ttl: $adf_b2(0..7), tos: $adf_b3(0..7), $constant5: $adf_h2(0..15), $constant5: 40, $constant6: $adf_h3(0..15), $constant6: 20, udp_dst_port: $adf_h8(0..15), smac.0-15: $adf_h9(0..15), dmac.0-15: $adf_h10(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f6(0..31), dip: $adf_f7(0..31) }
      - set hdr.udp.dst_port, udp_dst_port
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 17
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant5
      - add hdr.udp.length, eg_md.pkt_length, $constant6
      - set hdr.ethernet.ether_type, 2048
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set hdr.udp.src_port, eg_md.dtel.hash.0-15
      - set B38, 69
      - bitmasked-set B49, $data0, B49
      - set W26, 16384
      SwitchEgress.mirror_rewrite.rewrite_dtel_report_without_entropy(16, 16):
      - p4_param_order: { smac: 48, dmac: 48, sip: 32, dip: 32, tos: 8, ttl: 8, udp_dst_port: 16, udp_src_port: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000bc
      - next_table: 0
      - { $data0: $adf_b0(0..5), $constant2: $data0(0..0), $constant2: 1, $constant1: $data0(1..1), $constant1: 1, $constant0: $data0(5..5), $constant0: 1, $mask0: $adf_b1(0..5), $constant3: $mask0(0..1), $constant3: 3, $constant4: $mask0(5..5), $constant4: 1, ttl: $adf_b2(0..7), tos: $adf_b3(0..7), $constant5: $adf_h2(0..15), $constant5: 40, $constant6: $adf_h3(0..15), $constant6: 20, udp_src_port: $adf_h8(0..15), udp_dst_port: $adf_h9(0..15), smac.0-15: $adf_h10(0..15), dmac.0-15: $adf_h11(0..15), smac.16-47: $adf_f2(0..31), dmac.16-47: $adf_f3(0..31), sip: $adf_f6(0..31), dip: $adf_f7(0..31) }
      - set hdr.udp.dst_port, udp_dst_port
      - set hdr.ipv4.diffserv, tos
      - set hdr.ipv4.ttl, ttl
      - set hdr.ipv4.protocol, 17
      - set hdr.ipv4.src_addr, sip
      - set hdr.ipv4.dst_addr, dip
      - add hdr.ipv4.total_len, eg_md.pkt_length, $constant5
      - add hdr.udp.length, eg_md.pkt_length, $constant6
      - set hdr.ethernet.ether_type, 2048
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set hdr.udp.src_port, udp_src_port
      - set B38, 69
      - bitmasked-set B49, $data0, B49
      - set W26, 16384
    default_action: NoAction
  action mirror_rewrite_rewrite_1$action_data:
    p4: { name: SwitchEgress.mirror_rewrite.rewrite$action }
    row: [ 8, 7 ]
    word: [ 0, 1 ]
    column:
    - 4
    - 2
    vpns: 
    - [ 0 ]
    - [ 0 ]
    home_row:
    - 8
    - 7
    format SwitchEgress.mirror_rewrite.rewrite_: { $adf_b0: 0..7 }
    format SwitchEgress.mirror_rewrite.rewrite_erspan_type2: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f5: 160..191, $adf_f6: 192..223 }
    format SwitchEgress.mirror_rewrite.rewrite_erspan_type3: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f5: 160..191, $adf_f6: 192..223 }
    format SwitchEgress.mirror_rewrite.rewrite_erspan_type3_platform_specific: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f5: 160..191, $adf_f6: 192..223 }
    format SwitchEgress.mirror_rewrite.rewrite_erspan_type2_with_vlan: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_h9: 144..159, $adf_h10: 160..175, $adf_h11: 176..191, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f6: 192..223, $adf_f7: 224..255 }
    format SwitchEgress.mirror_rewrite.rewrite_erspan_type3_with_vlan: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_h9: 144..159, $adf_h10: 160..175, $adf_h11: 176..191, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f6: 192..223, $adf_f7: 224..255 }
    format SwitchEgress.mirror_rewrite.rewrite_erspan_type3_platform_specific_with_vlan: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_h9: 144..159, $adf_h10: 160..175, $adf_h11: 176..191, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f6: 192..223, $adf_f7: 224..255 }
    format SwitchEgress.mirror_rewrite.rewrite_dtel_report_with_entropy: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_b3: 24..31, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_h9: 144..159, $adf_h10: 160..175, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f6: 192..223, $adf_f7: 224..255 }
    format SwitchEgress.mirror_rewrite.rewrite_dtel_report_without_entropy: { $adf_b0: 0..7, $adf_b1: 8..15, $adf_b2: 16..23, $adf_b3: 24..31, $adf_h2: 32..47, $adf_h3: 48..63, $adf_h8: 128..143, $adf_h9: 144..159, $adf_h10: 160..175, $adf_h11: 176..191, $adf_f2: 64..95, $adf_f3: 96..127, $adf_f6: 192..223, $adf_f7: 224..255 }
    action_bus: { 16 : $adf_b0, 17 : $adf_b1, 18 : $adf_b2, 19 : $adf_b3, 32..33 : $adf_h2, 34..35 : $adf_h3, 64..65 : $adf_h8, 66..67 : $adf_h9, 68..69 : $adf_h10, 70..71 : $adf_h11, 96..99 : $adf_f2, 100..103 : $adf_f3, 104..107 : $adf_f6, 108..111 : $adf_f7, 68..71 : $adf_f5 }
  ternary_match tbl_act_17 1:
    p4: { name: tbl_act_17 }
    gateway:
      name: cond-48
      input_xbar:
        exact group 0: { 16: eg_md.checks.same_bd }
      row: 6
      bus: 1
      unit: 0
      match: { 0: eg_md.checks.same_bd(0..7), 8: eg_md.checks.same_bd(8..15) }
      0x0000: run_table
      miss:  cond-49
      condition: 
        expression: "(eg_md.checks.same_bd == 0)"
        true:  tbl_act_17
        false:  cond-49
    hit: [  cond-49 ]
    miss:  cond-49
    indirect: tbl_act_17$tind
  ternary_indirect tbl_act_17$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_act_17$tind(action, $DEFAULT)
    actions:
      act_17(1, 5):
      - default_action: { allowed: true }
      - handle: 0x200000bf
      - next_table: 0
      - set eg_md.flags.routed, 0
    default_action: act_17
  gateway cond-49 2:
    name: cond-49
    input_xbar:
      exact group 0: { 37: eg_md.bypass(5) }
    row: 4
    bus: 1
    unit: 0
    match: { 5: eg_md.bypass(5) }
    0b**0:  tbl_act_19
    miss:  cond-51
    condition: 
      expression: "(eg_md.bypass & 32 == 0)"
      true:  tbl_act_19
      false:  cond-51
  hash_action tbl_act_19 3:
    p4: { name: tbl_act_19 }
    row: 2
    bus: 1
    hash_dist:
      0: { hash: 1, mask: 0x7fffff, shift: 0, expand: 0 }
    input_xbar:
      exact group 0: { 64: eg_intr_md.egress_port(0..6), 72: eg_md.bd(8..11), 80: eg_md.bd(0..7) }
      hash 1:
        0..6: stripe(eg_intr_md.egress_port(0..6))
        15..15: stripe(eg_md.bd(8))
        32..34: stripe(eg_md.bd(9..11))
        7..14: stripe(eg_md.bd(0..7))
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: cond-50
      input_xbar:
        exact group 0: { 44: eg_md.bd(12..15) }
      row: 0
      bus: 0
      unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 4: eg_md.bd(12..15) }
      0x0:  cond-51
      miss: run_table
      condition: 
        expression: "(eg_md.bd[15:12][15:12] == 0)"
        true:  cond-51
        false:  cond-51
    next:  cond-51
    action_bus: { 36..37 : tbl_act_19$salu.SwitchEgress.stp.stp(0..15) }
    stateful: tbl_act_19$salu.SwitchEgress.stp.stp(hash_dist 0, meter_pfe, meter_type)
    instruction: tbl_act_19(action, $DEFAULT)
    actions:
      act_18(1, 7):
      - default_action: { allowed: true }
      - handle: 0x200000c0
      - next_table: 0
      - set eg_md.checks.stp, tbl_act_19$salu.SwitchEgress.stp.stp
      - tbl_act_19$salu.SwitchEgress.stp.stp(1, $hash_dist)
    default_action: act_18
  stateful tbl_act_19$salu.SwitchEgress.stp.stp:
    p4: { name: SwitchEgress.stp.stp, size: 524288 }
    row: [ 15, 13 ]
    column:
    - [ 2, 3, 4, 5 ]
    - 2
    maprams: 
    - [ 2, 3, 4, 5 ]
    - 2
    format: { lo: 1 }
    actions:
      stp_stp_check_0:
      - read_bit
      - output alu_lo
      set_bit_alu$0:
      - set_bit
      clr_bit_alu$0:
      - clr_bit
  gateway cond-51 4:
    name: cond-51
    input_xbar:
      exact group 0: { 32: eg_md.bypass(0) }
    row: 3
    bus: 1
    unit: 0
    match: { 0: eg_md.bypass(0) }
    0b*******0:  tbl_act_20
    miss:  dtel_queue_report_queue_alert
    condition: 
      expression: "(eg_md.bypass & 1 == 0)"
      true:  tbl_act_20
      false:  dtel_queue_report_queue_alert
stage 4 egress:
  ternary_match tbl_act_20 0:
    p4: { name: tbl_act_20 }
    gateway:
      name: cond-52
      input_xbar:
        exact group 0: { 1: hdr.vlan_tag$0.$valid }
      row: 3
      bus: 1
      unit: 0
      match: { 1: hdr.vlan_tag$0.$valid }
      0b******1: run_table
      miss:  dtel_queue_report_queue_alert
      condition: 
        expression: "(hdr.vlan_tag[0].$valid == 1)"
        true:  tbl_act_20
        false:  dtel_queue_report_queue_alert
    hit: [  dtel_queue_report_queue_alert ]
    miss:  dtel_queue_report_queue_alert
    indirect: tbl_act_20$tind
  ternary_indirect tbl_act_20$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_act_20$tind(action, $DEFAULT)
    actions:
      act_20(1, 1):
      - default_action: { allowed: true }
      - handle: 0x200000c1
      - next_table: 0
      - set hdr.ethernet.ether_type, hdr.vlan_tag$0.ether_type
      - set hdr.vlan_tag$0.$valid, 0
    default_action: act_20
  exact_match dtel_queue_report_queue_alert 1:
    p4: { name: SwitchEgress.dtel.queue_report.queue_alert, size: 1024 }
    p4_param_order: 
      eg_md.qos.qid: { type: exact, size: 5, full_size: 5, key_name: "qid" }
      eg_md.port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 2
    bus: 0
    column: [ 2, 3, 4, 6 ]
    stash: 
      row: [ 2 ]
      col: [ 6 ]
      unit: [ 0 ]
    ways:
      - [0, 0, 0x0, [2, 6]]
      - [0, 1, 0x0, [2, 4]]
      - [0, 2, 0x0, [2, 3]]
      - [0, 3, 0x0, [2, 2]]
    input_xbar:
      exact group 0: { 8: eg_md.port.8-8, 16: eg_md.port.0-7, 24: eg_md.qos.qid }
      hash 0:
        0: random(eg_md.port.0-7(4..7)) ^ eg_md.port.8-8
        1..4: random(eg_md.port.0-7(4..7)) ^ eg_md.port.0-7(0..3)
        5..9: random(eg_md.port.0-7(4..7)) ^ eg_md.qos.qid
        11: random(eg_md.port.0-7(4..7)) ^ eg_md.port.8-8
        12..15: random(eg_md.port.0-7(4..7)) ^ eg_md.port.0-7(0..3)
        16..19: random(eg_md.port.0-7(4..7)) ^ eg_md.qos.qid(0..3)
        10: random(eg_md.port.0-7(4..7)) ^ eg_md.qos.qid(4)
        22: random(eg_md.port.0-7(4..7)) ^ eg_md.port.8-8
        23..26: random(eg_md.port.0-7(4..7)) ^ eg_md.port.0-7(0..3)
        27..29: random(eg_md.port.0-7(4..7)) ^ eg_md.qos.qid(0..2)
        20..21: random(eg_md.port.0-7(4..7)) ^ eg_md.qos.qid(3..4)
        33: random(eg_md.port.0-7(4..7)) ^ eg_md.port.8-8
        34..37: random(eg_md.port.0-7(4..7)) ^ eg_md.port.0-7(0..3)
        38..39: random(eg_md.port.0-7(4..7)) ^ eg_md.qos.qid(0..1)
        30..32: random(eg_md.port.0-7(4..7)) ^ eg_md.qos.qid(2..4)
      hash group 0:
        table: [0]
        seed: 0xef473d67cd
    format: { action(0): 0..1, immediate(0): 17..32, version(0): 112..115, meter_addr(0): 2..12, meter_pfe(0): 13..13, meter_type(0): 14..16, match(0): 36..39 }
    match: [ eg_md.port.0-7(4..7) ]
    gateway:
      name: cond-63
      input_xbar:
        exact group 0: { 32: eg_md.pkt_src }
      row: 2
      bus: 1
      unit: 1
      match: { 0: eg_md.pkt_src }
      0x00: run_table
      miss:  tbl_act_16
      condition: 
        expression: "(eg_md.pkt_src == 0)"
        true:  dtel_queue_report_queue_alert
        false:  tbl_act_16
    hit: [  tbl_act_16 ]
    miss:  tbl_act_16
    action_bus: { 96..99 : immediate(0..15), 32..33 : dtel_queue_report_queue_alert$salu.SwitchEgress.dtel.queue_report.thresholds(0..15) }
    stateful: dtel_queue_report_queue_alert$salu.SwitchEgress.dtel.queue_report.thresholds(meter_addr, meter_pfe, meter_type)
    action: dtel_queue_report_queue_alert$action_data($DIRECT, $DEFAULT)
    instruction: dtel_queue_report_queue_alert(action, $DEFAULT)
    actions:
      SwitchEgress.dtel.queue_report.set_qalert(1, 2):
      - p4_param_order: { index: 16, quota: 16, quantization_mask: 32 }
      - default_action: { allowed: true }
      - handle: 0x200000e9
      - next_table: 0
      - { quantization_mask: $adf_f0(0..31), quota: immediate(0..15) }
      - { index: meter_addr }
      - set dtel_queue_report_flag, dtel_queue_report_queue_alert$salu.SwitchEgress.dtel.queue_report.thresholds
      - set dtel_queue_report_quota, quota
      - and eg_md.dtel.latency, eg_md.dtel.latency, quantization_mask
      - dtel_queue_report_queue_alert$salu.SwitchEgress.dtel.queue_report.thresholds(1, index)
      SwitchEgress.dtel.queue_report.set_qmask(2, 4):
      - p4_param_order: { quantization_mask: 32 }
      - default_action: { allowed: true }
      - handle: 0x200000ea
      - next_table: 0
      - { quantization_mask: $adf_f0(0..31) }
      - and eg_md.dtel.latency, eg_md.dtel.latency, quantization_mask
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x200000eb
      - next_table: 0
      - {  }
    default_only_action: NoAction
  stateful dtel_queue_report_queue_alert$salu.SwitchEgress.dtel.queue_report.thresholds:
    p4: { name: SwitchEgress.dtel.queue_report.thresholds, size: 2048 }
    row: 15
    column: [ 3, 4 ]
    maprams: [ 3, 4 ]
    input_xbar:
      exact group 0: { 64: eg_md.dtel.latency, 96: eg_intr_md.enq_qdepth }
      hash 1:
        0..31: eg_md.dtel.latency
        32..50: eg_intr_md.enq_qdepth
      hash group 1:
        table: [1]
        seed: 0x0
    format: { lo: 32, hi:32 }
    actions:
      dtel_queue_report_check_thresholds:
      - leq.u lo, hi, -phv_lo
      - leq.u hi, lo, -phv_hi(0..23)
      - output cmplo | cmphi, predicate
    pred_shift: 28
    pred_comb_shift: 0
  action dtel_queue_report_queue_alert$action_data:
    p4: { name: SwitchEgress.dtel.queue_report.queue_alert$action }
    row: 11
    column: 3
    vpns: [ 0 ]
    home_row:
    - 11
    format SwitchEgress.dtel.queue_report.set_qalert: { $adf_f0: 0..31 }
    format SwitchEgress.dtel.queue_report.set_qmask: { $adf_f0: 0..31 }
    action_bus: { 104..107 : $adf_f0 }
  ternary_match tbl_act_16 2:
    p4: { name: tbl_act_16 }
    hit: [  qos_qos_map ]
    miss:  qos_qos_map
    indirect: tbl_act_16$tind
  ternary_indirect tbl_act_16$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_act_16$tind(action, $DEFAULT)
    actions:
      act_16(0, 3):
      - default_action: { allowed: true }
      - handle: 0x200000aa
      - next_table: 0
      - set eg_md.timestamp, eg_intr_md_from_prsr.global_tstamp.0-31
    default_action: act_16
  ternary_match qos_qos_map 3:
    p4: { name: SwitchEgress.qos.qos_map, size: 1024 }
    p4_param_order: 
      eg_md.qos.group: { type: ternary, size: 5, full_size: 5, key_name: "group" }
      eg_md.qos.tc: { type: ternary, size: 8, full_size: 8, key_name: "tc" }
      eg_md.qos.color: { type: ternary, size: 2, full_size: 2, key_name: "color" }
      hdr.ipv4.$valid: { type: ternary, size: 1, full_size: 1 }
      hdr.ipv6.$valid: { type: ternary, size: 1, full_size: 1 }
    row: [ 0, 1 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 3: { 0: eg_md.qos.tc, 8: eg_md.qos.color, 17: hdr.ipv4.$valid, 26: hdr.ipv6.$valid, 30: eg_md.qos.group }
    match:
    - { group: 3, byte_config: 3, dirtcam: 0x155 }
    gateway:
      name: cond-53
      input_xbar:
        exact group 0: { 43: eg_md.bypass(3) }
      row: 1
      bus: 1
      unit: 0
      match: { 3: eg_md.bypass(3) }
      0b****0: run_table
      miss:  rewrite_nexthop_rewrite
      condition: 
        expression: "(eg_md.bypass & 8 == 0)"
        true:  qos_qos_map
        false:  rewrite_nexthop_rewrite
    hit: [  rewrite_nexthop_rewrite ]
    miss:  rewrite_nexthop_rewrite
    indirect: qos_qos_map$tind
  ternary_indirect qos_qos_map$tind:
    row: 0
    bus: 0
    column: 5
    input_xbar:
      ternary group 3: { 0: eg_md.qos.tc, 8: eg_md.qos.color, 17: hdr.ipv4.$valid, 26: hdr.ipv6.$valid, 30: eg_md.qos.group }
    format: { action: 0..2, immediate: 3..10 }
    action_bus: { 0 : immediate(0..7), 36..37 : immediate(0..7) }
    instruction: qos_qos_map$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000c2
      - next_table: 0
      - {  }
      SwitchEgress.qos.set_ipv4_dscp(2, 5):
      - p4_param_order: { dscp: 6 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000c3
      - next_table: 0
      - { dscp: immediate(0..5) }
      - set hdr.ipv4.diffserv(2..7), dscp
      SwitchEgress.qos.set_ipv4_tos(3, 6):
      - p4_param_order: { tos: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000c4
      - next_table: 0
      - { tos: immediate(0..7) }
      - set hdr.ipv4.diffserv, tos
      SwitchEgress.qos.set_ipv6_dscp(4, 8):
      - p4_param_order: { dscp: 6 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000c5
      - next_table: 0
      - { dscp.2-5: immediate(0..3), dscp.0-1: immediate(4..5) }
      - set hdr.ipv6.traffic_class.0-3(2..3), dscp.0-1
      - set hdr.ipv6.traffic_class.4-7, dscp.2-5
      SwitchEgress.qos.set_ipv6_tos(5, 10):
      - p4_param_order: { tos: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000c6
      - next_table: 0
      - { tos.4-7: immediate(0..3), tos.0-3: immediate(4..7) }
      - set hdr.ipv6.traffic_class.0-3, tos.0-3
      - set hdr.ipv6.traffic_class.4-7, tos.4-7
      SwitchEgress.qos.set_vlan_pcp(6, 7):
      - p4_param_order: { pcp: 3 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000c7
      - next_table: 0
      - { pcp: immediate(0..2) }
      - set eg_md.lkp.pcp, pcp
    default_action: NoAction
  exact_match rewrite_nexthop_rewrite 4:
    p4: { name: SwitchEgress.rewrite.nexthop_rewrite, size: 16384 }
    p4_param_order: 
      eg_md.nexthop: { type: exact, size: 16, full_size: 16 }
    row: 0
    bus: 0
    column: [ 2, 3, 4, 6 ]
    stash: 
      row: [ 0 ]
      col: [ 6 ]
      unit: [ 0 ]
    ways:
      - [2, 0, 0x0, [0, 6]]
      - [2, 1, 0x0, [0, 4]]
      - [2, 2, 0x0, [0, 3]]
      - [2, 3, 0x0, [0, 2]]
    input_xbar:
      exact group 1: { 0: eg_md.nexthop }
      hash 2:
        0..7: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(0..7)
        8..9: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(8..9)
        11..18: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(0..7)
        19: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(8)
        10: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(9)
        22..29: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(0..7)
        20..21: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(8..9)
        33..39: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(0..6)
        30: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(7)
        31..32: random(eg_md.nexthop(10..15)) ^ eg_md.nexthop(8..9)
      hash group 2:
        table: [2]
        seed: 0x4c09b0c6d
    format: { action(0): 0..2, version(0): 112..115, match(0): 34..39, action(1): 3..5, version(1): 116..119, match(1): 42..47, action(2): 6..8, version(2): 120..123, match(2): 50..55, action(3): 9..11, version(3): 124..127, match(3): 58..63 }
    match: [ eg_md.nexthop(10..15) ]
    gateway:
      name: cond-54
      input_xbar:
        exact group 0: { 40: eg_md.bypass(0) }
      row: 0
      bus: 1
      unit: 0
      match: { 0: eg_md.bypass(0) }
      0b*******0: run_table
      miss:  qos_queue
      condition: 
        expression: "(eg_md.bypass & 1 == 0)"
        true:  rewrite_nexthop_rewrite
        false:  qos_queue
    hit: [  qos_queue ]
    miss:  qos_queue
    action: rewrite_nexthop_rewrite$action_data($DIRECT, $DEFAULT)
    instruction: rewrite_nexthop_rewrite(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000ca
      - next_table: 0
      - {  }
      SwitchEgress.rewrite.rewrite_l2_with_tunnel(2, 9):
      - p4_param_order: { type: 3 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000cb
      - next_table: 0
      - {  }
      SwitchEgress.rewrite.rewrite_l3(3, 11):
      - p4_param_order: { bd: 16, dmac: 48 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000cc
      - next_table: 0
      - { dmac.0-15: $adf_h0(0..15), bd: $adf_h1(0..15), dmac.16-47: $adf_f1(0..31) }
      - set eg_md.flags.routed, 1
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set eg_md.bd, bd
      SwitchEgress.rewrite.rewrite_l3_with_tunnel(4, 12):
      - p4_param_order: { dmac: 48, type: 3 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000cd
      - next_table: 0
      - {  }
      SwitchEgress.rewrite.rewrite_l3_with_tunnel_bd(5, 13):
      - p4_param_order: { dmac: 48, type: 3, bd: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000ce
      - next_table: 0
      - {  }
      SwitchEgress.rewrite.rewrite_l3_with_tunnel_id(6, 14):
      - p4_param_order: { dmac: 48, type: 3, id: 24 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000cf
      - next_table: 0
      - {  }
    default_action: NoAction
  action rewrite_nexthop_rewrite$action_data:
    p4: { name: SwitchEgress.rewrite.nexthop_rewrite$action }
    row: [ 14, 12, 11, 10, 9 ]
    word: [ 0, 0, 0, 0, 0 ]
    column:
    - 5
    - 5
    - [ 4, 5 ]
    - 5
    - [ 1, 2, 3 ]
    vpns: 
    - [ 0 ]
    - [ 1 ]
    - [ 2, 3 ]
    - [ 4 ]
    - [ 5, 6, 7 ]
    home_row:
    - 14
    format SwitchEgress.rewrite.rewrite_l3: { $adf_h0: 0..15, $adf_h1: 16..31, $adf_f1: 32..63 }
    action_bus: { 40..41 : $adf_h0, 42..43 : $adf_h1, 116..119 : $adf_f1 }
  exact_match qos_queue 8:
    p4: { name: SwitchEgress.qos.queue, size: 1024 }
    p4_param_order: 
      eg_intr_md.egress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
      eg_md.qos.qid: { type: exact, size: 5, full_size: 5, key_name: "qid" }
    row: 1
    bus: 0
    column: [ 2, 3, 4, 6 ]
    stash: 
      row: [ 1 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [6, 0, 0x0, [1, 2]]
      - [6, 1, 0x0, [1, 6]]
      - [6, 2, 0x0, [1, 4]]
      - [6, 3, 0x0, [1, 3]]
    input_xbar:
      exact group 6: { 0: eg_intr_md.egress_port, 16: eg_md.qos.qid }
      hash 12:
        0..3: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(0..3)
        4: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(8)
        5..9: random(eg_intr_md.egress_port(4..7)) ^ eg_md.qos.qid
        11..14: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(0..3)
        15: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(8)
        16..19: random(eg_intr_md.egress_port(4..7)) ^ eg_md.qos.qid(0..3)
        10: random(eg_intr_md.egress_port(4..7)) ^ eg_md.qos.qid(4)
        22..25: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(0..3)
        26: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(8)
        27..29: random(eg_intr_md.egress_port(4..7)) ^ eg_md.qos.qid(0..2)
        20..21: random(eg_intr_md.egress_port(4..7)) ^ eg_md.qos.qid(3..4)
        33..36: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(0..3)
        37: random(eg_intr_md.egress_port(4..7)) ^ eg_intr_md.egress_port(8)
        38..39: random(eg_intr_md.egress_port(4..7)) ^ eg_md.qos.qid(0..1)
        30..32: random(eg_intr_md.egress_port(4..7)) ^ eg_md.qos.qid(2..4)
      hash group 6:
        table: [12]
        seed: 0x4792d0c8bf
    format: { version(0): 112..115, match(0): 36..39 }
    match: [ eg_intr_md.egress_port(4..7) ]
    hit: [  cond-58 ]
    miss:  cond-58
    stats: qos_queue$stats.SwitchEgress.qos.queue_stats($DIRECT, $DEFAULT)
    instruction: qos_queue($DEFAULT, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x200000c8
      - next_table: 0
      SwitchEgress.qos.count(0, 15):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000c9
      - next_table: 0
      - qos_queue$stats.SwitchEgress.qos.queue_stats($DIRECT)
    default_only_action: NoAction
  counter qos_queue$stats.SwitchEgress.qos.queue_stats:
    p4: { name: SwitchEgress.qos.queue_stats }
    row: 13
    column: [ 3, 4, 5 ]
    maprams: [ 3, 4, 5 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 379488784, interval: 23718144 }
    - { threshold: 379488784, interval: 23718144 }
    - { threshold: 379488784, interval: 23718144 }
  gateway cond-58 9:
    name: cond-58
    input_xbar:
      exact group 0: { 40: eg_md.bypass(0) }
    row: 4
    bus: 1
    unit: 0
    match: { 0: eg_md.bypass(0) }
    0b*******0:  vlan_xlate_port_bd_to_vlan_mapping
    miss:  dtel_queue_report_check_quota
    condition: 
      expression: "(eg_md.bypass & 1 == 0)"
      true:  vlan_xlate_port_bd_to_vlan_mapping
      false:  dtel_queue_report_check_quota
stage 5 egress:
  exact_match vlan_xlate_port_bd_to_vlan_mapping 6:
    p4: { name: SwitchEgress.vlan_xlate.port_bd_to_vlan_mapping, size: 1024 }
    p4_param_order: 
      eg_md.port_lag_index: { type: exact, size: 10, full_size: 10, key_name: "port_lag_index" }
      eg_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
    row: [ 3, 2 ]
    bus: [ 1, 0 ]
    column:
    - 4
    - [ 2, 3 ]
    stash: 
      row: [ 3 ]
      col: [ 4 ]
      unit: [ 0 ]
    ways:
      - [1, 1, 0x0, [3, 4]]
      - [1, 2, 0x0, [2, 2]]
      - [1, 3, 0x0, [2, 3]]
    input_xbar:
      exact group 0: { 88: eg_md.port_lag_index(8..9), 96: eg_md.port_lag_index(0..7), 104: eg_md.bd(8..15), 112: eg_md.bd(0..7) }
      hash 1:
        10..11: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(8..9)
        12..19: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(0..7)
        21..22: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(8..9)
        23..29: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(0..6)
        20: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(7)
        32..33: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(8..9)
        34..39: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(0..5)
        30..31: random(eg_md.bd(8..15), eg_md.bd(0..7)) ^ eg_md.port_lag_index(6..7)
      hash group 1:
        table: [1]
        seed: 0x6d93d6b800
    format: { action(0): 0..1, immediate(0): 6..18, version(0): 112..115, match(0): 48..63, action(1): 2..3, immediate(1): 19..31, version(1): 116..119, match(1): 64..79, action(2): 4..5, immediate(2): 32..44, version(2): 120..123, match(2): 80..95 }
    match: [ eg_md.bd(0..7), eg_md.bd(8..15) ]
    hit: [  dtel_queue_report_check_quota ]
    miss:  vlan_xlate_bd_to_vlan_mapping
    action_bus: { 32..33 : immediate(0..12) }
    instruction: vlan_xlate_port_bd_to_vlan_mapping(action, $DEFAULT)
    actions:
      SwitchEgress.vlan_xlate.set_vlan_untagged(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000dc
      - next_table_miss:  vlan_xlate_bd_to_vlan_mapping
      - next_table: 0
      - {  }
      SwitchEgress.vlan_xlate.set_vlan_tagged(1, 1):
      - p4_param_order: { vid: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000dd
      - next_table_miss:  vlan_xlate_bd_to_vlan_mapping
      - next_table: 0
      - { $data0: immediate(0..12), vid: $data0(0..11), $constant0: $data0(12..12), $constant0: 0 }
      - set hdr.vlan_tag$0.$valid, 1
      - set hdr.vlan_tag$0.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, 33024
      - deposit-field H54(0..12), $data0, H57
      SwitchEgress.vlan_xlate.set_double_tagged(2, 2):
      - p4_param_order: { vid0: 12, vid1: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000de
      - next_table_miss:  vlan_xlate_bd_to_vlan_mapping
      - next_table: 0
      - {  }
    default_action: SwitchEgress.vlan_xlate.set_vlan_untagged
  exact_match vlan_xlate_bd_to_vlan_mapping 7:
    p4: { name: SwitchEgress.vlan_xlate.bd_to_vlan_mapping, size: 4096 }
    p4_param_order: 
      eg_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
    row: [ 4, 3 ]
    bus: [ 1, 0 ]
    column:
    - [ 3, 4 ]
    - [ 2, 3 ]
    stash: 
      row: [ 4 ]
      col: [ 3 ]
      unit: [ 0 ]
    ways:
      - [2, 0, 0x0, [4, 3]]
      - [2, 1, 0x0, [4, 4]]
      - [2, 2, 0x0, [3, 2]]
      - [2, 3, 0x0, [3, 3]]
    input_xbar:
      exact group 1: { 0: eg_md.bd }
      hash 2:
        0..7: random(eg_md.bd(10..15)) ^ eg_md.bd(0..7)
        8..9: random(eg_md.bd(10..15)) ^ eg_md.bd(8..9)
        11..18: random(eg_md.bd(10..15)) ^ eg_md.bd(0..7)
        19: random(eg_md.bd(10..15)) ^ eg_md.bd(8)
        10: random(eg_md.bd(10..15)) ^ eg_md.bd(9)
        22..29: random(eg_md.bd(10..15)) ^ eg_md.bd(0..7)
        20..21: random(eg_md.bd(10..15)) ^ eg_md.bd(8..9)
        33..39: random(eg_md.bd(10..15)) ^ eg_md.bd(0..6)
        30: random(eg_md.bd(10..15)) ^ eg_md.bd(7)
        31..32: random(eg_md.bd(10..15)) ^ eg_md.bd(8..9)
      hash group 2:
        table: [2]
        seed: 0x18ce49251a
    format: { action(0): 0..0, immediate(0): 3..15, version(0): 112..115, match(0): 42..47, action(1): 1..1, immediate(1): 16..28, version(1): 116..119, match(1): 50..55, action(2): 2..2, immediate(2): 29..41, version(2): 120..123, match(2): 58..63 }
    match: [ eg_md.bd(10..15) ]
    hit: [  dtel_queue_report_check_quota ]
    miss:  dtel_queue_report_check_quota
    action_bus: { 36..37 : immediate(0..12) }
    instruction: vlan_xlate_bd_to_vlan_mapping(action, $DEFAULT)
    actions:
      SwitchEgress.vlan_xlate.set_vlan_untagged(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000df
      - next_table: 0
      - {  }
      SwitchEgress.vlan_xlate.set_vlan_tagged(1, 3):
      - p4_param_order: { vid: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000e0
      - next_table: 0
      - { $data0: immediate(0..12), vid: $data0(0..11), $constant0: $data0(12..12), $constant0: 0 }
      - set hdr.vlan_tag$0.$valid, 1
      - set hdr.vlan_tag$0.ether_type, hdr.ethernet.ether_type
      - set hdr.ethernet.ether_type, 33024
      - deposit-field H54(0..12), $data0, H57
    default_action: SwitchEgress.vlan_xlate.set_vlan_untagged
  exact_match dtel_queue_report_check_quota 8:
    p4: { name: SwitchEgress.dtel.queue_report.check_quota, size: 3072 }
    p4_param_order: 
      eg_md.pkt_src: { type: exact, size: 8, full_size: 8 }
      dtel_queue_report_flag: { type: exact, size: 1, full_size: 1, key_name: "qalert" }
      eg_md.qos.qid: { type: exact, size: 5, full_size: 5, key_name: "qid" }
      eg_md.port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: [ 5, 4 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4 ]
    - 2
    stash: 
      row: [ 5 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [3, 0, 0x0, [5, 2]]
      - [3, 1, 0x0, [5, 3]]
      - [3, 2, 0x0, [5, 4]]
      - [3, 3, 0x0, [4, 2]]
    input_xbar:
      exact group 1: { 64: dtel_queue_report_flag, 72: eg_md.port.8-8, 80: eg_md.port.0-7, 88: eg_md.qos.qid, 96: eg_md.pkt_src }
      hash 3:
        0: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ dtel_queue_report_flag
        1: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.8-8
        2..4: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.0-7(0..2)
        5..9: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.qos.qid
        11: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ dtel_queue_report_flag
        12: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.8-8
        13..15: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.0-7(0..2)
        16..19: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.qos.qid(0..3)
        10: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.qos.qid(4)
        22: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ dtel_queue_report_flag
        23: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.8-8
        24..26: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.0-7(0..2)
        27..29: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.qos.qid(0..2)
        20..21: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.qos.qid(3..4)
        33: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ dtel_queue_report_flag
        34: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.8-8
        35..37: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.port.0-7(0..2)
        38..39: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.qos.qid(0..1)
        30..32: random(eg_md.port.0-7(3..7), eg_md.pkt_src) ^ eg_md.qos.qid(2..4)
      hash group 3:
        table: [3]
        seed: 0x6190fcaa1b
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 6..16, meter_pfe(0): 17..17, meter_type(0): 18..20, match(0): 51..63, action(1): 2..3, version(1): 116..119, meter_addr(1): 21..31, meter_pfe(1): 32..32, meter_type(1): 33..35, match(1): [75..79, 64..71 ], action(2): 4..5, version(2): 120..123, meter_addr(2): 36..46, meter_pfe(2): 47..47, meter_type(2): 48..50, match(2): [91..95, 80..87 ] }
    match: [ eg_md.port.0-7(3..7), eg_md.pkt_src ]
    hit: [  tbl_act_28 ]
    miss:  tbl_act_28
    action_bus: { 40..41 : dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas(0..15) }
    stateful: dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas(meter_addr, meter_pfe, meter_type)
    instruction: dtel_queue_report_check_quota(action, $DEFAULT)
    actions:
      NoAction(0, 4):
      - default_action: { allowed: true }
      - handle: 0x200000ec
      - next_table: 0
      - set hdr.dtel.reserved, 0
      - set hdr.dtel.seq_number, 0
      - set hdr.dtel.timestamp, 0
      - set hdr.dtel.switch_id, 0
      SwitchEgress.dtel.queue_report.reset_quota_(1, 6):
      - p4_param_order: { index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000ed
      - next_table: 0
      - { index: meter_addr }
      - set dtel_queue_report_flag, dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas
      - set hdr.dtel.reserved, 0
      - set hdr.dtel.seq_number, 0
      - set hdr.dtel.timestamp, 0
      - set hdr.dtel.switch_id, 0
      - dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas(1, index)
      SwitchEgress.dtel.queue_report.update_quota_(2, 8):
      - p4_param_order: { index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000ee
      - next_table: 0
      - { index: meter_addr }
      - set dtel_queue_report_flag, dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas
      - set hdr.dtel.reserved, 0
      - set hdr.dtel.seq_number, 0
      - set hdr.dtel.timestamp, 0
      - set hdr.dtel.switch_id, 0
      - or B33, 2, B33
      - dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas(3, index)
      SwitchEgress.dtel.queue_report.check_latency_and_update_quota_(3, 10):
      - p4_param_order: { index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000ef
      - next_table: 0
      - { index: meter_addr }
      - set dtel_queue_report_flag, dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas
      - set hdr.dtel.reserved, 0
      - set hdr.dtel.seq_number, 0
      - set hdr.dtel.timestamp, 0
      - set hdr.dtel.switch_id, 0
      - or B33, 2, B33
      - dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas(5, index)
    default_action: NoAction
  stateful dtel_queue_report_check_quota$salu.SwitchEgress.dtel.queue_report.quotas:
    p4: { name: SwitchEgress.dtel.queue_report.quotas, size: 2048 }
    row: 7
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    input_xbar:
      exact group 2: { 0: eg_md.dtel.latency, 43: dtel_queue_report_quota }
      hash 4:
        0..31: eg_md.dtel.latency
        32..47: dtel_queue_report_quota
      hash group 4:
        table: [4]
        seed: 0x0
    format: { lo: 32, hi:32 }
    actions:
      dtel_queue_report_reset_quota_0:
      - alu_a lo, phv_hi(0..15)
      dtel_queue_report_update_quota_0:
      - grt.u lo, lo
      - add cmplo, lo, lo, 4294967295
      - output cmplo, predicate
      dtel_queue_report_check_latency_and_update_quota_0:
      - grt.u lo, lo
      - add cmplo, lo, lo, 4294967295
      - neq hi, hi, -phv_lo
      - alu_a cmphi, hi, phv_lo
      - output cmplo | cmphi, predicate
    pred_shift: 28
    pred_comb_shift: 0
  hash_action tbl_act_28 9:
    p4: { name: tbl_act_28 }
    row: 5
    bus: 1
    hash_dist:
      0: { hash: 5, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 3: { 0: eg_md.dtel.latency, 32: eg_md.dtel.hash.0-15, 48: eg_md.dtel.hash.16-31, 64: eg_md.ingress_port, 80: eg_md.port.8-8, 88: eg_md.port.0-7 }
      hash 6:
        0..15: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 82, { 0: eg_md.dtel.hash.0-15, 16: eg_md.dtel.hash.16-31, 50: eg_md.dtel.latency }, { })), 0..15)
      hash 7:
        0..15: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 82, { 32: eg_md.port.0-7, 40: eg_md.port.8-8, 41: eg_md.ingress_port }, { })), 0..15)
      hash group 5:
        table: [6, 7]
        seed: 0x0
    gateway:
      name: cond-64
      input_xbar:
        exact group 1: { 96: eg_md.pkt_src }
      row: 3
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 0: eg_md.pkt_src }
      0x00:  tbl_act_29
      miss: run_table
      condition: 
        expression: "(eg_md.pkt_src == 0)"
        true:  tbl_act_29
        false:  rewrite_egress_bd_bd_mapping
    next:  rewrite_egress_bd_bd_mapping
    action_bus: { 44..45 : hash_dist(0, lo) }
    instruction: tbl_act_28(action, $DEFAULT)
    actions:
      act_29(1, 5):
      - default_action: { allowed: true }
      - handle: 0x200000f0
      - next_table: 0
      - set H81, hash_dist(0, 0..15)
    default_action: act_29
stage 6 egress:
  hash_action tbl_act_29 0:
    p4: { name: tbl_act_29 }
    row: 1
    bus: 1
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 0: eg_md.dtel.hash.0-15 }
      hash 0:
        0..15: stripe(eg_md.dtel.hash.0-15)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: cond-65
      input_xbar:
        exact group 0: { 80: eg_md.dtel.report_type }
      row: 5
      bus: 0
      unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 0: eg_md.dtel.report_type }
      0b****0**1:  tbl_act_30
      miss: run_table
      condition: 
        expression: "(eg_md.dtel.report_type & 9 == 1)"
        true:  tbl_act_30
        false:  tbl_act_30
    next:  tbl_act_30
    action_bus: { 0 : tbl_act_29$salu.SwitchEgress.dtel.flow_report.array1(0..7) }
    stateful: tbl_act_29$salu.SwitchEgress.dtel.flow_report.array1(hash_dist 0, meter_pfe, meter_type)
    instruction: tbl_act_29(action, $DEFAULT)
    actions:
      act_28(1, 1):
      - default_action: { allowed: true }
      - handle: 0x200000f1
      - next_table: 0
      - set dtel_flow_report_flag, tbl_act_29$salu.SwitchEgress.dtel.flow_report.array1
      - tbl_act_29$salu.SwitchEgress.dtel.flow_report.array1(1, $hash_dist)
    default_action: act_28
  stateful tbl_act_29$salu.SwitchEgress.dtel.flow_report.array1:
    p4: { name: SwitchEgress.dtel.flow_report.array1, size: 65536 }
    row: [ 15, 13 ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 3, 4, 5 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 3, 4, 5 ]
    input_xbar:
      exact group 0: { 64: dtel_flow_report_digest }
    format: { lo: 16 }
    actions:
      dtel_flow_report_filter1:
      - equ lo, lo
      - alu_a cmplo, hi, 2
      - equ hi, lo, -phv_lo
      - alu_a !cmplo & cmphi, hi, 1
      - alu_a lo, phv_lo
      - output cmplo | !cmplo & cmphi, alu_hi
stage 7 egress:
  hash_action tbl_act_30 0:
    p4: { name: tbl_act_30 }
    row: 2
    bus: 1
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 0: eg_md.dtel.hash.16-31 }
      hash 0:
        0..15: stripe(eg_md.dtel.hash.16-31)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: cond-66
      input_xbar:
        exact group 0: { 80: eg_md.dtel.report_type }
      row: 5
      bus: 1
      unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 0: eg_md.dtel.report_type }
      0b****0**1:  rewrite_egress_bd_bd_mapping
      miss: run_table
      condition: 
        expression: "(eg_md.dtel.report_type & 9 == 1)"
        true:  rewrite_egress_bd_bd_mapping
        false:  rewrite_egress_bd_bd_mapping
    next:  rewrite_egress_bd_bd_mapping
    action_bus: { 0 : tbl_act_30$salu.SwitchEgress.dtel.flow_report.array2(0..7) }
    stateful: tbl_act_30$salu.SwitchEgress.dtel.flow_report.array2(hash_dist 0, meter_pfe, meter_type)
    instruction: tbl_act_30(action, $DEFAULT)
    actions:
      act_30(1, 1):
      - default_action: { allowed: true }
      - handle: 0x200000f2
      - next_table: 0
      - or B42, tbl_act_30$salu.SwitchEgress.dtel.flow_report.array2, B42
      - tbl_act_30$salu.SwitchEgress.dtel.flow_report.array2(1, $hash_dist)
    default_action: act_30
  stateful tbl_act_30$salu.SwitchEgress.dtel.flow_report.array2:
    p4: { name: SwitchEgress.dtel.flow_report.array2, size: 65536 }
    row: [ 15, 13 ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    input_xbar:
      exact group 0: { 64: dtel_flow_report_digest }
    format: { lo: 16 }
    actions:
      dtel_flow_report_filter2:
      - equ lo, lo
      - alu_a cmplo, hi, 2
      - equ hi, lo, -phv_lo
      - alu_a !cmplo & cmphi, hi, 1
      - alu_a lo, phv_lo
      - output cmplo | !cmplo & cmphi, alu_hi
  exact_match rewrite_egress_bd_bd_mapping 1:
    p4: { name: SwitchEgress.rewrite.egress_bd.bd_mapping, size: 5120 }
    p4_param_order: 
      eg_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
    row: [ 7, 5 ]
    bus: [ 0, 1 ]
    column:
    - [ 2, 3, 4 ]
    - [ 3, 4 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [1, 0, 0x1, [7, 2], [7, 3]]
      - [1, 1, 0x0, [7, 4]]
      - [1, 2, 0x0, [5, 3]]
      - [1, 3, 0x0, [5, 4]]
    input_xbar:
      exact group 0: { 88: eg_md.bd(8..15), 96: eg_md.bd(0..7) }
      hash 1:
        0..1: random(eg_md.bd(10..15)) ^ eg_md.bd(8..9)
        2..9: random(eg_md.bd(10..15)) ^ eg_md.bd(0..7)
        40: random(eg_md.bd(10..15))
        11..12: random(eg_md.bd(10..15)) ^ eg_md.bd(8..9)
        13..19: random(eg_md.bd(10..15)) ^ eg_md.bd(0..6)
        10: random(eg_md.bd(10..15)) ^ eg_md.bd(7)
        22..23: random(eg_md.bd(10..15)) ^ eg_md.bd(8..9)
        24..29: random(eg_md.bd(10..15)) ^ eg_md.bd(0..5)
        20..21: random(eg_md.bd(10..15)) ^ eg_md.bd(6..7)
        33..34: random(eg_md.bd(10..15)) ^ eg_md.bd(8..9)
        35..39: random(eg_md.bd(10..15)) ^ eg_md.bd(0..4)
        30..32: random(eg_md.bd(10..15)) ^ eg_md.bd(5..7)
      hash group 1:
        table: [1]
        seed: 0x16daef7abd7
    format: { action(0): 0..0, immediate(0): 1..32, version(0): 112..115, match(0): 34..39 }
    match: [ eg_md.bd(10..15) ]
    hit: [  rewrite_ip_rewrite ]
    miss:  rewrite_ip_rewrite
    action_bus: { 64..65 : immediate(0..15), 66..67 : immediate(16..31) }
    instruction: rewrite_egress_bd_bd_mapping(action, $DEFAULT)
    actions:
      NoAction(0, 2):
      - default_action: { allowed: true }
      - handle: 0x200000d0
      - next_table: 0
      - {  }
      - set rewrite_smac_index, 0
      SwitchEgress.rewrite.egress_bd.set_bd_properties(1, 4):
      - p4_param_order: { bd_label: 16, smac_index: 16, mtu_index: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000d1
      - next_table: 0
      - { mtu_index: immediate(0..15), smac_index: immediate(16..31) }
      - set rewrite_smac_index, smac_index
      - set eg_md.checks.mtu, mtu_index
    default_action: NoAction
  exact_match rewrite_ip_rewrite 12:
    p4: { name: SwitchEgress.rewrite.ip_rewrite }
    p4_param_order: 
      hdr.ipv4.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.ipv6.$valid: { type: exact, size: 1, full_size: 1 }
    row: 4
    bus: 0
    column: 2
    stash: 
      row: [ 4 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [3, 2, 0x0, [4, 2]]
    input_xbar:
      exact group 1: { 81: hdr.ipv4.$valid, 98: hdr.ipv6.$valid }
      hash 3:
        20: hdr.ipv4.$valid
        21: hdr.ipv6.$valid
      hash group 3:
        table: [3]
        seed: 0x0
    format: { action(0): 0..1, version(0): 112..115 }
    gateway:
      name: cond-56
      input_xbar:
        exact group 1: { 32: eg_md.bypass(0), 48: eg_md.flags.routed }
      row: 1
      bus: 0
      unit: 0
      match: { 0: eg_md.bypass(0), 8: eg_md.flags.routed }
      0b*******1*******0: run_table
      miss:  dtel_config
      condition: 
        expression: "(eg_md.bypass & 1 == 0 && eg_md.flags.routed)"
        true:  rewrite_ip_rewrite
        false:  dtel_config
    hit: [  rewrite_smac_rewrite ]
    miss:  rewrite_smac_rewrite
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x1"
        - field_name: hdr.ipv6.$valid
          value: "0x0"
        action_handle: 0x200000d4
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x0"
        - field_name: hdr.ipv6.$valid
          value: "0x1"
        action_handle: 0x200000d5
        is_default_entry: false
        action_parameters_values: []
    instruction: rewrite_ip_rewrite(action, $DEFAULT)
    actions:
      SwitchEgress.rewrite.rewrite_ipv4(1, 3):
      - default_action: { allowed: true }
      - handle: 0x200000d4
      - next_table: 0
      - add hdr.ipv4.ttl, hdr.ipv4.ttl, 255
      SwitchEgress.rewrite.rewrite_ipv6(2, 5):
      - default_action: { allowed: true }
      - handle: 0x200000d5
      - next_table: 0
      - add hdr.ipv6.hop_limit, hdr.ipv6.hop_limit, 255
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x200000d6
      - next_table: 0
    default_only_action: NoAction
stage 8 egress:
  exact_match rewrite_smac_rewrite 1:
    p4: { name: SwitchEgress.rewrite.smac_rewrite }
    p4_param_order: 
      rewrite_smac_index: { type: exact, size: 16, full_size: 16, key_name: "smac_index" }
    row: [ 4, 3 ]
    bus: [ 1, 0 ]
    column:
    - [ 3, 4, 6 ]
    - 2
    stash: 
      row: [ 3 ]
      col: [ 2 ]
      unit: [ 1 ]
    ways:
      - [1, 0, 0x0, [3, 2]]
      - [1, 1, 0x0, [4, 6]]
      - [1, 2, 0x0, [4, 4]]
      - [1, 3, 0x0, [4, 3]]
    input_xbar:
      exact group 0: { 64: rewrite_smac_index }
      hash 1:
        0..7: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(0..7)
        8..9: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(8..9)
        11..18: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(0..7)
        19: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(8)
        10: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(9)
        22..29: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(0..7)
        20..21: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(8..9)
        33..39: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(0..6)
        30: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(7)
        31..32: random(rewrite_smac_index(10..15)) ^ rewrite_smac_index(8..9)
      hash group 1:
        table: [1]
        seed: 0x4dac44e2ef
    format: { action(0): 0..0, immediate(0): 1..32, version(0): 112..115, match(0): 34..39 }
    match: [ rewrite_smac_index(10..15) ]
    hit: [  dtel_config ]
    miss:  dtel_config
    action_bus: { 96..99 : immediate(0..31) }
    action: rewrite_smac_rewrite$action_data($DIRECT, $DEFAULT)
    instruction: rewrite_smac_rewrite(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000d7
      - next_table: 0
      - {  }
      SwitchEgress.rewrite.rewrite_smac(1, 1):
      - p4_param_order: { smac: 48 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000d8
      - next_table: 0
      - { smac.0-15: $adf_h0(0..15), smac.16-47: immediate(0..31) }
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
    default_action: NoAction
  action rewrite_smac_rewrite$action_data:
    p4: { name: SwitchEgress.rewrite.smac_rewrite$action }
    row: 12
    column: 5
    vpns: [ 0 ]
    home_row:
    - 12
    format SwitchEgress.rewrite.rewrite_smac: { $adf_h0: 0..15 }
    action_bus: { 32..33 : $adf_h0 }
  ternary_match dtel_config 2:
    p4: { name: SwitchEgress.dtel.config }
    p4_param_order: 
      eg_md.pkt_src: { type: ternary, size: 8, full_size: 8 }
      eg_md.dtel.report_type: { type: ternary, size: 4, full_size: 4 }
      dtel_drop_report_flag: { type: ternary, size: 2, full_size: 2, key_name: "drop_report_flag" }
      dtel_flow_report_flag: { type: ternary, size: 2, full_size: 2, key_name: "flow_report_flag" }
      dtel_queue_report_flag: { type: ternary, size: 1, full_size: 1, key_name: "queue_report_flag" }
    row: 9
    bus: 0
    column: 0
    hash_dist:
      0: { hash: 2, mask: 0x3ff, shift: 5 }
    input_xbar:
      ternary group 0: { 0: dtel_queue_report_flag, 11: dtel_drop_report_flag, 16: eg_md.dtel.report_type, 24: dtel_flow_report_flag, 32: eg_md.pkt_src }
      exact group 1: { 0: eg_md.dtel.session_id }
      hash 2:
        0..9: stripe(eg_md.dtel.session_id)
      hash group 2:
        table: [2]
        seed: 0x0
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x155 }
    hit: [  mtu_mtu ]
    miss:  mtu_mtu
    indirect: dtel_config$tind
  stateful dtel_config$salu.SwitchEgress.dtel.seq_number:
    p4: { name: SwitchEgress.dtel.seq_number, size: 1024 }
    row: 11
    column: [ 1, 2 ]
    maprams: [ 1, 2 ]
    format: { lo: 32 }
    actions:
      dtel_get_seq_number:
      - add lo, lo, 1
      - output alu_lo
  ternary_indirect dtel_config$tind:
    row: 0
    bus: 1
    column: 3
    hash_dist:
      0: { hash: 2, mask: 0x3ff, shift: 5 }
    input_xbar:
      ternary group 0: { 0: dtel_queue_report_flag, 11: dtel_drop_report_flag, 16: eg_md.dtel.report_type, 24: dtel_flow_report_flag, 32: eg_md.pkt_src }
      exact group 1: { 0: eg_md.dtel.session_id }
      hash 2:
        0..9: stripe(eg_md.dtel.session_id)
      hash group 2:
        table: [2]
        seed: 0x0
    format: { action: 0..1, meter_pfe: 2..2 }
    action_bus: { 112..115 : dtel_config$salu.SwitchEgress.dtel.seq_number(0..31) }
    stateful: dtel_config$salu.SwitchEgress.dtel.seq_number(hash_dist 0, meter_pfe, $DEFAULT)
    action: dtel_config$action_data($DIRECT, $DEFAULT)
    instruction: dtel_config$tind(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000f7
      - next_table: 0
      - {  }
      SwitchEgress.dtel.drop(1, 2):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000f8
      - next_table: 0
      - {  }
      - set eg_intr_md_for_dprsr.drop_ctl, 1
      SwitchEgress.dtel.mirror(2, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000f9
      - next_table: 0
      - {  }
      - set eg_md.mirror.type, 4
      - set eg_md.mirror.src, 2
      SwitchEgress.dtel.update(3, 4):
      - p4_param_order: { switch_id: 32, hw_id: 6, next_proto: 4, report_type: 4 }
      - default_action: { allowed: false, reason: uses_hash_dist }
      - handle: 0x200000fa
      - next_table: 0
      - { $data0: $adf_f0(0..31), hw_id: $data0(0..5), $constant1: $data0(6..20), $constant1: 0, report_type.0-2: $data0(21..23), next_proto: $data0(24..27), $constant0: $data0(28..31), $constant0: 0, switch_id: $adf_f1(0..31) }
      - set hdr.dtel.$valid, 1
      - set hdr.dtel.seq_number, dtel_config$salu.SwitchEgress.dtel.seq_number
      - set hdr.dtel.timestamp, eg_md.ingress_timestamp.0-31
      - set hdr.dtel.switch_id, switch_id
      - set W25, $data0
      - dtel_config$salu.SwitchEgress.dtel.seq_number(1, $hash_dist)
    default_action: NoAction
  action dtel_config$action_data:
    p4: { name: SwitchEgress.dtel.config$action }
    row: 14
    column: 5
    vpns: [ 0 ]
    home_row:
    - 14
    format SwitchEgress.dtel.update: { $adf_f0: 0..31, $adf_f1: 32..63 }
    action_bus: { 104..107 : $adf_f0, 108..111 : $adf_f1 }
  exact_match mtu_mtu 3:
    p4: { name: SwitchEgress.mtu.mtu, size: 1024 }
    p4_param_order: 
      eg_md.checks.mtu: { type: exact, size: 16, full_size: 16, key_name: "mtu_check" }
      hdr.ipv4.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.ipv6.$valid: { type: exact, size: 1, full_size: 1 }
    row: 3
    bus: 1
    column: [ 3, 4, 6 ]
    stash: 
      row: [ 3 ]
      col: [ 6 ]
      unit: [ 0 ]
    ways:
      - [3, 0, 0x0, [3, 6]]
      - [3, 1, 0x0, [3, 4]]
      - [3, 2, 0x0, [3, 3]]
    input_xbar:
      exact group 1: { 66: hdr.ipv6.$valid, 72: eg_md.checks.mtu(8..15), 80: eg_md.checks.mtu(0..7), 89: hdr.ipv4.$valid }
      hash 3:
        0: random(eg_md.checks.mtu(8..15)) ^ hdr.ipv6.$valid
        1..8: random(eg_md.checks.mtu(8..15)) ^ eg_md.checks.mtu(0..7)
        9: random(eg_md.checks.mtu(8..15)) ^ hdr.ipv4.$valid
        11: random(eg_md.checks.mtu(8..15)) ^ hdr.ipv6.$valid
        12..19: random(eg_md.checks.mtu(8..15)) ^ eg_md.checks.mtu(0..7)
        10: random(eg_md.checks.mtu(8..15)) ^ hdr.ipv4.$valid
        22: random(eg_md.checks.mtu(8..15)) ^ hdr.ipv6.$valid
        23..29: random(eg_md.checks.mtu(8..15)) ^ eg_md.checks.mtu(0..6)
        20: random(eg_md.checks.mtu(8..15)) ^ eg_md.checks.mtu(7)
        21: random(eg_md.checks.mtu(8..15)) ^ hdr.ipv4.$valid
      hash group 3:
        table: [3]
        seed: 0x23dd580c
    format: { action(0): 0..1, immediate(0): 6..21, version(0): 112..115, match(0): 56..63, action(1): 2..3, immediate(1): 22..37, version(1): 116..119, match(1): 64..71, action(2): 4..5, immediate(2): 38..53, version(2): 120..123, match(2): 72..79 }
    match: [ eg_md.checks.mtu(8..15) ]
    gateway:
      name: cond-57
      input_xbar:
        exact group 1: { 102: eg_md.bypass(6) }
      row: 1
      bus: 1
      unit: 0
      match: { 6: eg_md.bypass(6) }
      0b*0: run_table
      miss:  rewrite_egress_bd_bd_stats
      condition: 
        expression: "(eg_md.bypass & 64 == 0)"
        true:  mtu_mtu
        false:  rewrite_egress_bd_bd_stats
    hit: [  rewrite_egress_bd_bd_stats ]
    miss:  rewrite_egress_bd_bd_stats
    action_bus: { 36..37 : immediate(0..15) }
    instruction: mtu_mtu(action, $DEFAULT)
    actions:
      SwitchEgress.mtu.ipv4_mtu_check(1, 5):
      - p4_param_order: { mtu: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000d9
      - next_table: 0
      - { mtu: immediate(0..15) }
      - ssubu eg_md.checks.mtu, mtu, hdr.ipv4.total_len
      SwitchEgress.mtu.ipv6_mtu_check(2, 6):
      - p4_param_order: { mtu: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000da
      - next_table: 0
      - { mtu: immediate(0..15) }
      - ssubu eg_md.checks.mtu, mtu, hdr.ipv6.payload_len
      SwitchEgress.mtu.mtu_miss(3, 8):
      - default_action: { allowed: true }
      - handle: 0x200000db
      - next_table: 0
      - {  }
      - set eg_md.checks.mtu, 65535
    default_action: SwitchEgress.mtu.mtu_miss
  exact_match rewrite_egress_bd_bd_stats 8:
    p4: { name: SwitchEgress.rewrite.egress_bd.bd_stats, size: 15360 }
    p4_param_order: 
      eg_md.bd: { type: exact, size: 16, full_size: 16, key_name: "bd" }
      eg_md.pkt_type: { type: exact, size: 2, full_size: 2, key_name: "pkt_type" }
    row: 1
    bus: 0
    column: [ 2, 3, 4, 6 ]
    stash: 
      row: [ 1 ]
      col: [ 6 ]
      unit: [ 0 ]
    ways:
      - [7, 0, 0x0, [1, 6]]
      - [7, 1, 0x0, [1, 4]]
      - [7, 2, 0x0, [1, 3]]
      - [7, 3, 0x0, [1, 2]]
    input_xbar:
      exact group 3: { 64: eg_md.bd, 81: eg_md.pkt_type }
      hash 7:
        0..7: random(eg_md.bd(8..15)) ^ eg_md.bd(0..7)
        8..9: random(eg_md.bd(8..15)) ^ eg_md.pkt_type
        11..18: random(eg_md.bd(8..15)) ^ eg_md.bd(0..7)
        19: random(eg_md.bd(8..15)) ^ eg_md.pkt_type(0)
        10: random(eg_md.bd(8..15)) ^ eg_md.pkt_type(1)
        22..29: random(eg_md.bd(8..15)) ^ eg_md.bd(0..7)
        20..21: random(eg_md.bd(8..15)) ^ eg_md.pkt_type
        33..39: random(eg_md.bd(8..15)) ^ eg_md.bd(0..6)
        30: random(eg_md.bd(8..15)) ^ eg_md.bd(7)
        31..32: random(eg_md.bd(8..15)) ^ eg_md.pkt_type
      hash group 7:
        table: [7]
        seed: 0x497609fd63
    format: { action(0): 0..0, version(0): 112..115, match(0): 32..39, action(1): 1..1, version(1): 116..119, match(1): 40..47, action(2): 2..2, version(2): 120..123, match(2): 48..55, action(3): 3..3, version(3): 124..127, match(3): 56..63 }
    match: [ eg_md.bd(8..15) ]
    gateway:
      name: cond-55
      input_xbar:
        exact group 1: { 104: eg_md.pkt_src }
      row: 0
      bus: 0
      unit: 0
      match: { 0: eg_md.pkt_src }
      0x00: run_table
      miss:  dtel_egress_port_conversion2
      condition: 
        expression: "(eg_md.pkt_src == 0)"
        true:  rewrite_egress_bd_bd_stats
        false:  dtel_egress_port_conversion2
    hit: [  dtel_egress_port_conversion2 ]
    miss:  dtel_egress_port_conversion2
    stats: rewrite_egress_bd_bd_stats$stats.SwitchEgress.rewrite.egress_bd.stats($DIRECT, $DEFAULT)
    instruction: rewrite_egress_bd_bd_stats(action, $DEFAULT)
    actions:
      SwitchEgress.rewrite.egress_bd.count(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000d2
      - next_table: 0
      - rewrite_egress_bd_bd_stats$stats.SwitchEgress.rewrite.egress_bd.stats($DIRECT)
      NoAction(-1, 7):
      - default_only_action: { allowed: true }
      - handle: 0x200000d3
      - next_table: 0
    default_only_action: NoAction
  counter rewrite_egress_bd_bd_stats$stats.SwitchEgress.rewrite.egress_bd.stats:
    p4: { name: SwitchEgress.rewrite.egress_bd.stats }
    row: [ 13, 11, 9 ]
    column:
    - [ 1, 2, 3, 4, 5 ]
    - [ 3, 4, 5 ]
    - 1
    maprams: 
    - [ 1, 2, 3, 4, 5 ]
    - [ 3, 4, 5 ]
    - 1
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
    lrt:
    - { threshold: 338078240, interval: 21129984 }
    - { threshold: 338078240, interval: 21129984 }
    - { threshold: 338078240, interval: 21129984 }
  exact_match dtel_egress_port_conversion2 9:
    p4: { name: SwitchEgress.dtel.egress_port_conversion2 }
    p4_param_order: 
      hdr.dtel_switch_local_report.egress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 2
    bus: 0
    column: 2
    stash: 
      row: [ 2 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [5, 2, 0x0, [2, 2]]
    input_xbar:
      exact group 2: { 64: hdr.dtel_switch_local_report.egress_port }
      hash 5:
        20..27: hdr.dtel_switch_local_report.egress_port(0..7)
        28: hdr.dtel_switch_local_report.egress_port(8)
      hash group 5:
        table: [5]
        seed: 0x0
    format: { action(0): 0..1, immediate(0): 2..10, version(0): 112..115 }
    gateway:
      name: cond-67
      input_xbar:
        exact group 1: { 67: hdr.dtel_switch_local_report.$valid }
      row: 3
      bus: 1
      unit: 0
      match: { 3: hdr.dtel_switch_local_report.$valid }
      0b****1: run_table
      miss:  system_acl_system_acl_0
      condition: 
        expression: "(hdr.dtel_switch_local_report.$valid == 1)"
        true:  dtel_egress_port_conversion2
        false:  system_acl_system_acl_0
    hit: [  dtel_ingress_port_conversion2 ]
    miss:  dtel_ingress_port_conversion2
    action_bus: { 48..49 : immediate(0..8) }
    instruction: dtel_egress_port_conversion2(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000f5
      - next_table: 0
      - {  }
      SwitchEgress.dtel.convert_egress_port2(2, 9):
      - p4_param_order: { port: 9 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000f6
      - next_table: 0
      - { port: immediate(0..8) }
      - set hdr.dtel_switch_local_report.egress_port, port
    default_action: NoAction
  exact_match dtel_ingress_port_conversion2 10:
    p4: { name: SwitchEgress.dtel.ingress_port_conversion2 }
    p4_param_order: 
      hdr.dtel_switch_local_report.ingress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: 5
    bus: 0
    column: 2
    stash: 
      row: [ 5 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - [5, 3, 0x0, [5, 2]]
    input_xbar:
      exact group 2: { 96: hdr.dtel_switch_local_report.ingress_port }
      hash 5:
        30..37: hdr.dtel_switch_local_report.ingress_port(0..7)
        38: hdr.dtel_switch_local_report.ingress_port(8)
      hash group 5:
        table: [5]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 1..9, version(0): 112..115 }
    hit: [  system_acl_system_acl_0 ]
    miss:  system_acl_system_acl_0
    action_bus: { 52..53 : immediate(0..8) }
    instruction: dtel_ingress_port_conversion2(action, $DEFAULT)
    actions:
      NoAction(0, 0):
      - default_action: { allowed: true }
      - handle: 0x200000f3
      - next_table: 0
      - {  }
      SwitchEgress.dtel.convert_ingress_port2(1, 10):
      - p4_param_order: { port: 9 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000f4
      - next_table: 0
      - { port: immediate(0..8) }
      - set hdr.dtel_switch_local_report.ingress_port, port
    default_action: NoAction
stage 9 egress:
  ternary_match system_acl_system_acl_0 0:
    p4: { name: SwitchEgress.system_acl.system_acl, size: 512 }
    p4_param_order: 
      eg_intr_md.egress_port: { type: ternary, size: 9, full_size: 9 }
      eg_md.flags.acl_deny: { type: ternary, size: 1, full_size: 1 }
      eg_md.checks.mtu: { type: ternary, size: 16, full_size: 16 }
      eg_md.checks.stp: { type: ternary, size: 1, full_size: 1 }
    row: [ 10, 11 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: eg_md.checks.mtu, 16: eg_intr_md.egress_port(0..7), 26: eg_md.checks.stp, 38: eg_md.flags.acl_deny }
      byte group 0: { 0: eg_intr_md.egress_port(8) }
    match:
    - { group: 0, byte_group: 0, byte_config: 0, dirtcam: 0x555 }
    - { byte_config: 3, dirtcam: 0x0 }
    gateway:
      name: cond-68
      input_xbar:
        exact group 0: { 2: eg_md.bypass(2) }
      row: 0
      bus: 1
      unit: 1
      match: { 2: eg_md.bypass(2) }
      0b*****0: run_table
      miss:  tbl_set_eg_intr_md
      condition: 
        expression: "(eg_md.bypass & 4 == 0)"
        true:  system_acl_system_acl_0
        false:  tbl_set_eg_intr_md
    hit: [  tbl_set_eg_intr_md ]
    miss:  tbl_set_eg_intr_md
    indirect: system_acl_system_acl_0$tind
  ternary_indirect system_acl_system_acl_0$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: eg_md.checks.mtu, 16: eg_intr_md.egress_port(0..7), 26: eg_md.checks.stp, 38: eg_md.flags.acl_deny }
      byte group 0: { 0: eg_intr_md.egress_port(8) }
    format: { action: 0..2, immediate: 3..34 }
    action_bus: { 0 : immediate(0..7), 64..65 : immediate(0..15), 66..67 : immediate(16..31) }
    instruction: system_acl_system_acl_0$tind(action, $DEFAULT)
    actions:
      NoAction(1, 0):
      - default_action: { allowed: true }
      - handle: 0x200000fb
      - next_table: 0
      - {  }
      SwitchEgress.system_acl.drop(2, 1):
      - p4_param_order: { reason_code: 8 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000fc
      - next_table: 0
      - { reason_code: immediate(0..7) }
      - set eg_md.drop_reason, reason_code
      - set eg_intr_md_for_dprsr.drop_ctl, 1
      SwitchEgress.system_acl.copy_to_cpu(3, 2):
      - p4_param_order: { reason_code: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000fd
      - next_table: 0
      - { $constant0: immediate(0..9), $constant0: 250, reason_code: immediate(16..31) }
      - set eg_md.cpu_reason, reason_code
      - set eg_md.mirror.type, 2
      - set eg_md.mirror.session_id, $constant0
      - set eg_md.mirror.src, 2
      SwitchEgress.system_acl.redirect_to_cpu(4, 4):
      - p4_param_order: { reason_code: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000fe
      - next_table: 0
      - { $constant0: immediate(0..9), $constant0: 250, reason_code: immediate(16..31) }
      - set eg_md.cpu_reason, reason_code
      - set eg_md.mirror.type, 2
      - set eg_md.mirror.session_id, $constant0
      - set eg_md.mirror.src, 2
      - set eg_intr_md_for_dprsr.drop_ctl, 1
      SwitchEgress.system_acl.insert_timestamp(5, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x200000ff
      - next_table: 0
      - {  }
    default_action: NoAction
stage 10 egress:
  ternary_match tbl_set_eg_intr_md 0:
    p4: { name: tbl_set_eg_intr_md }
    hit: [  system_acl_drop_stats_0 ]
    miss:  system_acl_drop_stats_0
    indirect: tbl_set_eg_intr_md$tind
  ternary_indirect tbl_set_eg_intr_md$tind:
    row: 1
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_set_eg_intr_md$tind(action, $DEFAULT)
    actions:
      set_eg_intr_md(0, 1):
      - default_action: { allowed: true }
      - handle: 0x20000102
      - next_table: 0
      - set eg_intr_md_for_dprsr.mirror_type, eg_md.mirror.type(0..2)
    default_action: set_eg_intr_md
  exact_match system_acl_drop_stats_0 1:
    p4: { name: SwitchEgress.system_acl.drop_stats, size: 8192 }
    p4_param_order: 
      eg_md.drop_reason: { type: exact, size: 8, full_size: 8, key_name: "drop_reason" }
      eg_intr_md.egress_port: { type: exact, size: 9, full_size: 9, key_name: "port" }
    row: [ 6, 5 ]
    bus: [ 1, 0 ]
    column:
    - [ 3, 4 ]
    - [ 2, 3 ]
    stash: 
      row: [ 6 ]
      col: [ 3 ]
      unit: [ 0 ]
    ways:
      - [0, 0, 0x0, [6, 3]]
      - [0, 1, 0x0, [6, 4]]
      - [0, 2, 0x0, [5, 2]]
      - [0, 3, 0x0, [5, 3]]
    input_xbar:
      exact group 0: { 0: eg_intr_md.egress_port, 16: eg_md.drop_reason }
      hash 0:
        0: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(0)
        1: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(8)
        2..9: random(eg_intr_md.egress_port(1..7)) ^ eg_md.drop_reason
        11: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(0)
        12: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(8)
        13..19: random(eg_intr_md.egress_port(1..7)) ^ eg_md.drop_reason(0..6)
        10: random(eg_intr_md.egress_port(1..7)) ^ eg_md.drop_reason(7)
        22: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(0)
        23: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(8)
        24..29: random(eg_intr_md.egress_port(1..7)) ^ eg_md.drop_reason(0..5)
        20..21: random(eg_intr_md.egress_port(1..7)) ^ eg_md.drop_reason(6..7)
        33: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(0)
        34: random(eg_intr_md.egress_port(1..7)) ^ eg_intr_md.egress_port(8)
        35..39: random(eg_intr_md.egress_port(1..7)) ^ eg_md.drop_reason(0..4)
        30..32: random(eg_intr_md.egress_port(1..7)) ^ eg_md.drop_reason(5..7)
      hash group 0:
        table: [0]
        seed: 0xd97c73b425
    format: { version(0): 112..115, match(0): 33..39, version(1): 116..119, match(1): 41..47 }
    match: [ eg_intr_md.egress_port(1..7) ]
    hit: [  END ]
    miss:  END
    stats: system_acl_drop_stats_0$stats.SwitchEgress.system_acl.stats($DIRECT, $DEFAULT)
    instruction: system_acl_drop_stats_0($DEFAULT, $DEFAULT)
    actions:
      NoAction(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000100
      - next_table: 0
      SwitchEgress.system_acl.count(0, 2):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000101
      - next_table: 0
      - system_acl_drop_stats_0$stats.SwitchEgress.system_acl.stats($DIRECT)
    default_only_action: NoAction
  counter system_acl_drop_stats_0$stats.SwitchEgress.system_acl.stats:
    p4: { name: SwitchEgress.system_acl.stats }
    row: 9
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 22349296, interval: 268435200 }
    - { threshold: 22349296, interval: 268435200 }
    - { threshold: 22349296, interval: 268435200 }

flexible_headers: [

  { name: "hdr.bridged_md",
    fields: [

      { name: "src", slice: { start_bit: 0, bit_width: 8 } },
      { name: "type", slice: { start_bit: 0, bit_width: 8 } },
      { name: "base_ingress_ifindex", slice: { start_bit: 0, bit_width: 16 } },
      { name: "base_ingress_bd", slice: { start_bit: 0, bit_width: 16 } },
      { name: "base_nexthop", slice: { start_bit: 0, bit_width: 16 } },
      { name: "base_cpu_reason", slice: { start_bit: 0, bit_width: 16 } },
      { name: "base_timestamp", slice: { start_bit: 0, bit_width: 48 } },
      { name: "base_tc", slice: { start_bit: 0, bit_width: 8 } },
      { name: "dtel_hash", slice: { start_bit: 0, bit_width: 32 } },
      { name: "__pad_0", slice: { start_bit: 0, bit_width: 2 } },
      { name: "base_color", slice: { start_bit: 0, bit_width: 2 } },
      { name: "base_peer_link", slice: { start_bit: 0, bit_width: 1 } },
      { name: "base_pkt_type", slice: { start_bit: 0, bit_width: 2 } },
      { name: "base_routed", slice: { start_bit: 0, bit_width: 1 } },
      { name: "__pad_1", slice: { start_bit: 0, bit_width: 4 } },
      { name: "dtel_report_type", slice: { start_bit: 0, bit_width: 4 } },
      { name: "__pad_2", slice: { start_bit: 0, bit_width: 3 } },
      { name: "base_qid", slice: { start_bit: 0, bit_width: 5 } },
      { name: "__pad_3", slice: { start_bit: 0, bit_width: 7 } },
      { name: "base_ingress_port", slice: { start_bit: 0, bit_width: 9 } },
      { name: "__pad_4", slice: { start_bit: 0, bit_width: 7 } },
      { name: "dtel_egress_port", slice: { start_bit: 0, bit_width: 9 } },
      { name: "__pad_5", slice: { start_bit: 0, bit_width: 6 } },
      { name: "dtel_session_id", slice: { start_bit: 0, bit_width: 10 } }    ]
  }]

primitives: "./switch/pipe//switch.prim.json"
dynhash: "./switch/pipe//switch.dynhash.json"
